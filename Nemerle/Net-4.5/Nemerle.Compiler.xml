<?xml version="1.0"?>
<doc>
  <assembly>
    <name>c:\dev\open-source\nemerle\bin\Release\net-4.5\\Stage1\\Nemerle.Compiler.xml</name>
  </assembly>
  <members>
    <member name="T:Nemerle.Compiler.CompilationOptions" />
    <member name="M:Nemerle.Compiler.CompilationOptions._N_split_opt_24851(System.String)" />
    <member name="F:Nemerle.Compiler.CompilationOptions.OutputFileName" />
    <member name="F:Nemerle.Compiler.CompilationOptions.OutputPath" />
    <member name="F:Nemerle.Compiler.CompilationOptions.ProjectPath" />
    <member name="F:Nemerle.Compiler.CompilationOptions.RootNamespace" />
    <member name="F:Nemerle.Compiler.CompilationOptions.XmlDocOutputFileName" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DumpTypedTree" />
    <member name="F:Nemerle.Compiler.CompilationOptions.PrintExpressionsType" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DumpNamedMethod" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DumpDecisionTree" />
    <member name="F:Nemerle.Compiler.CompilationOptions.AdditionalDebug" />
    <member name="F:Nemerle.Compiler.CompilationOptions.TargetIsLibrary" />
    <member name="F:Nemerle.Compiler.CompilationOptions.TargetIsWinexe" />
    <member name="F:Nemerle.Compiler.CompilationOptions.IgnoreConfusion" />
    <member name="F:Nemerle.Compiler.CompilationOptions.ThrowOnError" />
    <member name="F:Nemerle.Compiler.CompilationOptions.GeneralTailCallOpt" />
    <member name="F:Nemerle.Compiler.CompilationOptions.ProgressBar" />
    <member name="F:Nemerle.Compiler.CompilationOptions.ColorMessages" />
    <member name="F:Nemerle.Compiler.CompilationOptions.UseLoadedCorlib" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DoNotLoadMacros" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DoNotLoadStdlib" />
    <member name="F:Nemerle.Compiler.CompilationOptions.EmitDebug" />
    <member name="F:Nemerle.Compiler.CompilationOptions.CompileToMemory" />
    <member name="F:Nemerle.Compiler.CompilationOptions.EarlyExit" />
    <member name="F:Nemerle.Compiler.CompilationOptions.GreedyReferences" />
    <member name="F:Nemerle.Compiler.CompilationOptions.IndentationSyntax" />
    <member name="F:Nemerle.Compiler.CompilationOptions.PersistentLibraries" />
    <member name="F:Nemerle.Compiler.CompilationOptions.MainClass" />
    <member name="F:Nemerle.Compiler.CompilationOptions.IsMainClassAutogenerated" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DoPrintStats" />
    <member name="F:Nemerle.Compiler.CompilationOptions.LexerStoreComments" />
    <member name="F:Nemerle.Compiler.CompilationOptions.Optimize" />
    <member name="F:Nemerle.Compiler.CompilationOptions.CheckIntegerOverflow" />
    <member name="F:Nemerle.Compiler.CompilationOptions.DisableExternalParsers" />
    <member name="F:Nemerle.Compiler.CompilationOptions.UnmanagedResource" />
    <member name="F:Nemerle.Compiler.CompilationOptions.LinkedResources" />
    <member name="F:Nemerle.Compiler.CompilationOptions.EmbeddedResources" />
    <member name="F:Nemerle.Compiler.CompilationOptions.ReferencedLibraries" />
    <member name="F:Nemerle.Compiler.CompilationOptions.LibraryPaths" />
    <member name="F:Nemerle.Compiler.CompilationOptions.MacrosToLoad" />
    <member name="F:Nemerle.Compiler.CompilationOptions.Sources" />
    <member name="F:Nemerle.Compiler.CompilationOptions.Platform" />
    <member name="F:Nemerle.Compiler.CompilationOptions.disabled_keywords" />
    <member name="F:Nemerle.Compiler.CompilationOptions._N_CommandDefines_5332" />
    <member name="M:Nemerle.Compiler.CompilationOptions.get_CommandDefines" />
    <member name="M:Nemerle.Compiler.CompilationOptions.set_CommandDefines(Nemerle.Collections.Map{System.String,System.Boolean})" />
    <member name="P:Nemerle.Compiler.CompilationOptions.CommandDefines" />
    <member name="F:Nemerle.Compiler.CompilationOptions.Warnings" />
    <member name="F:Nemerle.Compiler.CompilationOptions.MatchOptions" />
    <member name="F:Nemerle.Compiler.CompilationOptions._N_field_filename_embeded_in_StrongAssemblyKeyName_3515" />
    <member name="M:Nemerle.Compiler.CompilationOptions.get_StrongAssemblyKeyName" />
    <member name="M:Nemerle.Compiler.CompilationOptions.set_StrongAssemblyKeyName(System.String)" />
    <member name="P:Nemerle.Compiler.CompilationOptions.StrongAssemblyKeyName" />
    <member name="M:Nemerle.Compiler.CompilationOptions.Validate" />
    <member name="M:Nemerle.Compiler.CompilationOptions.#ctor" />
    <member name="M:Nemerle.Compiler.CompilationOptions.Clear" />
    <member name="M:Nemerle.Compiler.CompilationOptions.DisableKeyword(System.String,System.String)">
      <summary>
        <para>default null value for [in_namespace] means that keyword
 will be disabled in all namespaces

</para>
      </summary> <remarks><para>Note: only keywords introduced by syntax extensions can be disabled

</para></remarks></member>
    <member name="M:Nemerle.Compiler.CompilationOptions.IsKeywordDisabled(System.String,Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node})" />
    <member name="M:Nemerle.Compiler.CompilationOptions.DefineConstant(System.String)">
      <summary>
        <para>Adds given name as a command-line defined constant.
 It is then visible in all files just like defined preprocessor constant.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.CompilationOptions.UndefineConstant(System.String)">
      <summary>
        <para>Removes given name as a command-line defined constant.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.CompilationOptions.IsConstantDefined(System.String)">
      <summary>
        <para>Checks if given name was specified as command-line defined constant.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.CompilationOptions.ShouldDump(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.CompilationOptions.GetCommonOptions" />
    <member name="M:Nemerle.Compiler.CompilationOptions.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.WarningOptions">
      <summary>
        <para>Module used to enumerate and filter warnings emitted by compiler

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.WarningOptions.treat_warnings_as_errors" />
    <member name="F:Nemerle.Compiler.WarningOptions._N_field_cur_level_embeded_in_Level_3519" />
    <member name="M:Nemerle.Compiler.WarningOptions.get_Level" />
    <member name="M:Nemerle.Compiler.WarningOptions.set_Level(System.Int32)" />
    <member name="P:Nemerle.Compiler.WarningOptions.Level" />
    <member name="F:Nemerle.Compiler.WarningOptions.currently_enabled" />
    <member name="F:Nemerle.Compiler.WarningOptions.enabled" />
    <member name="F:Nemerle.Compiler.WarningOptions.disabled" />
    <member name="F:Nemerle.Compiler.WarningOptions.pragma_warning" />
    <member name="M:Nemerle.Compiler.WarningOptions.#ctor" />
    <member name="M:Nemerle.Compiler.WarningOptions.IsEnabled(System.Int32)">
      <summary>
        <para>Gives information if warning with given number should be emited by
        compiler.

</para>
      </summary>        <remarks><para>It depends on currently set warning level and enabled / disabled
        particular warnings.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.WarningOptions.IsEnabledAt(Nemerle.Compiler.Location,System.Int32)">
      <summary>
        <para>Check if given warning is enabled at a given location.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.WarningOptions.AddPragmaWarning(System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.WarningOptions.Enable(System.Int32)" />
    <member name="M:Nemerle.Compiler.WarningOptions.Disable(System.Int32)" />
    <member name="F:Nemerle.Compiler.WarningOptions.levels" />
    <member name="M:Nemerle.Compiler.WarningOptions.get_Help" />
    <member name="P:Nemerle.Compiler.WarningOptions.Help" />
    <member name="M:Nemerle.Compiler.WarningOptions.get_TreatWarningsAsErrors" />
    <member name="M:Nemerle.Compiler.WarningOptions.set_TreatWarningsAsErrors(System.Boolean)" />
    <member name="P:Nemerle.Compiler.WarningOptions.TreatWarningsAsErrors" />
    <member name="M:Nemerle.Compiler.WarningOptions.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.MatchCompilerOptions">
      <summary>
        <para>Match compiler options

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.MatchCompilerOptions.min_switch_size_for_variants" />
    <member name="F:Nemerle.Compiler.MatchCompilerOptions.min_switch_size_for_ordinals" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.#ctor" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.Clear" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.get_MinSwitchSizeForVariants" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.set_MinSwitchSizeForVariants(System.Int32)" />
    <member name="P:Nemerle.Compiler.MatchCompilerOptions.MinSwitchSizeForVariants" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.get_MinSwitchSizeForOrdinals" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.set_MinSwitchSizeForOrdinals(System.Int32)" />
    <member name="P:Nemerle.Compiler.MatchCompilerOptions.MinSwitchSizeForOrdinals" />
    <member name="M:Nemerle.Compiler.MatchCompilerOptions.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.CompilerEventHandler" />
    <member name="M:Nemerle.Compiler.CompilerEventHandler.BeginInvoke(Nemerle.Compiler.ManagerClass,System.AsyncCallback,System.Object)" />
    <member name="M:Nemerle.Compiler.CompilerEventHandler.EndInvoke(System.IAsyncResult)" />
    <member name="M:Nemerle.Compiler.CompilerEventHandler.Invoke(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.CompilerEventHandler.#ctor(System.Object,System.IntPtr)" />
    <member name="T:Nemerle.Compiler.CompilationAbortedException" />
    <member name="M:Nemerle.Compiler.CompilationAbortedException.#ctor" />
    <member name="M:Nemerle.Compiler.CompilationAbortedException.#ctor(System.String)" />
    <member name="M:Nemerle.Compiler.CompilationAbortedException.#ctor(System.String,System.Exception)" />
    <member name="M:Nemerle.Compiler.CompilationAbortedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
    <member name="M:Nemerle.Compiler.CompilationAbortedException.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ManagerClass" />
    <member name="M:Nemerle.Compiler.ManagerClass._N_resetChildren_28975(Nemerle.Compiler.ManagerClass._N_closureOf_CleanUpTypes_28969,Nemerle.Collections.Hashtable{System.String,Nemerle.Compiler.NamespaceTree.Node})" />
    <member name="M:Nemerle.Compiler.ManagerClass._N_tryEx_27871(Nemerle.Compiler.ManagerClass._N_closureOf_LoadExternalLibraries_27853,Nemerle.Builtins.FunctionVoid)" />
    <member name="M:Nemerle.Compiler.ManagerClass.#cctor" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_IsStop" />
    <member name="P:Nemerle.Compiler.ManagerClass.IsStop" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_TypesTreeVersion" />
    <member name="P:Nemerle.Compiler.ManagerClass.TypesTreeVersion" />
    <member name="F:Nemerle.Compiler.ManagerClass.ExtPointOverloadingRes" />
    <member name="F:Nemerle.Compiler.ManagerClass.Instance" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_SystemTypeCache_5503" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_SystemTypeCache" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_SystemTypeCache(Nemerle.Compiler.SystemTypeClass)" />
    <member name="P:Nemerle.Compiler.ManagerClass.SystemTypeCache" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_InternalType_5510" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_InternalType" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_InternalType(Nemerle.Compiler.InternalTypeClass)" />
    <member name="P:Nemerle.Compiler.ManagerClass.InternalType" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_AttributeCompiler_5517" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_AttributeCompiler" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_AttributeCompiler(Nemerle.Compiler.AttributeCompilerClass)" />
    <member name="P:Nemerle.Compiler.ManagerClass.AttributeCompiler" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_Stats_5524" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_Stats" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_Stats(Nemerle.Compiler.StatsClass)" />
    <member name="P:Nemerle.Compiler.ManagerClass.Stats" />
    <member name="F:Nemerle.Compiler.ManagerClass._solver" />
    <member name="M:Nemerle.Compiler.ManagerClass.SetSolver(Nemerle.Compiler.Solver)" />
    <member name="M:Nemerle.Compiler.ManagerClass.CheckSolver" />
    <member name="F:Nemerle.Compiler.ManagerClass.Hierarchy" />
    <member name="F:Nemerle.Compiler.ManagerClass.LibrariesManager" />
    <member name="F:Nemerle.Compiler.ManagerClass.NameTree" />
    <member name="F:Nemerle.Compiler.ManagerClass.CoreEnv" />
    <member name="F:Nemerle.Compiler.ManagerClass.MacrosRegistry" />
    <member name="F:Nemerle.Compiler.ManagerClass.Options" />
    <member name="F:Nemerle.Compiler.ManagerClass.MacroColors" />
    <member name="F:Nemerle.Compiler.ManagerClass.emptyTEnv" />
    <member name="F:Nemerle.Compiler.ManagerClass.componentsFactory" />
    <member name="F:Nemerle.Compiler.ManagerClass.doc_comments" />
    <member name="F:Nemerle.Compiler.ManagerClass.tyinfo_counter" />
    <member name="F:Nemerle.Compiler.ManagerClass.current_tyinfo_count" />
    <member name="F:Nemerle.Compiler.ManagerClass.current_pb_stage" />
    <member name="F:Nemerle.Compiler.ManagerClass.pb_killed" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_DelayedTypingsInProgress_5550" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_DelayedTypingsInProgress" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_DelayedTypingsInProgress(System.Boolean)" />
    <member name="P:Nemerle.Compiler.ManagerClass.DelayedTypingsInProgress" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_DelayedTypingsSecondPass_5557" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_DelayedTypingsSecondPass" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_DelayedTypingsSecondPass(System.Boolean)" />
    <member name="P:Nemerle.Compiler.ManagerClass.DelayedTypingsSecondPass" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_IsSpeculativeTyping_5564" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_IsSpeculativeTyping" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_IsSpeculativeTyping(System.Boolean)" />
    <member name="P:Nemerle.Compiler.ManagerClass.IsSpeculativeTyping" />
    <member name="F:Nemerle.Compiler.ManagerClass.NotResolvedNestedDelayedTypings" />
    <member name="F:Nemerle.Compiler.ManagerClass._N__N_event_field_of_ErrorOccured_3509" />
    <member name="M:Nemerle.Compiler.ManagerClass.add_ErrorOccured(Nemerle.Compiler.ManagerClass.MessageEventHandler)" />
    <member name="M:Nemerle.Compiler.ManagerClass.remove_ErrorOccured(Nemerle.Compiler.ManagerClass.MessageEventHandler)" />
    <member name="E:Nemerle.Compiler.ManagerClass.ErrorOccured" />
    <member name="F:Nemerle.Compiler.ManagerClass._N__N_event_field_of_WarningOccured_3510" />
    <member name="M:Nemerle.Compiler.ManagerClass.add_WarningOccured(Nemerle.Compiler.ManagerClass.MessageEventHandler)" />
    <member name="M:Nemerle.Compiler.ManagerClass.remove_WarningOccured(Nemerle.Compiler.ManagerClass.MessageEventHandler)" />
    <member name="E:Nemerle.Compiler.ManagerClass.WarningOccured" />
    <member name="F:Nemerle.Compiler.ManagerClass._N__N_event_field_of_MessageOccured_3511" />
    <member name="M:Nemerle.Compiler.ManagerClass.add_MessageOccured(Nemerle.Compiler.ManagerClass.MessageEventHandler)" />
    <member name="M:Nemerle.Compiler.ManagerClass.remove_MessageOccured(Nemerle.Compiler.ManagerClass.MessageEventHandler)" />
    <member name="E:Nemerle.Compiler.ManagerClass.MessageOccured" />
    <member name="M:Nemerle.Compiler.ManagerClass.BeginRelatedMessageSequence" />
    <member name="M:Nemerle.Compiler.ManagerClass.EndRelatedMessageSequence" />
    <member name="M:Nemerle.Compiler.ManagerClass.RequestOnBuildTypesTree" />
    <member name="F:Nemerle.Compiler.ManagerClass._N__N_event_field_of_CompilationStart_3512" />
    <member name="M:Nemerle.Compiler.ManagerClass.add_CompilationStart(Nemerle.Compiler.CompilerEventHandler)" />
    <member name="M:Nemerle.Compiler.ManagerClass.remove_CompilationStart(Nemerle.Compiler.CompilerEventHandler)" />
    <member name="E:Nemerle.Compiler.ManagerClass.CompilationStart" />
    <member name="F:Nemerle.Compiler.ManagerClass._N__N_event_field_of_TypeTreeBuildFinish_3513" />
    <member name="M:Nemerle.Compiler.ManagerClass.add_TypeTreeBuildFinish(Nemerle.Compiler.CompilerEventHandler)" />
    <member name="M:Nemerle.Compiler.ManagerClass.remove_TypeTreeBuildFinish(Nemerle.Compiler.CompilerEventHandler)" />
    <member name="E:Nemerle.Compiler.ManagerClass.TypeTreeBuildFinish" />
    <member name="F:Nemerle.Compiler.ManagerClass.IdToNameMap" />
    <member name="M:Nemerle.Compiler.ManagerClass.OnTypeTreeBuildFinish" />
    <member name="M:Nemerle.Compiler.ManagerClass.WrapWithCurrentContext(Nemerle.Builtins.FunctionVoid)" />
    <member name="M:Nemerle.Compiler.ManagerClass.CallAndResetList(Nemerle.Core.list{Nemerle.Builtins.FunctionVoid}@)" />
    <member name="F:Nemerle.Compiler.ManagerClass._beforeAddMembers" />
    <member name="M:Nemerle.Compiler.ManagerClass.OnBeforeAddMembers" />
    <member name="M:Nemerle.Compiler.ManagerClass.ExecBeforeAddMembers(Nemerle.Builtins.FunctionVoid)" />
    <member name="F:Nemerle.Compiler.ManagerClass._beforeWithTypedMembers" />
    <member name="M:Nemerle.Compiler.ManagerClass.OnBeforeWithTypedMembers" />
    <member name="M:Nemerle.Compiler.ManagerClass.ExecBeforeWithTypedMembers(Nemerle.Builtins.FunctionVoid)" />
    <member name="F:Nemerle.Compiler.ManagerClass._userData" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_UserData" />
    <member name="P:Nemerle.Compiler.ManagerClass.UserData" />
    <member name="F:Nemerle.Compiler.ManagerClass.sourceChangedHandlers" />
    <member name="M:Nemerle.Compiler.ManagerClass.NotifySourceChanged(Nemerle.Compiler.ISource)" />
    <member name="M:Nemerle.Compiler.ManagerClass.SubscribeSourceChanged(System.Int32,Nemerle.Compiler.ManagerClass.SourceChangedHandler,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ManagerClass.UnsubscribeSourceChanged(System.Int32,Nemerle.Compiler.ManagerClass.SourceChangedHandler)" />
    <member name="M:Nemerle.Compiler.ManagerClass.HasSourceChangedSubscribers(System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.UnsubscribeSourceChangedHandler(System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.UnsubscribeSourceChangedHandlers" />
    <member name="M:Nemerle.Compiler.ManagerClass.GetSource(System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.RunErrorOccured(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.RunWarningOccured(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.RunMessageOccured(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.InitOutput(System.IO.TextWriter)" />
    <member name="F:Nemerle.Compiler.ManagerClass.StaticTyVarId" />
    <member name="F:Nemerle.Compiler.ManagerClass.Typer_DT_Id" />
    <member name="F:Nemerle.Compiler.ManagerClass.Typer_checked_macro" />
    <member name="F:Nemerle.Compiler.ManagerClass.Typer_unchecked_macro" />
    <member name="F:Nemerle.Compiler.ManagerClass.Typer_yield_macro" />
    <member name="F:Nemerle.Compiler.ManagerClass.TyVar_reuse_queue" />
    <member name="F:Nemerle.Compiler.ManagerClass.TyVar_Id" />
    <member name="F:Nemerle.Compiler.ManagerClass.Util_Id" />
    <member name="F:Nemerle.Compiler.ManagerClass.AttributeMacroExpansion_global_nr" />
    <member name="F:Nemerle.Compiler.ManagerClass.Macros_in_pattern" />
    <member name="F:Nemerle.Compiler.ManagerClass.Message_ErrorCount" />
    <member name="F:Nemerle.Compiler.ManagerClass.Message_WarningCount" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_Message_emitted_hints_5664" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_Message_emitted_hints" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_Message_emitted_hints(Nemerle.Collections.Hashtable{System.String,System.Int32})" />
    <member name="P:Nemerle.Compiler.ManagerClass.Message_emitted_hints" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_Typer_BetterTypeCache_5671" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_Typer_BetterTypeCache" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_Typer_BetterTypeCache(Nemerle.Collections.Hashtable{Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo},System.Boolean})" />
    <member name="P:Nemerle.Compiler.ManagerClass.Typer_BetterTypeCache" />
    <member name="F:Nemerle.Compiler.ManagerClass.Message_output" />
    <member name="F:Nemerle.Compiler.ManagerClass._afterUsingDirectiveParse">
      <summary>
        <para>Called by parser when simple "using" directive parsed .
 name : list [string] - qualified identifier/
 prevEnv : GlobalEnv - GlobalEnv before adding current using directive.
 location : Location - location of qualified identifier.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.OnAfterUsingDirectiveParse(Nemerle.Compiler.Location,Nemerle.Core.list{System.String},Nemerle.Core.list{Nemerle.Compiler.Location},System.String,Nemerle.Compiler.Location,Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.GlobalEnv)" />
    <member name="F:Nemerle.Compiler.ManagerClass._beforeNamespaceParse" />
    <member name="M:Nemerle.Compiler.ManagerClass.OnBeforeNamespaceParse" />
    <member name="F:Nemerle.Compiler.ManagerClass._afterNamespaceParse" />
    <member name="M:Nemerle.Compiler.ManagerClass.OnAfterNamespaceParse(Nemerle.Compiler.Location,Nemerle.Core.list{System.String},Nemerle.Core.list{Nemerle.Compiler.Location},Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Location,Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.ManagerClass.FullResetNamespaceTree">
      <summary>
        <para>Clearing all variables used in typing process.
 Use this method only if we destroy NamespaceTree

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.GetNewId" />
    <member name="M:Nemerle.Compiler.ManagerClass.GetNewId(System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.GetIdName(System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.ResetCompilerState(Nemerle.Compiler.CompilationOptions)" />
    <member name="M:Nemerle.Compiler.ManagerClass.#ctor(Nemerle.Compiler.CompilationOptions)">
      <summary>
        <para>initialize pipelines with default values

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.MarkAsUsed(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.ManagerClass.MarkAsUsed(Nemerle.Compiler.IMember,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ManagerClass.MarkAsUsed(Nemerle.Compiler.IMember,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ManagerClass.MarkAsAssigned(Nemerle.Compiler.IField)" />
    <member name="M:Nemerle.Compiler.ManagerClass.MarkAsAssigned(Nemerle.Compiler.IField,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ManagerClass.CreateComponentsFactory" />
    <member name="F:Nemerle.Compiler.ManagerClass.ScanningPipeline">
      <summary>
        <para>Pipeline for adding namespaces and types hierarchy from parsed
        declarations.

</para>
      </summary>        <remarks><para>The list of declarations denotes the scope of one file, including
        using statements, etc. So the default pipeline passes enriched
        environment through declarations on the list.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.ManagerClass.Parser" />
    <member name="F:Nemerle.Compiler.ManagerClass._N__N_event_field_of_OnInit_3514" />
    <member name="M:Nemerle.Compiler.ManagerClass.add_OnInit(Nemerle.Compiler.ManagerClass.InitDelegate)" />
    <member name="M:Nemerle.Compiler.ManagerClass.remove_OnInit(Nemerle.Compiler.ManagerClass.InitDelegate)" />
    <member name="E:Nemerle.Compiler.ManagerClass.OnInit" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_GeneratedAssembly" />
    <member name="P:Nemerle.Compiler.ManagerClass.GeneratedAssembly" />
    <member name="M:Nemerle.Compiler.ManagerClass.MarkTypeBuilderCompiled" />
    <member name="F:Nemerle.Compiler.ManagerClass._isIntelliSenseMode">
      <summary>
        <para>True if compiler runing in IntelliSense mode. This disable some
 optimisations and anable lazy methods bodies compilation.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.ManagerClass._isCompletionInProgress">
      <summary>
        <para>True if now completion word in progress. This enable additional checks
 of completion tokens.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.ManagerClass._N_CompletionMarkLine_5727" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_CompletionMarkLine" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_CompletionMarkLine(System.Int32)" />
    <member name="P:Nemerle.Compiler.ManagerClass.CompletionMarkLine" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_CompletionMarkChar_5734" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_CompletionMarkChar" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_CompletionMarkChar(System.Int32)" />
    <member name="P:Nemerle.Compiler.ManagerClass.CompletionMarkChar" />
    <member name="F:Nemerle.Compiler.ManagerClass._completionParameterNames" />
    <member name="F:Nemerle.Compiler.ManagerClass._completionPattern" />
    <member name="F:Nemerle.Compiler.ManagerClass._completionLocation" />
    <member name="F:Nemerle.Compiler.ManagerClass._N_IsImportCompletion_5744" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_IsImportCompletion" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_IsImportCompletion(System.Boolean)" />
    <member name="P:Nemerle.Compiler.ManagerClass.IsImportCompletion" />
    <member name="M:Nemerle.Compiler.ManagerClass.ProgressBar(System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.KillProgressBar" />
    <member name="M:Nemerle.Compiler.ManagerClass.shouldCreate(System.Object)" />
    <member name="M:Nemerle.Compiler.ManagerClass.CleanUp" />
    <member name="M:Nemerle.Compiler.ManagerClass.InitCompiler" />
    <member name="M:Nemerle.Compiler.ManagerClass.LoadExternalLibraries" />
    <member name="M:Nemerle.Compiler.ManagerClass.LoadNemerleMacros" />
    <member name="M:Nemerle.Compiler.ManagerClass.Run">
      <summary>
        <para>Run passes of the compiler.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.Lookup(System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.LookupTypeInfo(System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.Lookup(System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.LookupTypeInfo(System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.ManagerClass.LookupSystemType(System.String)" />
    <member name="M:Nemerle.Compiler.ManagerClass.IsExtensionMethod(Nemerle.Compiler.IMethod,Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Return true if 'method' is extension method.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.Complete(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typer,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Process completion.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.CompletePattern(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typer.PatternTyper,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Process completion in patterns.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.ManagerClass.TypeKeywords" />
    <member name="M:Nemerle.Compiler.ManagerClass.CompleteTypeRef(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Process completion in type reference.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ManagerClass.CleanUpTypes" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_Solver" />
    <member name="P:Nemerle.Compiler.ManagerClass.Solver" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_ComponentsFactory" />
    <member name="P:Nemerle.Compiler.ManagerClass.ComponentsFactory" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_DocComments" />
    <member name="M:Nemerle.Compiler.ManagerClass.set_DocComments(Nemerle.Collections.Map{Nemerle.Compiler.Location,System.String})" />
    <member name="P:Nemerle.Compiler.ManagerClass.DocComments" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_IsIntelliSenseMode">
      <summary>
        <para>True if compiler runing in IntelliSense mode. This disable some
 optimisations and anable lazy methods bodies compilation.

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.ManagerClass.IsIntelliSenseMode" />
    <member name="M:Nemerle.Compiler.ManagerClass.get_IsCompletionInProgress">
      <summary>
        <para>True if now completion word in progress. This enable additional checks
 of completion tokens.

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.ManagerClass.IsCompletionInProgress" />
    <member name="M:Nemerle.Compiler.ManagerClass.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ManagerClass.MessageEventHandler" />
    <member name="T:Nemerle.Compiler.ManagerClass.SourceChangedHandler" />
    <member name="T:Nemerle.Compiler.ManagerClass.InitDelegate" />
    <member name="T:Nemerle.Compiler.TextPoint" />
    <member name="F:Nemerle.Compiler.TextPoint.Line" />
    <member name="F:Nemerle.Compiler.TextPoint.Column" />
    <member name="M:Nemerle.Compiler.TextPoint.op_Equality(Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.op_Inequality(Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.op_LessThan(Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.op_GreaterThan(Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.op_LessThanOrEqual(Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.op_GreaterThanOrEqual(Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.Offcet(Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.Offcet(System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.TextPoint.CompareTo(Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.TextPoint.ToString" />
    <member name="M:Nemerle.Compiler.TextPoint.#ctor(System.Int32,System.Int32)" />
    <member name="T:Nemerle.Compiler.Location" />
    <member name="M:Nemerle.Compiler.Location.#cctor" />
    <member name="F:Nemerle.Compiler.Location._isFileInIndentationSyntax" />
    <member name="F:Nemerle.Compiler.Location._files" />
    <member name="F:Nemerle.Compiler.Location._filesMap" />
    <member name="M:Nemerle.Compiler.Location.GetIndexArrayLength" />
    <member name="M:Nemerle.Compiler.Location.SetIndentationSyntaxForFile(System.Int32,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(System.Int32,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(System.String,Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(System.Int32,Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(Nemerle.Compiler.Location,System.Int32,System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.Location.#ctor(Nemerle.Compiler.Location,System.Int32,System.Int32)" />
    <member name="F:Nemerle.Compiler.Location.Default" />
    <member name="M:Nemerle.Compiler.Location.op_Equality(Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.op_Inequality(Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.op_Addition(Nemerle.Compiler.Location,Nemerle.Compiler.Location)">
      <summary>
        <para>This operator is not commutative!

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.AsGenerated" />
    <member name="M:Nemerle.Compiler.Location.AsGenerated(System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.AsGenerated(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.AsGenerated(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.get_IsGenerated" />
    <member name="P:Nemerle.Compiler.Location.IsGenerated" />
    <member name="M:Nemerle.Compiler.Location.MarkAsGenerated" />
    <member name="M:Nemerle.Compiler.Location.MarkAsFakeSorceAvailable" />
    <member name="M:Nemerle.Compiler.Location.AsFakeSorceAvailable" />
    <member name="M:Nemerle.Compiler.Location.get_IsGeneratedOrEmpty" />
    <member name="P:Nemerle.Compiler.Location.IsGeneratedOrEmpty" />
    <member name="M:Nemerle.Compiler.Location.get_IsSourceAvailable" />
    <member name="P:Nemerle.Compiler.Location.IsSourceAvailable" />
    <member name="M:Nemerle.Compiler.Location.get_IsSourceFileAvailable" />
    <member name="P:Nemerle.Compiler.Location.IsSourceFileAvailable" />
    <member name="M:Nemerle.Compiler.Location.GetFileName(System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.AddFile(System.String)">
      <summary>
        <para>Adds new filename to locations index. If filename in already in
        store, an error message is outputted.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.RemoveFile(System.String)">
      <summary>
        <para>Removes a filename from the location index
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.IsFileInIndentationSyntax(System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.GetFileIndex(System.String)">
      <summary>
        <para>Gets index of given filename in locations store. If one doesn't exist
        it is being added and new index is returned.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Location.AllMasks" />
    <member name="F:Nemerle.Compiler.Location.FileIndexMask" />
    <member name="F:Nemerle.Compiler.Location.FakeSourceMask" />
    <member name="F:Nemerle.Compiler.Location.GeneratedMask" />
    <member name="M:Nemerle.Compiler.Location.get_FileIndex" />
    <member name="P:Nemerle.Compiler.Location.FileIndex" />
    <member name="F:Nemerle.Compiler.Location._fileIndex" />
    <member name="F:Nemerle.Compiler.Location._line" />
    <member name="F:Nemerle.Compiler.Location._column" />
    <member name="M:Nemerle.Compiler.Location.get_Column" />
    <member name="P:Nemerle.Compiler.Location.Column" />
    <member name="F:Nemerle.Compiler.Location._endLine" />
    <member name="F:Nemerle.Compiler.Location._endColumn" />
    <member name="M:Nemerle.Compiler.Location.get_EndColumn" />
    <member name="P:Nemerle.Compiler.Location.EndColumn" />
    <member name="M:Nemerle.Compiler.Location.get_Begin" />
    <member name="P:Nemerle.Compiler.Location.Begin" />
    <member name="M:Nemerle.Compiler.Location.get_End" />
    <member name="P:Nemerle.Compiler.Location.End" />
    <member name="M:Nemerle.Compiler.Location.get_File" />
    <member name="P:Nemerle.Compiler.Location.File" />
    <member name="M:Nemerle.Compiler.Location.CompareTo(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.ToString" />
    <member name="M:Nemerle.Compiler.Location.Equals(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.GetHashCode" />
    <member name="M:Nemerle.Compiler.Location.FromStart" />
    <member name="M:Nemerle.Compiler.Location.FromStartAsGenerated" />
    <member name="M:Nemerle.Compiler.Location.FromEnd" />
    <member name="M:Nemerle.Compiler.Location.FromEndAsGenerated" />
    <member name="M:Nemerle.Compiler.Location.Contains(Nemerle.Compiler.TextPoint)" />
    <member name="M:Nemerle.Compiler.Location.Contains(System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.StrictlyContains(Nemerle.Compiler.Location)">
      <summary>
        <para>Returns whether the first location is strictly inside the second

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.Contains(Nemerle.Compiler.Location)">
      <summary>
        <para>Returns whether the first location is (not strictly) inside the second

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.StartsBefore(Nemerle.Compiler.Location)">
      <summary>
        <para>Returns whether the first location is (not strictly)
 before the second (the left of first is to the left of second)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.Contains(System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.EnclosingLocation(Nemerle.Core.list{Nemerle.Compiler.Location})">
      <summary>
        <para>The 'lst' must be ordered. This function test only first and last elements.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.EnclosingLocation``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Compiler.Location.TrimStart(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.TrimStart(Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Location.TrimEnd(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.Trim(Nemerle.Compiler.Location,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.Combine(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.Combine(Nemerle.Compiler.Located)" />
    <member name="M:Nemerle.Compiler.Location.IsIntersect(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.Intersect(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.IsEqualExcludingFile(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Location.get_IsEmpty" />
    <member name="P:Nemerle.Compiler.Location.IsEmpty" />
    <member name="M:Nemerle.Compiler.Location.IsNestedIn(Nemerle.Compiler.Location)">
      <summary>
        <para>True if second contain inside this location and them not equal.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.IndexOfMostNested2``1(System.Collections.Generic.IList{``0},System.Converter{``0,Nemerle.Compiler.Location},System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.Location.IndexOfMostNested``1(System.Collections.Generic.IList{``0},Nemerle.Builtins.Function{``0,Nemerle.Compiler.Location},System.Int32,System.Int32)">
      <summary>
        <para>Return index of object in seq which conain most nested Lication.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Location.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.Location.get_Line" />
    <member name="P:Nemerle.Compiler.Location.Line" />
    <member name="M:Nemerle.Compiler.Location.get_EndLine" />
    <member name="P:Nemerle.Compiler.Location.EndLine" />
    <member name="T:Nemerle.Compiler.Located" />
    <member name="F:Nemerle.Compiler.Located.loc" />
    <member name="M:Nemerle.Compiler.Located.#ctor" />
    <member name="M:Nemerle.Compiler.Located.#ctor(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Located.get_IsGenerated" />
    <member name="P:Nemerle.Compiler.Located.IsGenerated" />
    <member name="M:Nemerle.Compiler.Located.get_Location" />
    <member name="M:Nemerle.Compiler.Located.set_Location(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Located.Location" />
    <member name="M:Nemerle.Compiler.Located.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ParsedBase">
      <summary>
        <para>Root of parsed AST

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.ParsedBase._N_TypedObject_6052" />
    <member name="M:Nemerle.Compiler.ParsedBase.get_TypedObject" />
    <member name="M:Nemerle.Compiler.ParsedBase.set_TypedObject(Nemerle.Compiler.TypedBase)" />
    <member name="P:Nemerle.Compiler.ParsedBase.TypedObject" />
    <member name="M:Nemerle.Compiler.ParsedBase.ResetTypedObject" />
    <member name="M:Nemerle.Compiler.ParsedBase.SetTypedObject(Nemerle.Compiler.TypedBase)" />
    <member name="M:Nemerle.Compiler.ParsedBase.#ctor">
      <summary>
        <para>Root of parsed AST

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ParsedBase.#ctor(Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.TypedBase">
      <summary>
        <para>Root of parsed AST

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.TypedBase._N_ParsedObject_6067" />
    <member name="M:Nemerle.Compiler.TypedBase.get_ParsedObject" />
    <member name="M:Nemerle.Compiler.TypedBase.set_ParsedObject(Nemerle.Compiler.ParsedBase)" />
    <member name="P:Nemerle.Compiler.TypedBase.ParsedObject" />
    <member name="M:Nemerle.Compiler.TypedBase.SetParsedObject(Nemerle.Compiler.ParsedBase)" />
    <member name="M:Nemerle.Compiler.TypedBase.UpdateRelatedParsedObject" />
    <member name="M:Nemerle.Compiler.TypedBase.#ctor">
      <summary>
        <para>Root of parsed AST

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypedBase.#ctor(Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.NemerleAttributes" />
    <member name="T:Nemerle.Compiler.NemerleModifiers" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.value__" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.None" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Public" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Private" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.New" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Protected" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Abstract" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Virtual" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Sealed" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Static" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Mutable" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Internal" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Override" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Struct" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Macro" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Volatile" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.SpecialName" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Partial" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.Extern" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.CompilerMutable">
      <summary>
        <para>field is immutable, but compiler overrides it and can assign something

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.NemerleModifiers.VirtualityModifiers" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.OverrideModifiers" />
    <member name="F:Nemerle.Compiler.NemerleModifiers.AccessModifiers" />
    <member name="T:Nemerle.Compiler.Modifiers" />
    <member name="T:Nemerle.Compiler.AttributesAndModifiers" />
    <member name="F:Nemerle.Compiler.AttributesAndModifiers._N_CustomAttributesLocation_6082" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_CustomAttributesLocation" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.set_CustomAttributesLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.CustomAttributesLocation" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_Modifiers" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.set_Modifiers(Nemerle.Compiler.NemerleModifiers)" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.Modifiers" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_CustomAttributes" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.set_CustomAttributes(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.CustomAttributes" />
    <member name="F:Nemerle.Compiler.AttributesAndModifiers.mods" />
    <member name="F:Nemerle.Compiler.AttributesAndModifiers.custom_attrs" />
    <member name="F:Nemerle.Compiler.AttributesAndModifiers.macro_attrs" />
    <member name="F:Nemerle.Compiler.AttributesAndModifiers._N_field_parsed_custom_attrs_embeded_in_ParsedCustomAttributes_3508" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_ParsedCustomAttributes" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.set_ParsedCustomAttributes(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.ParsedCustomAttributes">
      <summary>
        <para>This property contains only custom attributes which parsed from sources. Macros can't modify it.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.AttributesAndModifiers._N_ParsedModifiers_6108">
      <summary>
        <para>This property contains only modifiers which parsed from sources. Macros can't modify it.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_ParsedModifiers" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.ParsedModifiers">
      <summary>
        <para>This property contains only modifiers which parsed from sources. Macros can't modify it.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_IsEmpty" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.IsEmpty" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.#ctor(Nemerle.Compiler.NemerleModifiers,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.#ctor" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.#ctor(Nemerle.Compiler.AttributesAndModifiers)">
      <summary>
        <para>For Clone()

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.Clone" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_Location" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.Location" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.get_Attributes" />
    <member name="P:Nemerle.Compiler.AttributesAndModifiers.Attributes" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.GetCustomAttributes" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.GetMacroAttributes" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.AddCustomAttribute(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.ToString" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.IsCustomAttributeDefined(System.String,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.FindAttribute(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Finds first attribute of specified type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.FindAttributeWithArgs(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Finds attribute of specified type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.FindAttributesWithArgs(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Finds all attributes of specified type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.AttributeTypes(Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.SaveCustomAttributes(Nemerle.Compiler.TypeBuilder,Nemerle.Builtins.Function{System.AttributeTargets,System.Reflection.Emit.CustomAttributeBuilder,System.Boolean,System.String})" />
    <member name="M:Nemerle.Compiler.AttributesAndModifiers.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Literal" />
    <member name="M:Nemerle.Compiler.Literal.#ctor" />
    <member name="F:Nemerle.Compiler.Literal._N_RawString_6154" />
    <member name="M:Nemerle.Compiler.Literal.get_RawString" />
    <member name="M:Nemerle.Compiler.Literal.set_RawString(System.String)" />
    <member name="P:Nemerle.Compiler.Literal.RawString" />
    <member name="M:Nemerle.Compiler.Literal.Equals(Nemerle.Compiler.Literal)" />
    <member name="M:Nemerle.Compiler.Literal.EscapeChar(System.Char)" />
    <member name="M:Nemerle.Compiler.Literal.EscapeString(System.String)" />
    <member name="M:Nemerle.Compiler.Literal.ToString">
      <summary>
        <para>Converts 'this' literal to an equivalent (lexable) string

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Literal.SystemType(Nemerle.Compiler.InternalTypeClass)" />
    <member name="M:Nemerle.Compiler.Literal.GetInternalType(Nemerle.Compiler.InternalTypeClass)" />
    <member name="M:Nemerle.Compiler.Literal.WithType(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Literal.WithProperType" />
    <member name="M:Nemerle.Compiler.Literal.AsObject(Nemerle.Compiler.InternalTypeClass)" />
    <member name="M:Nemerle.Compiler.Literal.get_AsInt" />
    <member name="P:Nemerle.Compiler.Literal.AsInt" />
    <member name="M:Nemerle.Compiler.Literal.get_AsRawInt" />
    <member name="P:Nemerle.Compiler.Literal.AsRawInt">
      <summary>
        <para>Returns plain integer value of Literal.Integer or Literal.Enum.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Literal.get_AsSByte" />
    <member name="P:Nemerle.Compiler.Literal.AsSByte" />
    <member name="M:Nemerle.Compiler.Literal.get_AsByte" />
    <member name="P:Nemerle.Compiler.Literal.AsByte" />
    <member name="M:Nemerle.Compiler.Literal.get_AsShort" />
    <member name="P:Nemerle.Compiler.Literal.AsShort" />
    <member name="M:Nemerle.Compiler.Literal.get_AsUShort" />
    <member name="P:Nemerle.Compiler.Literal.AsUShort" />
    <member name="M:Nemerle.Compiler.Literal.get_AsUInt" />
    <member name="P:Nemerle.Compiler.Literal.AsUInt" />
    <member name="M:Nemerle.Compiler.Literal.get_AsLong" />
    <member name="P:Nemerle.Compiler.Literal.AsLong" />
    <member name="M:Nemerle.Compiler.Literal.get_AsULong" />
    <member name="P:Nemerle.Compiler.Literal.AsULong" />
    <member name="M:Nemerle.Compiler.Literal.FromInt(System.Int32)" />
    <member name="M:Nemerle.Compiler.Literal.FromSByte(System.SByte)" />
    <member name="M:Nemerle.Compiler.Literal.FromByte(System.Byte)" />
    <member name="M:Nemerle.Compiler.Literal.FromShort(System.Int16)" />
    <member name="M:Nemerle.Compiler.Literal.FromUShort(System.UInt16)" />
    <member name="M:Nemerle.Compiler.Literal.FromUInt(System.UInt32)" />
    <member name="M:Nemerle.Compiler.Literal.FromLong(System.Int64)" />
    <member name="M:Nemerle.Compiler.Literal.FromULong(System.UInt64)" />
    <member name="M:Nemerle.Compiler.Literal.FromObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Literal.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.Literal._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Literal._N_GetVariantCodeSafe(Nemerle.Compiler.Literal)" />
    <member name="M:Nemerle.Compiler.Literal._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Literal.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Literal.Void" />
    <member name="T:Nemerle.Compiler.Literal.Null" />
    <member name="T:Nemerle.Compiler.Literal.String" />
    <member name="T:Nemerle.Compiler.Literal.Float" />
    <member name="T:Nemerle.Compiler.Literal.Double" />
    <member name="T:Nemerle.Compiler.Literal.Decimal" />
    <member name="T:Nemerle.Compiler.Literal.Char" />
    <member name="T:Nemerle.Compiler.Literal.Bool" />
    <member name="T:Nemerle.Compiler.Literal.Integer" />
    <member name="T:Nemerle.Compiler.Literal.Enum" />
    <member name="T:Nemerle.Compiler.FunBody" />
    <member name="M:Nemerle.Compiler.FunBody.#ctor" />
    <member name="M:Nemerle.Compiler.FunBody.ToString" />
    <member name="M:Nemerle.Compiler.FunBody._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.FunBody._N_GetVariantCodeSafe(Nemerle.Compiler.FunBody)" />
    <member name="M:Nemerle.Compiler.FunBody._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.FunBody.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.FunBody.Parsed" />
    <member name="T:Nemerle.Compiler.FunBody.Typed" />
    <member name="T:Nemerle.Compiler.FunBody.ILed" />
    <member name="T:Nemerle.Compiler.FunBody.Abstract" />
    <member name="T:Nemerle.Compiler.Token" />
    <member name="M:Nemerle.Compiler.Token.System#Collections#IEnumerable#GetEnumerator" />
    <member name="F:Nemerle.Compiler.Token.Location" />
    <member name="F:Nemerle.Compiler.Token.Next" />
    <member name="M:Nemerle.Compiler.Token.#ctor" />
    <member name="M:Nemerle.Compiler.Token.#ctor(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Token.ToString" />
    <member name="M:Nemerle.Compiler.Token.GetEnumerator" />
    <member name="M:Nemerle.Compiler.Token.ToString(System.Boolean)" />
    <member name="M:Nemerle.Compiler.Token._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Token._N_GetVariantCodeSafe(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.Token._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Token.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Token.Identifier" />
    <member name="T:Nemerle.Compiler.Token.QuotedIdentifier" />
    <member name="T:Nemerle.Compiler.Token.IdentifierToComplete" />
    <member name="T:Nemerle.Compiler.Token.Keyword" />
    <member name="T:Nemerle.Compiler.Token.Operator" />
    <member name="T:Nemerle.Compiler.Token.StringLiteral" />
    <member name="T:Nemerle.Compiler.Token.CharLiteral" />
    <member name="T:Nemerle.Compiler.Token.IntegerLiteral" />
    <member name="T:Nemerle.Compiler.Token.FloatLiteral" />
    <member name="T:Nemerle.Compiler.Token.DoubleLiteral" />
    <member name="T:Nemerle.Compiler.Token.DecimalLiteral" />
    <member name="T:Nemerle.Compiler.Token.Comment" />
    <member name="T:Nemerle.Compiler.Token.Semicolon" />
    <member name="T:Nemerle.Compiler.Token.Comma" />
    <member name="T:Nemerle.Compiler.Token.BeginBrace" />
    <member name="T:Nemerle.Compiler.Token.EndBrace" />
    <member name="T:Nemerle.Compiler.Token.BeginRound" />
    <member name="T:Nemerle.Compiler.Token.EndRound" />
    <member name="T:Nemerle.Compiler.Token.BeginSquare" />
    <member name="T:Nemerle.Compiler.Token.EndSquare" />
    <member name="T:Nemerle.Compiler.Token.BeginQuote" />
    <member name="T:Nemerle.Compiler.Token.EndQuote" />
    <member name="T:Nemerle.Compiler.Token.Indent" />
    <member name="T:Nemerle.Compiler.Token.WhiteSpace" />
    <member name="T:Nemerle.Compiler.Token.NewLine" />
    <member name="T:Nemerle.Compiler.Token.RoundGroup" />
    <member name="T:Nemerle.Compiler.Token.BracesGroup" />
    <member name="T:Nemerle.Compiler.Token.SquareGroup" />
    <member name="T:Nemerle.Compiler.Token.QuoteGroup" />
    <member name="T:Nemerle.Compiler.Token.LooseGroup" />
    <member name="T:Nemerle.Compiler.Token.Namespace" />
    <member name="T:Nemerle.Compiler.Token.Using" />
    <member name="T:Nemerle.Compiler.Token.EndOfFile" />
    <member name="T:Nemerle.Compiler.Token.EndOfGroup" />
    <member name="T:Nemerle.Compiler.Region" />
    <member name="M:Nemerle.Compiler.Region.#ctor(Nemerle.Compiler.Location,System.String)" />
    <member name="F:Nemerle.Compiler.Region.isComplete" />
    <member name="F:Nemerle.Compiler.Region.location" />
    <member name="F:Nemerle.Compiler.Region.text" />
    <member name="M:Nemerle.Compiler.Region.SetEndRegion(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Region.get_IsComplete" />
    <member name="P:Nemerle.Compiler.Region.IsComplete" />
    <member name="M:Nemerle.Compiler.Region.get_Location" />
    <member name="P:Nemerle.Compiler.Region.Location" />
    <member name="M:Nemerle.Compiler.Region.get_Text" />
    <member name="P:Nemerle.Compiler.Region.Text" />
    <member name="M:Nemerle.Compiler.Region.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LexerBase" />
    <member name="M:Nemerle.Compiler.LexerBase._N_special_33099(System.Char)">
      <summary>
        <para>we should have integer number here

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LexerBase._N_check_type_suffix_33093(Nemerle.Compiler.LexerBase._N_closureOf_get_number_32995,System.UInt64)" />
    <member name="M:Nemerle.Compiler.LexerBase._N_exponent_part_33059(Nemerle.Compiler.LexerBase._N_closureOf_get_number_32995,System.Boolean)" />
    <member name="M:Nemerle.Compiler.LexerBase._N_read_word_32357(Nemerle.Compiler.LexerBase._N_closureOf_parse_preprocessor_32335)" />
    <member name="M:Nemerle.Compiler.LexerBase._N_eat_spaces_32343(Nemerle.Compiler.LexerBase._N_closureOf_parse_preprocessor_32335)" />
    <member name="M:Nemerle.Compiler.LexerBase.#ctor(Nemerle.Compiler.ManagerClass,System.String)" />
    <member name="M:Nemerle.Compiler.LexerBase.get_LinesLengths" />
    <member name="P:Nemerle.Compiler.LexerBase.LinesLengths" />
    <member name="M:Nemerle.Compiler.LexerBase.get_LinesCount" />
    <member name="P:Nemerle.Compiler.LexerBase.LinesCount" />
    <member name="F:Nemerle.Compiler.LexerBase._N_IsEof_6635" />
    <member name="M:Nemerle.Compiler.LexerBase.get_IsEof" />
    <member name="M:Nemerle.Compiler.LexerBase.set_IsEof(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LexerBase.IsEof" />
    <member name="F:Nemerle.Compiler.LexerBase.incompleteRegions" />
    <member name="F:Nemerle.Compiler.LexerBase.regions" />
    <member name="M:Nemerle.Compiler.LexerBase.get_Location" />
    <member name="P:Nemerle.Compiler.LexerBase.Location" />
    <member name="F:Nemerle.Compiler.LexerBase.isPendingChar" />
    <member name="F:Nemerle.Compiler.LexerBase.pendingChar" />
    <member name="F:Nemerle.Compiler.LexerBase.line" />
    <member name="F:Nemerle.Compiler.LexerBase.col" />
    <member name="F:Nemerle.Compiler.LexerBase.file_idx" />
    <member name="F:Nemerle.Compiler.LexerBase._linesLengths" />
    <member name="F:Nemerle.Compiler.LexerBase._intoCode" />
    <member name="F:Nemerle.Compiler.LexerBase.Keywords" />
    <member name="F:Nemerle.Compiler.LexerBase.id_buffer" />
    <member name="F:Nemerle.Compiler.LexerBase.insert_location" />
    <member name="F:Nemerle.Compiler.LexerBase.tok_pending" />
    <member name="F:Nemerle.Compiler.LexerBase.counting_indentation" />
    <member name="F:Nemerle.Compiler.LexerBase.insert_indent" />
    <member name="F:Nemerle.Compiler.LexerBase.indent_string" />
    <member name="F:Nemerle.Compiler.LexerBase.in_indentation_mode" />
    <member name="M:Nemerle.Compiler.LexerBase.SwitchToIndentationMode" />
    <member name="M:Nemerle.Compiler.LexerBase.pragma_indent" />
    <member name="F:Nemerle.Compiler.LexerBase.white_beginning">
      <summary>
        <para>if there was only white chars from beginnig of line
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LexerBase.eating_stack" />
    <member name="F:Nemerle.Compiler.LexerBase.eating_now">
      <summary>
        <para>states:
     now processing:
      -4 region
      -3 else
      -1 if/elif
       0 no preprocessor
     not processing:
       1 if/elif, but some other block possibly will be processed
       2 if/elif, and other blocks won't be processed
        (there already was processed block, or parent block isn't processed)
       3 else
       4 region

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LexerBase.line_stack" />
    <member name="F:Nemerle.Compiler.LexerBase.line_start" />
    <member name="F:Nemerle.Compiler.LexerBase.file_real" />
    <member name="F:Nemerle.Compiler.LexerBase.defines" />
    <member name="F:Nemerle.Compiler.LexerBase.is_check_wrong_chars" />
    <member name="M:Nemerle.Compiler.LexerBase.BeginParseFile" />
    <member name="M:Nemerle.Compiler.LexerBase.IsKeyword(System.String)" />
    <member name="M:Nemerle.Compiler.LexerBase.GetToken" />
    <member name="M:Nemerle.Compiler.LexerBase.read_from_input" />
    <member name="M:Nemerle.Compiler.LexerBase.peek_or_white" />
    <member name="M:Nemerle.Compiler.LexerBase.peek" />
    <member name="M:Nemerle.Compiler.LexerBase.ignore_comments" />
    <member name="M:Nemerle.Compiler.LexerBase.comment_beginning" />
    <member name="M:Nemerle.Compiler.LexerBase.eat_whitespace">
      <summary>
        <para>returns true if there is some character in the input pending
 or false if we are at the end of file

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LexerBase.do_get_token" />
    <member name="M:Nemerle.Compiler.LexerBase.parse_preprocessor(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.LexerBase.read_or_eol" />
    <member name="M:Nemerle.Compiler.LexerBase.read" />
    <member name="M:Nemerle.Compiler.LexerBase.clear_id_buffer" />
    <member name="M:Nemerle.Compiler.LexerBase.get_op(System.Char)" />
    <member name="M:Nemerle.Compiler.LexerBase.get_op(System.Char,System.Char)" />
    <member name="M:Nemerle.Compiler.LexerBase.continue_get_op" />
    <member name="M:Nemerle.Compiler.LexerBase.get_number(System.Char)" />
    <member name="M:Nemerle.Compiler.LexerBase.get_id(System.Char)" />
    <member name="F:Nemerle.Compiler.LexerBase.get_char_from_hex" />
    <member name="F:Nemerle.Compiler.LexerBase.escape_value" />
    <member name="M:Nemerle.Compiler.LexerBase.get_char" />
    <member name="M:Nemerle.Compiler.LexerBase.get_string(System.Char,System.Boolean)" />
    <member name="M:Nemerle.Compiler.LexerBase.get_monkey_string" />
    <member name="M:Nemerle.Compiler.LexerBase.get_recursive_string">
      <summary>
        <para>Read &lt;# .... &lt;# ... #&gt; ... #&gt; string

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LexerBase.read_to_the_end_of_line(System.Boolean)" />
    <member name="M:Nemerle.Compiler.LexerBase.#cctor" />
    <member name="F:Nemerle.Compiler.LexerBase.opchars" />
    <member name="F:Nemerle.Compiler.LexerBase.BaseKeywords" />
    <member name="M:Nemerle.Compiler.LexerBase.IsIdBeginning(System.Char)" />
    <member name="M:Nemerle.Compiler.LexerBase.IsOperatorChar(System.Char)" />
    <member name="M:Nemerle.Compiler.LexerBase.IsOperator(System.String)" />
    <member name="M:Nemerle.Compiler.LexerBase.HasKeywordChars(System.String)" />
    <member name="M:Nemerle.Compiler.LexerBase.GetCharFromHex(System.Int32,System.Text.StringBuilder,Nemerle.Builtins.Function{System.Char},Nemerle.Builtins.Function{System.Char},Nemerle.Builtins.FunctionVoid{System.String})" />
    <member name="M:Nemerle.Compiler.LexerBase.EscapeValue(System.Char,System.Text.StringBuilder,Nemerle.Builtins.Function{System.Int32,System.Text.StringBuilder,System.Char},Nemerle.Builtins.FunctionVoid{System.String})" />
    <member name="M:Nemerle.Compiler.LexerBase.Fake" />
    <member name="M:Nemerle.Compiler.LexerBase.IsOperatorSpecial(System.Char)" />
    <member name="F:Nemerle.Compiler.LexerBase.Manager" />
    <member name="M:Nemerle.Compiler.LexerBase.get_InternalType" />
    <member name="P:Nemerle.Compiler.LexerBase.InternalType" />
    <member name="M:Nemerle.Compiler.LexerBase.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.LexerBase.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.LexerBase.__fake" />
    <member name="M:Nemerle.Compiler.LexerBase.get_IncompleteRegions" />
    <member name="P:Nemerle.Compiler.LexerBase.IncompleteRegions" />
    <member name="M:Nemerle.Compiler.LexerBase.get_Regions" />
    <member name="P:Nemerle.Compiler.LexerBase.Regions" />
    <member name="M:Nemerle.Compiler.LexerBase.get_InIndentationMode" />
    <member name="P:Nemerle.Compiler.LexerBase.InIndentationMode" />
    <member name="M:Nemerle.Compiler.LexerBase.get_Defines" />
    <member name="P:Nemerle.Compiler.LexerBase.Defines" />
    <member name="M:Nemerle.Compiler.LexerBase.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LexerBase.NumberMode" />
    <member name="T:Nemerle.Compiler.LexerBase.Error" />
    <member name="T:Nemerle.Compiler.LexerBase.PragmaIndent" />
    <member name="T:Nemerle.Compiler.LexerStringBase" />
    <member name="F:Nemerle.Compiler.LexerStringBase.reader" />
    <member name="F:Nemerle.Compiler.LexerStringBase.pos" />
    <member name="M:Nemerle.Compiler.LexerStringBase.#ctor(Nemerle.Compiler.ManagerClass,System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.LexerStringBase.peek" />
    <member name="M:Nemerle.Compiler.LexerStringBase.peek_or_white" />
    <member name="M:Nemerle.Compiler.LexerStringBase.read_from_input" />
    <member name="T:Nemerle.Compiler.LexerFile" />
    <member name="M:Nemerle.Compiler.LexerFile._N_loop1_33764(Nemerle.Compiler.LexerFile._N_closureOf_comment_beginning_33734,System.Boolean,System.Boolean)" />
    <member name="F:Nemerle.Compiler.LexerFile.comment_loc" />
    <member name="F:Nemerle.Compiler.LexerFile.currentComment" />
    <member name="M:Nemerle.Compiler.LexerFile.#ctor(Nemerle.Compiler.ManagerClass,System.Int32,System.String)" />
    <member name="M:Nemerle.Compiler.LexerFile.comment_beginning" />
    <member name="M:Nemerle.Compiler.LexerFile.ignore_comments" />
    <member name="M:Nemerle.Compiler.LexerFile.GetToken" />
    <member name="M:Nemerle.Compiler.LexerFile.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LexerString" />
    <member name="M:Nemerle.Compiler.LexerString._N_loop1_33892(Nemerle.Compiler.LexerString._N_closureOf_comment_beginning_33854,System.Boolean,System.Boolean)" />
    <member name="F:Nemerle.Compiler.LexerString.comment_loc" />
    <member name="F:Nemerle.Compiler.LexerString.currentComment" />
    <member name="F:Nemerle.Compiler.LexerString.CommentLocations" />
    <member name="M:Nemerle.Compiler.LexerString.#ctor(Nemerle.Compiler.ManagerClass,System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.LexerString.comment_beginning" />
    <member name="M:Nemerle.Compiler.LexerString.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LexerCompletion" />
    <member name="M:Nemerle.Compiler.LexerCompletion._N_resetCompletionMark_33947(Nemerle.Compiler.LexerCompletion._N_closureOf_GetToken_33939)" />
    <member name="F:Nemerle.Compiler.LexerCompletion.CompletionMarkLine" />
    <member name="F:Nemerle.Compiler.LexerCompletion.CompletionMarkChar" />
    <member name="M:Nemerle.Compiler.LexerCompletion.#ctor(Nemerle.Compiler.ManagerClass,System.String,Nemerle.Compiler.Location,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.LexerCompletion.GetToken" />
    <member name="T:Nemerle.Compiler.GrammarElement">
      <summary>
        <para>Nodes representing a tree of syntax extension definition.

</para>
      </summary>      <remarks><para>Macros contain list of elements of grammar to describe syntax extensions,
      which they introduce.
      Later, parser is reading those lists and merge them into current
      tree of syntax extensions, which can have branches and contain macro call
      definitions in leaves.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.GrammarElement.Next">
      <summary>
        <para>Next element in grammar tree. It is used only in merged
 trees created by parser

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.GrammarElement.Target" />
    <member name="M:Nemerle.Compiler.GrammarElement.#ctor" />
    <member name="M:Nemerle.Compiler.GrammarElement.#ctor(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.GrammarElement.#ctor(Nemerle.Compiler.GrammarElement,System.AttributeTargets)" />
    <member name="M:Nemerle.Compiler.GrammarElement.CloneWithNext(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.GrammarElement.AddBranch(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.GrammarElement.Equals(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.GrammarElement.ToStringWhole" />
    <member name="M:Nemerle.Compiler.GrammarElement.ToString" />
    <member name="M:Nemerle.Compiler.GrammarElement.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.GrammarElement._N_GetVariantCode">
      <summary>
        <para>Nodes representing a tree of syntax extension definition.

</para>
      </summary>      <remarks><para>Macros contain list of elements of grammar to describe syntax extensions,
      which they introduce.
      Later, parser is reading those lists and merge them into current
      tree of syntax extensions, which can have branches and contain macro call
      definitions in leaves.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.GrammarElement._N_GetVariantCodeSafe(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.GrammarElement._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.GrammarElement.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.GrammarElement.Operator" />
    <member name="T:Nemerle.Compiler.GrammarElement.Keyword" />
    <member name="T:Nemerle.Compiler.GrammarElement.Expression" />
    <member name="T:Nemerle.Compiler.GrammarElement.Parameter" />
    <member name="T:Nemerle.Compiler.GrammarElement.RawToken" />
    <member name="T:Nemerle.Compiler.GrammarElement.ExpressionList" />
    <member name="T:Nemerle.Compiler.GrammarElement.Optional" />
    <member name="T:Nemerle.Compiler.GrammarElement.Branch" />
    <member name="T:Nemerle.Compiler.GrammarElement.End" />
    <member name="T:Nemerle.Compiler.SyntaxDefinition">
      <summary>
        <para>Definition of syntax extension, which given macro introduces.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.SyntaxDefinition.Start" />
    <member name="F:Nemerle.Compiler.SyntaxDefinition.Keywords" />
    <member name="F:Nemerle.Compiler.SyntaxDefinition.MacroNamespace" />
    <member name="F:Nemerle.Compiler.SyntaxDefinition.Tree" />
    <member name="F:Nemerle.Compiler.SyntaxDefinition.Permute" />
    <member name="M:Nemerle.Compiler.SyntaxDefinition.#ctor(System.String,Nemerle.Core.list{System.String},Nemerle.Compiler.NamespaceTree.Node,Nemerle.Compiler.GrammarElement,Nemerle.Builtins.Function{Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement},Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement}})">
      <summary>
        <para>Definition of syntax extension, which given macro introduces.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.SyntaxDefinition.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.OperatorDefinition" />
    <member name="F:Nemerle.Compiler.OperatorDefinition.Left" />
    <member name="F:Nemerle.Compiler.OperatorDefinition.Right" />
    <member name="M:Nemerle.Compiler.OperatorDefinition.#ctor(Nemerle.Compiler.NamespaceTree.Node,System.String,System.Int32,System.Int32,System.Boolean)" />
    <member name="T:Nemerle.Compiler.MainParser" />
    <member name="M:Nemerle.Compiler.MainParser._N_tryMakeDollarised_38518(Nemerle.Compiler.MainParser._N_closureOf_makeStrsConcat_38495)" />
    <member name="M:Nemerle.Compiler.MainParser._N_makeStrsConcat_38489(Nemerle.Compiler.MainParser._N_closureOf_parse_expr_sequence_38470,Nemerle.Compiler.Token,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MainParser._N_isStr_38475(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser._N_push_38359``1(Nemerle.Compiler.MainParser._N_closureOf_parse_quotation_38333,System.String,Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.MainParser._N_ReportError_37727(Nemerle.Compiler.MainParser._N_closureOf_loop2_37719,Nemerle.Compiler.Token,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MainParser._N_loop2_37713(Nemerle.Compiler.MainParser._N_closureOf_parse_match_case_37703,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.MainParser._N_create_typarms_37041(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Core.list{Nemerle.Compiler.Parsetree.Constraint})" />
    <member name="M:Nemerle.Compiler.MainParser._N_add_and_loop_36911(Nemerle.Compiler.MainParser._N_closureOf_loop_36895,Nemerle.Compiler.MainParser._N_closureOf_get_modifiers_36881,Nemerle.Compiler.NemerleModifiers)" />
    <member name="M:Nemerle.Compiler.MainParser._N_loop_36889(Nemerle.Compiler.MainParser._N_closureOf_get_modifiers_36881,Nemerle.Compiler.NemerleModifiers)" />
    <member name="M:Nemerle.Compiler.MainParser._N_mekeNewSplicable_36626(Nemerle.Compiler.Parsetree.PExpr,System.String,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MainParser._N_redirect_36369(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.Name,Nemerle.Core.option{Nemerle.Compiler.Parsetree.ClassMember.Function})" />
    <member name="M:Nemerle.Compiler.MainParser._N_make_option_36219(Nemerle.Compiler.MainParser._N_closureOf_parse_option_36209,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Token,Nemerle.Compiler.Location,Nemerle.Compiler.Token.BracesGroup)" />
    <member name="M:Nemerle.Compiler.MainParser._N_parseNestedTypeDeclaration_36012(Nemerle.Compiler.MainParser._N_closureOf_ParseClassMember_35984)" />
    <member name="M:Nemerle.Compiler.MainParser._N__N_lambda__35666_35864(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.MainParser._N_errTypeExpected_35763(Nemerle.Compiler.MainParser._N_closureOf_processType_35745,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser._N_processType_35739(Nemerle.Compiler.MainParser._N_closureOf_ParseTypeDeclaration_35727,System.String)" />
    <member name="M:Nemerle.Compiler.MainParser._N_expect_close_34811(Nemerle.Compiler.MainParser._N_closureOf_loop_34777,Nemerle.Compiler.MainParser._N_closureOf_parse_grammar_rule_34744,Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.MainParser._N_loop_34771(Nemerle.Compiler.MainParser._N_closureOf_parse_grammar_rule_34744,Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement},Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.MainParser._N_expect_semicolon_34756(Nemerle.Compiler.MainParser._N_closureOf_parse_grammar_rule_34744)" />
    <member name="M:Nemerle.Compiler.MainParser._N_eat_definition_34568(Nemerle.Compiler.MainParser._N_closureOf_parse_top_extensions_34539,Nemerle.Compiler.SyntaxDefinition)" />
    <member name="M:Nemerle.Compiler.MainParser.load_syntax(Nemerle.Core.list{Nemerle.Compiler.SyntaxDefinition},Nemerle.Collections.Map{System.String,Nemerle.Compiler.GrammarElement})">
      <summary>
        <para>This functions loads given syntax extensions into current syntax
        tree. Overlaping definitions are merged if possible.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.MergeSyntax(Nemerle.Compiler.GrammarElement,Nemerle.Compiler.GrammarElement,Nemerle.Compiler.SyntaxDefinition)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_top_extensions(Nemerle.Compiler.AttributesAndModifiers,System.AttributeTargets)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_syntax_definition(Nemerle.Compiler.GrammarElement,Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.matches_stream(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.MainParser.create_optional_holders(Nemerle.Compiler.GrammarElement,Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement})">
      <summary>
        <para>add empty syntax elements, which were ommited in this grammar branch

</para>
      </summary> <remarks><para>this function should probably be extended ;-)

</para></remarks></member>
    <member name="M:Nemerle.Compiler.MainParser.parse_grammar_rule(Nemerle.Compiler.GrammarElement,Nemerle.Compiler.TokenStoppers,System.AttributeTargets)" />
    <member name="F:Nemerle.Compiler.MainParser.env" />
    <member name="F:Nemerle.Compiler.MainParser.in_variant" />
    <member name="F:Nemerle.Compiler.MainParser.stream" />
    <member name="F:Nemerle.Compiler.MainParser.last_tok" />
    <member name="F:Nemerle.Compiler.MainParser.streams_stack" />
    <member name="M:Nemerle.Compiler.MainParser.#ctor(Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Creates the instance of parsing engine with given environment
        (set of imported namespaces and entered ones)

</para>
      </summary>        <remarks><para>Parser instance is created with syntax extensions from Nemerle.Core namespace
        (which is always open by default).

</para></remarks></member>
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.GlobalEnv,System.String,System.Boolean)">
      <summary>
        <para>Parse given string as expression, given context in which this
        expression is situated.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.GlobalEnv,System.String,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseCommaSeparatedExprList(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.LexerBase,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.LexerBase,System.Boolean)">
      <summary>
        <para>Parse expression given lexer producing its content and context in which this
        expression is situated.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Token,Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.Token,Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseMember(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.LexerBase,System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseExpr(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.LexerBase,Nemerle.Compiler.Parsetree.PFunHeader)">
      <summary>
        <para>Parse function body expression given lexer producing its content
 and context in which this expression is situated.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.ParseFunctionBody(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PFunHeader,Nemerle.Compiler.Token.BracesGroup)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseFunParms(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Token.RoundGroup)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseTyVars(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseWhereConstraints(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Token,Nemerle.Builtins.Tuple{Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Location})" />
    <member name="M:Nemerle.Compiler.MainParser.Parse(Nemerle.Compiler.LexerBase)">
      <summary>
        <para>Parse well formed source code of toplevel program, using the given instance
 of [LexerBase] for obtaining tokens.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.Parse(Nemerle.Compiler.LexerBase,Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.Token})">
      <summary>
        <para>Parse well formed source code of toplevel program, using the given instance
 of [LexerBase] for obtaining tokens and invoke tokenHandler parameter function
 on the top-level token of given source.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.IsTopLevel(Nemerle.Compiler.Token.LooseGroup)" />
    <member name="M:Nemerle.Compiler.MainParser.push_stream(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.pop_stream" />
    <member name="M:Nemerle.Compiler.MainParser.pop_stream(System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.get_token" />
    <member name="M:Nemerle.Compiler.MainParser.peek_token" />
    <member name="M:Nemerle.Compiler.MainParser.peek_second_token" />
    <member name="M:Nemerle.Compiler.MainParser.peek_sibling_token" />
    <member name="M:Nemerle.Compiler.MainParser.jump_to_sibling" />
    <member name="M:Nemerle.Compiler.MainParser.shift_sibling" />
    <member name="M:Nemerle.Compiler.MainParser.new_group_beginning" />
    <member name="M:Nemerle.Compiler.MainParser.calc_group_location(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.push_back" />
    <member name="M:Nemerle.Compiler.MainParser.shift" />
    <member name="M:Nemerle.Compiler.MainParser.expect_empty(System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.expect_operator(System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.flag_keyword(System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.flag_sibling_keyword(System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.should_stop(Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.should_stop(Nemerle.Compiler.Token,Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.comma_separated_list``1(Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.MainParser.ParseClassMembers``1(Nemerle.Compiler.Token,System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.process_groups``1(Nemerle.Compiler.Token,System.String,Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.MainParser.fatal_error(Nemerle.Compiler.Token,System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.fatal_error(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.Error(Nemerle.Compiler.Token,System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.MkNameGenerated(System.String)" />
    <member name="M:Nemerle.Compiler.MainParser.MkName(System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.MkSplicableName(System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.MkTempName(System.String,System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.MkTempSplicableName(System.String,System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.MkWildcardSplicableName(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.TokenMap``1(Nemerle.Compiler.Token,Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.MainParser.get_splicable_id" />
    <member name="M:Nemerle.Compiler.MainParser.ParseTopLevel(Nemerle.Compiler.Token.LooseGroup,Nemerle.Core.list{Nemerle.Compiler.Parsetree.TopDeclaration})">
      <summary>
        <para>This function parses top level group updating global environment
        when entering into new namespace, using directive, class, etc.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.eat_assembly_attributes(Nemerle.Compiler.Token.LooseGroup)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseTypeDeclaration(Nemerle.Compiler.Token)">
      <summary>
        <para>Parses toplevel type (like class, interface, etc.).
        Expects [toks] to be first token in type declaration.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.ParseTypeDeclaration(Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Location)">
      <summary>
        <para>Parses toplevel type (like class, interface, etc.).
        We are inside stream with modifiers and custom attributes already read.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.ParseClassMember(System.String,System.Collections.Generic.List{Nemerle.Compiler.Parsetree.ClassMember})" />
    <member name="M:Nemerle.Compiler.MainParser.parse_method(Nemerle.Compiler.Parsetree.PFunHeader,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.MainParser.CombineLocations(Nemerle.Compiler.Token,Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.CombineLocations(Nemerle.Compiler.Location,Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.InitBodyLocations(Nemerle.Compiler.Parsetree.MemberBase,Nemerle.Compiler.Token.BracesGroup)" />
    <member name="M:Nemerle.Compiler.MainParser.InitBodyLocations(Nemerle.Compiler.Parsetree.MemberBase,Nemerle.Compiler.Token.BracesGroup,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.TryPeekBracesGroup" />
    <member name="M:Nemerle.Compiler.MainParser.parse_option(Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_accessor_body(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.MainParser.parse_property(System.String,System.Collections.Generic.List{Nemerle.Compiler.Parsetree.ClassMember},Nemerle.Compiler.Location,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Core.list{Nemerle.Compiler.Token.SquareGroup},Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter},Nemerle.Compiler.Parsetree.Typarms,Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseFunctionOrExpression(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})">
      <summary>
        <para>Parses function or single expression as function

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.ParseBlockOrExpression(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})">
      <summary>
        <para>Parses block or single expression

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.IsAutoGeneratedProperty(Nemerle.Compiler.Parsetree.ClassMember.Property)" />
    <member name="M:Nemerle.Compiler.MainParser.ValidateNoPropertyInitializer(Nemerle.Compiler.Parsetree.ClassMember.Property)" />
    <member name="M:Nemerle.Compiler.MainParser.TryExpandAutoproperty(Nemerle.Compiler.Parsetree.ClassMember.Property)" />
    <member name="M:Nemerle.Compiler.MainParser.CalcTokenLocation(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.AddPrefixToSplicable(System.String,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Location,System.Boolean)">
      <summary>
        <para>Adds string prefix to splice.
      It is used to generate event field name and accessor method names.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.parse_event(Nemerle.Compiler.Location,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Core.list{Nemerle.Compiler.Token.SquareGroup})">
      <summary>
        <para>Parse event definition from the place after 'event' keyword
        name {
          add {  }
          remove { }
          potentially many field definitions
        }

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.maybe_parse_ellipsis" />
    <member name="M:Nemerle.Compiler.MainParser.get_customs" />
    <member name="M:Nemerle.Compiler.MainParser.take_attributes_out(Nemerle.Core.list{Nemerle.Compiler.Token.SquareGroup}@,System.AttributeTargets,System.Boolean,Nemerle.Compiler.AttributesAndModifiers)">
      <summary>
        <para>allowed targets are:
          assembly: assembly
          module:  module   (not supprted currently)
          class, struct, interface, enum: type
          delegate: type, return
          method: method, return
          parameter: param
          field: field
          property indexer: property
          property get accessor: method, return
          property set accessor: method, param, return
          event field: event, field, method
          event property: event, property (what is this?)
          event add: method, param
          event remove: method, param

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.get_modifiers" />
    <member name="M:Nemerle.Compiler.MainParser.parse_tyvars" />
    <member name="M:Nemerle.Compiler.MainParser.parse_where_constraints(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Location)">
      <summary>
        <para>`splicing_type' is for noting, that there are spliced tyvars
 if yes, it's PType.Spliced with expression describing their list
 else it's PType.Void ()

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.parse_fun_header(Nemerle.Compiler.Parsetree.Splicable,System.Boolean)">
      <summary>
        <para>Parse plain functional header (with optional '[..]' generic parameters
                                 and '(..)' fun parameters)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.parse_parameter" />
    <member name="M:Nemerle.Compiler.MainParser.parse_parameter(System.Boolean)">
      <summary>
        <para>Parse function parameter definition from given LooseGroup
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.parse_parameters(System.Boolean,System.Boolean)">
      <summary>
        <para>parameters of (a:foo,b,c) or [a,b:foo,c] kind

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.parse_return_type(System.Boolean,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.ParseBlock(Nemerle.Compiler.Token.BracesGroup,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.MainParser.parse_block(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})">
      <summary>
        <para>parse {...} or $body - usually it is a body of method

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MainParser.make_splicable(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MainParser.make_operator_call(System.String,Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MainParser.make_operator_call(System.String,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MainParser.make_operator_call(System.String,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.MainParser.roll_exprs(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr}@,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.MainParser.roll_operators(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr}@,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.MainParser.OperatorInfo,Nemerle.Compiler.Location}}@,System.Int32)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_expr" />
    <member name="M:Nemerle.Compiler.MainParser.parse_expr(Nemerle.Compiler.TokenStoppers)">
      <summary>
        <para>Parse expression from current stream of tokens.
        Reading is terminated before every token from [stop].

</para>
      </summary>        <remarks><para>This is the top expression parsing method, it uses infix to RPN method
        to parse operators and [parse_embedded_expr] to parse expression in between.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.MainParser.is_operator_or_stoper(Nemerle.Compiler.Token,Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_literal" />
    <member name="M:Nemerle.Compiler.MainParser.parse_spliced_expr" />
    <member name="M:Nemerle.Compiler.MainParser.parse_match_case" />
    <member name="M:Nemerle.Compiler.MainParser.parse_embedded_expr(Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_quotation" />
    <member name="M:Nemerle.Compiler.MainParser.parse_expr_sequence(Nemerle.Compiler.TokenStoppers)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_expr_sequence(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.MainParser.parse_expr_sequence(Nemerle.Compiler.Token,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.MainParser.parse_expr_sequence(Nemerle.Compiler.TokenStoppers,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})">
      <summary>
        <para>special function to parse sequence in a way allowing other functions
        switching to sibling LooseGroup of tokens. Like:
          LooseGroup (..a b c..); LooseGroup (d..)

</para>
      </summary>        <remarks><para>It assumes that the token in current [stream] is a LooseGroup, and
        reads this and all following LooseGroups as expressions.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.MainParser.Manager">
      <summary>
        <para>Parser class, which transforms preparsed token tree into Nemerle parse trees.

</para>
      </summary>      <remarks><para>It also contains some helper methods to perform operation needed to parse
      string as expression or entire file given [LexerBase] instance.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.MainParser.get_InternalType" />
    <member name="P:Nemerle.Compiler.MainParser.InternalType" />
    <member name="M:Nemerle.Compiler.MainParser.get_SystemTypeCache">
      <summary>
        <para>Parser class, which transforms preparsed token tree into Nemerle parse trees.

</para>
      </summary>      <remarks><para>It also contains some helper methods to perform operation needed to parse
      string as expression or entire file given [LexerBase] instance.

</para></remarks></member>
    <member name="P:Nemerle.Compiler.MainParser.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.MainParser.__fake">
      <summary>
        <para>Parser class, which transforms preparsed token tree into Nemerle parse trees.

</para>
      </summary>      <remarks><para>It also contains some helper methods to perform operation needed to parse
      string as expression or entire file given [LexerBase] instance.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.MainParser.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.MainParser.OperatorInfo">
      <summary>
        <para>Reverse Polish Notation token. It is used on the stack created during translation
 of infix operator expression into RPN on the way to create appropriate PExpr.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.MainParser.UnaryOperatorInfo" />
    <member name="T:Nemerle.Compiler.MainParser.BinaryOperatorInfo" />
    <member name="T:Nemerle.Compiler.MainParser.NaryOperatorInfo" />
    <member name="T:Nemerle.Compiler.OpContext" />
    <member name="F:Nemerle.Compiler.OpContext.value__" />
    <member name="F:Nemerle.Compiler.OpContext.Prefix" />
    <member name="F:Nemerle.Compiler.OpContext.Postfix" />
    <member name="T:Nemerle.Compiler.TokenStoppers" />
    <member name="F:Nemerle.Compiler.TokenStoppers.value__" />
    <member name="F:Nemerle.Compiler.TokenStoppers.None" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Pipe" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Equal" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Braces" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Arrow" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Colon" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Dollar" />
    <member name="F:Nemerle.Compiler.TokenStoppers.Where" />
    <member name="F:Nemerle.Compiler.TokenStoppers.All" />
    <member name="T:Nemerle.Compiler.IParser" />
    <member name="M:Nemerle.Compiler.IParser.Parse(Nemerle.Compiler.ISource)" />
    <member name="T:Nemerle.Compiler.ParseResult" />
    <member name="F:Nemerle.Compiler.ParseResult._N_TopDeclarations_7206" />
    <member name="M:Nemerle.Compiler.ParseResult.get_TopDeclarations" />
    <member name="P:Nemerle.Compiler.ParseResult.TopDeclarations" />
    <member name="M:Nemerle.Compiler.ParseResult.get_CommentLocations" />
    <member name="P:Nemerle.Compiler.ParseResult.CommentLocations" />
    <member name="M:Nemerle.Compiler.ParseResult.get_Location" />
    <member name="P:Nemerle.Compiler.ParseResult.Location" />
    <member name="M:Nemerle.Compiler.ParseResult.get_Regions" />
    <member name="P:Nemerle.Compiler.ParseResult.Regions" />
    <member name="M:Nemerle.Compiler.ParseResult.get_LinesLengths" />
    <member name="P:Nemerle.Compiler.ParseResult.LinesLengths" />
    <member name="M:Nemerle.Compiler.ParseResult.#ctor(Nemerle.Core.list{Nemerle.Compiler.Parsetree.TopDeclaration})" />
    <member name="M:Nemerle.Compiler.ParseResult.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.DefaultParseResult" />
    <member name="F:Nemerle.Compiler.DefaultParseResult.lexer" />
    <member name="M:Nemerle.Compiler.DefaultParseResult.get_CommentLocations" />
    <member name="P:Nemerle.Compiler.DefaultParseResult.CommentLocations" />
    <member name="M:Nemerle.Compiler.DefaultParseResult.get_Location" />
    <member name="P:Nemerle.Compiler.DefaultParseResult.Location" />
    <member name="M:Nemerle.Compiler.DefaultParseResult.get_Regions" />
    <member name="P:Nemerle.Compiler.DefaultParseResult.Regions" />
    <member name="M:Nemerle.Compiler.DefaultParseResult.get_LinesLengths" />
    <member name="P:Nemerle.Compiler.DefaultParseResult.LinesLengths" />
    <member name="M:Nemerle.Compiler.DefaultParseResult.#ctor(Nemerle.Core.list{Nemerle.Compiler.Parsetree.TopDeclaration},Nemerle.Compiler.LexerBase)" />
    <member name="M:Nemerle.Compiler.DefaultParseResult.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.DefaultParser" />
    <member name="F:Nemerle.Compiler.DefaultParser.manager" />
    <member name="M:Nemerle.Compiler.DefaultParser.Parse(Nemerle.Compiler.ISource)" />
    <member name="M:Nemerle.Compiler.DefaultParser.get_Manager" />
    <member name="P:Nemerle.Compiler.DefaultParser.Manager" />
    <member name="M:Nemerle.Compiler.DefaultParser.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.DefaultParser.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.DispatchingFileParser" />
    <member name="M:Nemerle.Compiler.DispatchingFileParser.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.DispatchingFileParser.#ctor(Nemerle.Compiler.ManagerClass,Nemerle.Compiler.IParser)" />
    <member name="M:Nemerle.Compiler.DispatchingFileParser.Register(Nemerle.Compiler.ManagerClass,System.Type,System.String)" />
    <member name="M:Nemerle.Compiler.DispatchingFileParser.IsExtensionRegistered(System.String)" />
    <member name="M:Nemerle.Compiler.DispatchingFileParser.Parse(Nemerle.Compiler.ISource)" />
    <member name="F:Nemerle.Compiler.DispatchingFileParser.manager" />
    <member name="F:Nemerle.Compiler.DispatchingFileParser.defaultParser" />
    <member name="F:Nemerle.Compiler.DispatchingFileParser.registeredParsers" />
    <member name="M:Nemerle.Compiler.DispatchingFileParser.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration._N_getInner_39224(Nemerle.Compiler.Parsetree.TopDeclaration._N_closureOf_GetAllInnerTypes_39216,Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration._N_makeName_39170(Nemerle.Compiler.Parsetree.TopDeclaration._N_closureOf_get_FullName_39164,Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration._N_makeName_39137(Nemerle.Compiler.Parsetree.TopDeclaration._N_closureOf_get_FullQualifiedName_39131,Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="F:Nemerle.Compiler.Parsetree.TopDeclaration.DeclaredTypeParameters" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_DeclaredTypeParametersCount" />
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.DeclaredTypeParametersCount" />
    <member name="F:Nemerle.Compiler.Parsetree.TopDeclaration.typarms" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_TypeParameters" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.set_TypeParameters(Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.TypeParameters" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_TypeParametersCount" />
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.TypeParametersCount" />
    <member name="F:Nemerle.Compiler.Parsetree.TopDeclaration._definedIn">
      <summary>
        <para>If this TopDeclaration nested in other TopDeclaration
 this property contain referens to it.  This property set to null
 if it is top level declaration.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Parsetree.TopDeclaration._typeBuilder" />
    <member name="F:Nemerle.Compiler.Parsetree.TopDeclaration._headerLocation">
      <summary>
        <para>This location used to outlining tegion as start of outpining

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.#ctor(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.#ctor(Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.#ctor" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_FullQualifiedName" />
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.FullQualifiedName" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_FullName" />
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.FullName" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.GetMembers" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.GetAllInnerTypes" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_DefinedIn">
      <summary>
        <para>If this TopDeclaration nested in other TopDeclaration
 this property contain referens to it.  This property set to null
 if it is top level declaration.

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.DefinedIn" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_TypeBuilder" />
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.TypeBuilder" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.get_HeaderLocation">
      <summary>
        <para>This location used to outlining tegion as start of outpining

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.Parsetree.TopDeclaration.HeaderLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration._N_GetVariantCodeSafe(Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.TopDeclaration.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Class" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Alias" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Interface" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Variant" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.VariantOption" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Macro" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Delegate" />
    <member name="T:Nemerle.Compiler.Parsetree.TopDeclaration.Enum" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_prefix_40072(Nemerle.Compiler.Parsetree.ClassMember._N_closureOf_ToString_40046)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_ifMutable_40062(Nemerle.Compiler.Parsetree.ClassMember._N_closureOf_ToString_40046)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_prefix_40000(Nemerle.Compiler.Parsetree.ClassMember._N_closureOf_HeaderToString_39974)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_ifMutable_39990(Nemerle.Compiler.Parsetree.ClassMember._N_closureOf_HeaderToString_39974)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_print_39933(Nemerle.Compiler.Parsetree.ClassMember._N_closureOf_PrintBody_39918,Nemerle.Core.option{Nemerle.Compiler.Parsetree.ClassMember.Function},System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.SetEnv(Nemerle.Compiler.GlobalEnv)" />
    <member name="F:Nemerle.Compiler.Parsetree.ClassMember._env" />
    <member name="F:Nemerle.Compiler.Parsetree.ClassMember._tokens" />
    <member name="F:Nemerle.Compiler.Parsetree.ClassMember._definedIn">
      <summary>
        <para>This property contain referens to TopDeclaration where defined this member.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Parsetree.ClassMember._builder" />
    <member name="F:Nemerle.Compiler.Parsetree.ClassMember._userData" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.get_Body" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.set_Body(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="P:Nemerle.Compiler.Parsetree.ClassMember.Body">
      <summary>
        <para>accessible only for ClassMember.Function, when its FunBody is not typed or compiled
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.IsMutable" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.PrintBody(Nemerle.Compiler.LocatableTextWriter)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.HeaderToString" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.get_Env" />
    <member name="P:Nemerle.Compiler.Parsetree.ClassMember.Env" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.get_Tokens" />
    <member name="P:Nemerle.Compiler.Parsetree.ClassMember.Tokens" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.get_DefinedIn">
      <summary>
        <para>This property contain referens to TopDeclaration where defined this member.

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.Parsetree.ClassMember.DefinedIn" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.get_Builder" />
    <member name="P:Nemerle.Compiler.Parsetree.ClassMember.Builder" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.get_UserData" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.set_UserData(System.Object)" />
    <member name="P:Nemerle.Compiler.Parsetree.ClassMember.UserData" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_GetVariantCodeSafe(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.ClassMember.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember.TypeDeclaration" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember.Field" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember.Function" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember.Property" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember.Event" />
    <member name="T:Nemerle.Compiler.Parsetree.ClassMember.EnumOption" />
    <member name="T:Nemerle.Compiler.Parsetree.MemberBase" />
    <member name="F:Nemerle.Compiler.Parsetree.MemberBase._bodyOpenTokenLocation" />
    <member name="F:Nemerle.Compiler.Parsetree.MemberBase._bodyCloseTokenLocation" />
    <member name="F:Nemerle.Compiler.Parsetree.MemberBase._isIndentationSyntax" />
    <member name="F:Nemerle.Compiler.Parsetree.MemberBase._typeParametersLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.get_BodyLocation" />
    <member name="P:Nemerle.Compiler.Parsetree.MemberBase.BodyLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.get_BodyInnerLocation" />
    <member name="P:Nemerle.Compiler.Parsetree.MemberBase.BodyInnerLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.get_BodyOpenTokenLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.set_BodyOpenTokenLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Parsetree.MemberBase.BodyOpenTokenLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.get_BodyCloseTokenLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.set_BodyCloseTokenLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Parsetree.MemberBase.BodyCloseTokenLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.get_IsIndentationSyntax" />
    <member name="P:Nemerle.Compiler.Parsetree.MemberBase.IsIndentationSyntax" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.get_TypeParametersLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.set_TypeParametersLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Parsetree.MemberBase.TypeParametersLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.MemberBase.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.DeclarationBase" />
    <member name="F:Nemerle.Compiler.Parsetree.DeclarationBase.name" />
    <member name="F:Nemerle.Compiler.Parsetree.DeclarationBase.modifiers" />
    <member name="F:Nemerle.Compiler.Parsetree.DeclarationBase.ParsedSplicableName" />
    <member name="F:Nemerle.Compiler.Parsetree.DeclarationBase.ParsedAttributsAndModifiers" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.TryGetEnv" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.GetEnv(Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.get_PName" />
    <member name="P:Nemerle.Compiler.Parsetree.DeclarationBase.PName" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.get_Name" />
    <member name="P:Nemerle.Compiler.Parsetree.DeclarationBase.Name" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.get_ParsedName" />
    <member name="P:Nemerle.Compiler.Parsetree.DeclarationBase.ParsedName" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.get_NameLocation" />
    <member name="P:Nemerle.Compiler.Parsetree.DeclarationBase.NameLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.get_Attributes" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.set_Attributes(Nemerle.Compiler.NemerleModifiers)" />
    <member name="P:Nemerle.Compiler.Parsetree.DeclarationBase.Attributes" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.GetCustomAttributes" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.AddCustomAttribute(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.DeclarationBase.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.Constraint" />
    <member name="M:Nemerle.Compiler.Parsetree.Constraint.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="F:Nemerle.Compiler.Parsetree.Constraint.tyvar" />
    <member name="F:Nemerle.Compiler.Parsetree.Constraint.ty" />
    <member name="F:Nemerle.Compiler.Parsetree.Constraint._N_IsSpecial_7743" />
    <member name="M:Nemerle.Compiler.Parsetree.Constraint.get_IsSpecial" />
    <member name="P:Nemerle.Compiler.Parsetree.Constraint.IsSpecial" />
    <member name="M:Nemerle.Compiler.Parsetree.Constraint.get_TypeParameterName" />
    <member name="P:Nemerle.Compiler.Parsetree.Constraint.TypeParameterName" />
    <member name="M:Nemerle.Compiler.Parsetree.Constraint.get_Expression" />
    <member name="P:Nemerle.Compiler.Parsetree.Constraint.Expression" />
    <member name="M:Nemerle.Compiler.Parsetree.Constraint.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.Typarms" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.#cctor" />
    <member name="F:Nemerle.Compiler.Parsetree.Typarms.tyvars" />
    <member name="F:Nemerle.Compiler.Parsetree.Typarms.constraints" />
    <member name="F:Nemerle.Compiler.Parsetree.Typarms.Empty" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.get_IsCopyOfExisting" />
    <member name="P:Nemerle.Compiler.Parsetree.Typarms.IsCopyOfExisting" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.Substitute(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.get_ExistingTyvars" />
    <member name="P:Nemerle.Compiler.Parsetree.Typarms.ExistingTyvars" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.#ctor(Nemerle.Core.list{Nemerle.Compiler.Parsetree.Splicable},Nemerle.Core.list{Nemerle.Compiler.Parsetree.Constraint})" />
    <member name="M:Nemerle.Compiler.Parsetree.Typarms.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.SubstitutingTyparms" />
    <member name="F:Nemerle.Compiler.Parsetree.SubstitutingTyparms.subst" />
    <member name="M:Nemerle.Compiler.Parsetree.SubstitutingTyparms.#ctor(Nemerle.Compiler.Subst)" />
    <member name="M:Nemerle.Compiler.Parsetree.SubstitutingTyparms.Substitute(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Parsetree.SubstitutingTyparms.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.CopyTypedTyparms">
      <summary>
        <para>The specified list of typed type parameters will be used as template for new type parameters.
      Compiler will also perform substitution of references to old parameters in type/method signature into references
      to fresh type parameters
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Parsetree.CopyTypedTyparms.fresh_vars" />
    <member name="M:Nemerle.Compiler.Parsetree.CopyTypedTyparms.#ctor(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar})" />
    <member name="M:Nemerle.Compiler.Parsetree.CopyTypedTyparms.#ctor(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar},Nemerle.Compiler.Subst)" />
    <member name="M:Nemerle.Compiler.Parsetree.CopyTypedTyparms.get_IsCopyOfExisting" />
    <member name="P:Nemerle.Compiler.Parsetree.CopyTypedTyparms.IsCopyOfExisting" />
    <member name="M:Nemerle.Compiler.Parsetree.CopyTypedTyparms.get_ExistingTyvars" />
    <member name="P:Nemerle.Compiler.Parsetree.CopyTypedTyparms.ExistingTyvars" />
    <member name="M:Nemerle.Compiler.Parsetree.CopyTypedTyparms.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.Name">
      <summary>
        <para>class encapsulating name of variable for purpose of
      quotation and renaming

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Parsetree.Name.idl" />
    <member name="F:Nemerle.Compiler.Parsetree.Name.color" />
    <member name="F:Nemerle.Compiler.Parsetree.Name.context" />
    <member name="F:Nemerle.Compiler.Parsetree.Name.ParsedId" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(System.String,System.Int32,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(System.String,Nemerle.Compiler.Location,System.Int32,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(System.String,Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.#ctor(System.String,Nemerle.Compiler.Location,System.Int32,Nemerle.Compiler.GlobalEnv,System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.NameInCurrentColor(System.String,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.NameInCurrentColor(System.String,Nemerle.Compiler.Location,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.NameInCurrentColor(System.String,System.String,Nemerle.Compiler.Location,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.Global(Nemerle.Compiler.ManagerClass,System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.NewName(System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.get_Id" />
    <member name="P:Nemerle.Compiler.Parsetree.Name.Id">
      <summary>
        <para>Returns plain identifier string of this name.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Parsetree.Name.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.GetHashCode" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.Equals(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.CompareTo(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.GetEnv(Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.Parsetree.Name.Equals(System.Object)" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr" />
    <member name="F:Nemerle.Compiler.Parsetree.PExpr._N_Token_7836" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr.get_Token" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr.set_Token(Nemerle.Compiler.Token)" />
    <member name="P:Nemerle.Compiler.Parsetree.PExpr.Token" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr.FromQualifiedIdentifier(Nemerle.Compiler.ManagerClass,System.String)" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr._N_GetVariantCodeSafe(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr.#ctor" />
    <member name="M:Nemerle.Compiler.Parsetree.PExpr.#ctor(Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Wildcard" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Void" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.As" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Is" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Where" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Match" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Ref" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Member" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Call" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.GenericSpecifier" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.ListLiteral" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Assign" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.DefMutable" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Define" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.DefFunctions" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Lambda" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Throw" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Try" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.TryFinally" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Literal" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.This" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Base" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Typeof" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.TypeConversion" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.TypeEnforcement" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Sequence" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Tuple" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Array" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.EmptyArray" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Indexer" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.ParmByRef" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.ParmOut" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Error" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.MacroCall" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Quoted" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Spliced" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.ToComplete" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Ellipsis" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.Typed" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.TypedPattern" />
    <member name="T:Nemerle.Compiler.Parsetree.PExpr.TypedType" />
    <member name="T:Nemerle.Compiler.Parsetree.Splicable" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.GetName" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.Equals(Nemerle.Compiler.Parsetree.Splicable)" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.GetIdentifier" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable._N_GetVariantCodeSafe(Nemerle.Compiler.Parsetree.Splicable)" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.#ctor" />
    <member name="M:Nemerle.Compiler.Parsetree.Splicable.#ctor(Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.Parsetree.Splicable.Name" />
    <member name="T:Nemerle.Compiler.Parsetree.Splicable.Expression" />
    <member name="T:Nemerle.Compiler.Parsetree.Splicable.HalfId" />
    <member name="T:Nemerle.Compiler.Parsetree.PParameter" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter._N_from_expr_42548(Nemerle.Compiler.Parsetree.PParameter._N_closureOf__ctor_42540,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="F:Nemerle.Compiler.Parsetree.PParameter.Type" />
    <member name="F:Nemerle.Compiler.Parsetree.PParameter._N_PatternHack_8322" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.get_PatternHack" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.set_PatternHack(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="P:Nemerle.Compiler.Parsetree.PParameter.PatternHack" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.ResetPatternHack" />
    <member name="F:Nemerle.Compiler.Parsetree.PParameter.ParsedType" />
    <member name="F:Nemerle.Compiler.Parsetree.PParameter.ParsedPatternHack" />
    <member name="F:Nemerle.Compiler.Parsetree.PParameter._N_DefaultValue_8333" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.get_DefaultValue" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.set_DefaultValue(Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="P:Nemerle.Compiler.Parsetree.PParameter.DefaultValue" />
    <member name="F:Nemerle.Compiler.Parsetree.PParameter.ParsedDefaultValue" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.get_TypedObject" />
    <member name="P:Nemerle.Compiler.Parsetree.PParameter.TypedObject" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.#ctor(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.get_ReferencingExpr" />
    <member name="P:Nemerle.Compiler.Parsetree.PParameter.ReferencingExpr" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.PParameter.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.IParametersProvider">
      <summary>
        <para>implemented by parse tree and typed tree function headers

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Parsetree.IParametersProvider.get_ParametersDeclarations" />
    <member name="P:Nemerle.Compiler.Parsetree.IParametersProvider.ParametersDeclarations" />
    <member name="M:Nemerle.Compiler.Parsetree.IParametersProvider.get_ParametersReferences" />
    <member name="P:Nemerle.Compiler.Parsetree.IParametersProvider.ParametersReferences" />
    <member name="T:Nemerle.Compiler.Parsetree.PFunHeader" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.TypeParameters" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.SplicableName" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.ReturnType" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.Parameters" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_TypedObject" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.TypedObject" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.ParsedTypeParameters" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.ParsedSplicableName" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.ParsedReturnType" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader.ParsedParameters" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader._parsedParametersOpenLocation" />
    <member name="F:Nemerle.Compiler.Parsetree.PFunHeader._parsedParametersCloseLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.#ctor(Nemerle.Compiler.Parsetree.Typarms,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Typarms,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.Typarms,Nemerle.Compiler.Parsetree.Splicable,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter},Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_Name" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.Name" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_PName" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.PName" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_ParametersDeclarations" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.ParametersDeclarations" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_ParametersReferences" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.ParametersReferences" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_ParsedParametersOpenLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.set_ParsedParametersOpenLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.ParsedParametersOpenLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.get_ParsedParametersCloseLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.set_ParsedParametersCloseLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Parsetree.PFunHeader.ParsedParametersCloseLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.PFunHeader.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.Function_decl" />
    <member name="M:Nemerle.Compiler.Parsetree.Function_decl.#ctor(Nemerle.Compiler.Parsetree.PFunHeader,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.Function_decl.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.PFunHeader,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="F:Nemerle.Compiler.Parsetree.Function_decl.header" />
    <member name="F:Nemerle.Compiler.Parsetree.Function_decl.body" />
    <member name="M:Nemerle.Compiler.Parsetree.Function_decl.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.MatchCase" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.#ctor(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.#ctor(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="F:Nemerle.Compiler.Parsetree.MatchCase.patterns" />
    <member name="F:Nemerle.Compiler.Parsetree.MatchCase.body" />
    <member name="F:Nemerle.Compiler.Parsetree.MatchCase.disable_warnings" />
    <member name="F:Nemerle.Compiler.Parsetree.MatchCase._patternsLocation" />
    <member name="F:Nemerle.Compiler.Parsetree.MatchCase._arrowLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.get_BodyLocation" />
    <member name="P:Nemerle.Compiler.Parsetree.MatchCase.BodyLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.get_Location" />
    <member name="P:Nemerle.Compiler.Parsetree.MatchCase.Location" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.get_PatternsLocation" />
    <member name="P:Nemerle.Compiler.Parsetree.MatchCase.PatternsLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.get_ArrowLocation" />
    <member name="P:Nemerle.Compiler.Parsetree.MatchCase.ArrowLocation" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.#ctor(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.#ctor(Nemerle.Compiler.Location,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Parsetree.MatchCase.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.TryCase" />
    <member name="M:Nemerle.Compiler.Parsetree.TryCase.get_TypedObject" />
    <member name="P:Nemerle.Compiler.Parsetree.TryCase.TypedObject" />
    <member name="M:Nemerle.Compiler.Parsetree.TryCase._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Parsetree.TryCase._N_GetVariantCodeSafe(Nemerle.Compiler.Parsetree.TryCase)" />
    <member name="M:Nemerle.Compiler.Parsetree.TryCase._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.TryCase.#ctor" />
    <member name="M:Nemerle.Compiler.Parsetree.TryCase.#ctor(Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.Parsetree.TryCase.Catch" />
    <member name="T:Nemerle.Compiler.Parsetree.TryCase.Filter" />
    <member name="T:Nemerle.Compiler.Parsetree.TryCase.Ellipsis" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement.#ctor" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement.get_Location" />
    <member name="P:Nemerle.Compiler.Parsetree.SyntaxElement.Location" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement.ToString" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement._N_GetVariantCodeSafe(Nemerle.Compiler.Parsetree.SyntaxElement)" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Parsetree.SyntaxElement.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.Expression" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.MatchCase" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.Function" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.Parameter" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.TType" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.RawToken" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.ClassMember" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.TypeBuilder" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.FieldBuilder" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.MethodBuilder" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.PropertyBuilder" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.EventBuilder" />
    <member name="T:Nemerle.Compiler.Parsetree.SyntaxElement.ParameterBuilder" />
    <member name="T:Nemerle.Compiler.PreParserException" />
    <member name="F:Nemerle.Compiler.PreParserException._location" />
    <member name="M:Nemerle.Compiler.PreParserException.#ctor(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.PreParserException.get_Location" />
    <member name="P:Nemerle.Compiler.PreParserException.Location" />
    <member name="M:Nemerle.Compiler.PreParserException.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.PreParser">
      <summary>
        <para>Transforms stream of tokens from given LexerBase to token tree
      with matched brackets.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParser._N_create_body_token_43798(Nemerle.Compiler.PreParser._N_closureOf_parse_using_directive_43786)" />
    <member name="M:Nemerle.Compiler.PreParser._N_parse_using_directive_43780(Nemerle.Compiler.PreParser._N_closureOf_ParseTopLevelImpl_43721,Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.PreParser._N_make_before_location_43774(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PreParser._N_get_qualified_tokens_43754(Nemerle.Compiler.PreParser._N_closureOf_ParseTopLevelImpl_43721)" />
    <member name="M:Nemerle.Compiler.PreParser._N_get_qualified_identifier_43733(Nemerle.Compiler.PreParser._N_closureOf_ParseTopLevelImpl_43721)" />
    <member name="F:Nemerle.Compiler.PreParser.lexer" />
    <member name="F:Nemerle.Compiler.PreParser.last_token" />
    <member name="F:Nemerle.Compiler.PreParser.last_declaration_token" />
    <member name="F:Nemerle.Compiler.PreParser.Env" />
    <member name="F:Nemerle.Compiler.PreParser.finished" />
    <member name="F:Nemerle.Compiler.PreParser.parent_stream">
      <summary>
        <para>Parent stream is the stack of processed token nodes,
        which are already assigned to be in currently build sequence.
        For example:
          a; b; c (); d e _we_are_here_
        'a, b, c()', are alredy known to be in parent sequence,
        while 'd e' are in current temporary sequence, which might
        get added to parent_stream if separator (e.g. ';') occurs

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.PreParser.current_stream">
      <summary>
        <para>Currently builded stream of token nodes is an array of
        loose tokens, which have occured after last separator.
        It will probably form LooseGroup as an element of parent
        sequence or all elements will constitue parent

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.PreParser.doc_comments" />
    <member name="M:Nemerle.Compiler.PreParser.#ctor(Nemerle.Compiler.LexerBase)" />
    <member name="M:Nemerle.Compiler.PreParser.#ctor(Nemerle.Compiler.LexerBase,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.PreParser.reset_comment(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.PreParser.reset_comment(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PreParser.get_token">
      <summary>
        <para>Fetch next token (from one token buffer or lexer if it's empty
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParser.push_back(Nemerle.Compiler.Token)">
      <summary>
        <para>Store token in our mini one token buffer
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParser.peek_token" />
    <member name="M:Nemerle.Compiler.PreParser.make_list(System.Collections.Generic.List{Nemerle.Compiler.Token},System.Int32)">
      <summary>
        <para>links Tokens from specified subarray to form a list and return its head
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParser.list_location(System.Collections.Generic.List{Nemerle.Compiler.Token},System.Int32)">
      <summary>
        <para>returns a combined location of the subarray inside a token list
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParser.Dump(Nemerle.Compiler.Token,System.String)" />
    <member name="M:Nemerle.Compiler.PreParser.finish_parent(System.Int32,System.Int32)">
      <summary>
        <para>Closes both currently created LooseGroup and parent group.
        Returns list of tokens composing parent group
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParser.finish_current(System.Int32,Nemerle.Compiler.Token)">
      <summary>
        <para>Closes currently created LooseGroup and adds it at the end of the
        parent group. After that we are ready to make another LooseGroup.

</para>
      </summary>        <remarks><para>It is called mainly when separator token occurs.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.PreParser.handle_default_token(System.Int32,Nemerle.Compiler.Token,System.Boolean)">
      <summary>
        <para>Handle standard situations when new bracket group is beginning
        or there is erronous situation. Any non bracket token is
        appended to current LooseGroup.

</para>
      </summary>        <remarks><para>Throws PreParserException when there is unmatched end bracket.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.PreParser.parse_brace_group(Nemerle.Compiler.Location,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.PreParser.parse_round_group(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PreParser.parse_square_group(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PreParser.parse_quote_group(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PreParser.ParseTopLevelImpl(System.Int32)" />
    <member name="M:Nemerle.Compiler.PreParser.parseTypeName(Nemerle.Core.list{Nemerle.Compiler.Token},Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.PreParser.indention_based_copy" />
    <member name="M:Nemerle.Compiler.PreParser.ParseTopLevel" />
    <member name="M:Nemerle.Compiler.PreParser.PreParse" />
    <member name="M:Nemerle.Compiler.PreParser.shift_end(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PreParser.get_DocComments" />
    <member name="M:Nemerle.Compiler.PreParser.set_DocComments(Nemerle.Collections.Map{Nemerle.Compiler.Location,System.String})" />
    <member name="P:Nemerle.Compiler.PreParser.DocComments" />
    <member name="M:Nemerle.Compiler.PreParser.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.PreParserIndent" />
    <member name="F:Nemerle.Compiler.PreParserIndent.explicit_groups" />
    <member name="F:Nemerle.Compiler.PreParserIndent.indentation_syntax_active" />
    <member name="F:Nemerle.Compiler.PreParserIndent.insertLocation" />
    <member name="F:Nemerle.Compiler.PreParserIndent.had_some_real_input" />
    <member name="F:Nemerle.Compiler.PreParserIndent.last_token_was_semicolon" />
    <member name="F:Nemerle.Compiler.PreParserIndent.force_brace_after_newline" />
    <member name="F:Nemerle.Compiler.PreParserIndent.indent_strings" />
    <member name="F:Nemerle.Compiler.PreParserIndent.tokens_pending" />
    <member name="F:Nemerle.Compiler.PreParserIndent.set_namespace" />
    <member name="F:Nemerle.Compiler.PreParserIndent.set_class" />
    <member name="M:Nemerle.Compiler.PreParserIndent.#ctor(Nemerle.Compiler.LexerBase)" />
    <member name="M:Nemerle.Compiler.PreParserIndent.push_end_brace" />
    <member name="M:Nemerle.Compiler.PreParserIndent.get_CurrentIndent" />
    <member name="P:Nemerle.Compiler.PreParserIndent.CurrentIndent" />
    <member name="M:Nemerle.Compiler.PreParserIndent.handle_real_token(Nemerle.Compiler.Token)" />
    <member name="M:Nemerle.Compiler.PreParserIndent.get_token">
      <summary>
        <para>Fetch next token (from one token buffer or lexer if it's empty
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PreParserIndent.display_space(System.String)" />
    <member name="M:Nemerle.Compiler.PreParserIndent.get_token_after_indent(Nemerle.Compiler.Token,System.String)" />
    <member name="M:Nemerle.Compiler.PreParserIndent.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.PreprocessorEvaluator" />
    <member name="M:Nemerle.Compiler.PreprocessorEvaluator._N_highest_44411(Nemerle.Compiler.PreprocessorEvaluator._N_closureOf_EvalCondition_44341)" />
    <member name="M:Nemerle.Compiler.PreprocessorEvaluator._N_high_44405(Nemerle.Compiler.PreprocessorEvaluator._N_closureOf_EvalCondition_44341)" />
    <member name="M:Nemerle.Compiler.PreprocessorEvaluator._N_low_44399(Nemerle.Compiler.PreprocessorEvaluator._N_closureOf_EvalCondition_44341)" />
    <member name="M:Nemerle.Compiler.PreprocessorEvaluator._N_lowest_44393(Nemerle.Compiler.PreprocessorEvaluator._N_closureOf_EvalCondition_44341)" />
    <member name="M:Nemerle.Compiler.PreprocessorEvaluator.EvalCondition(Nemerle.Collections.Map{System.String,System.Boolean},System.String)" />
    <member name="M:Nemerle.Compiler.PreprocessorEvaluator.EvalConditions(Nemerle.Compiler.IMember,Nemerle.Compiler.GlobalEnv)" />
    <member name="T:Nemerle.Compiler.ISource" />
    <member name="M:Nemerle.Compiler.ISource.get_FileIndex" />
    <member name="P:Nemerle.Compiler.ISource.FileIndex" />
    <member name="M:Nemerle.Compiler.ISource.GetText" />
    <member name="T:Nemerle.Compiler.StringSource" />
    <member name="F:Nemerle.Compiler.StringSource._N_FileIndex_8723" />
    <member name="M:Nemerle.Compiler.StringSource.get_FileIndex" />
    <member name="P:Nemerle.Compiler.StringSource.FileIndex" />
    <member name="M:Nemerle.Compiler.StringSource.GetText" />
    <member name="F:Nemerle.Compiler.StringSource.text" />
    <member name="M:Nemerle.Compiler.StringSource.#ctor(System.Int32,System.String)" />
    <member name="M:Nemerle.Compiler.StringSource.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.FileSource" />
    <member name="M:Nemerle.Compiler.FileSource.#ctor(System.String,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.FileSource.#ctor(System.String,Nemerle.Compiler.WarningOptions)" />
    <member name="M:Nemerle.Compiler.FileSource.get_FileIndex" />
    <member name="P:Nemerle.Compiler.FileSource.FileIndex" />
    <member name="M:Nemerle.Compiler.FileSource.GetText" />
    <member name="F:Nemerle.Compiler.FileSource._N_field__internalSource_embeded_in_InternalSource_3494" />
    <member name="M:Nemerle.Compiler.FileSource.get_InternalSource" />
    <member name="P:Nemerle.Compiler.FileSource.InternalSource" />
    <member name="M:Nemerle.Compiler.FileSource.ReadFile(System.String,System.Boolean,System.Boolean)" />
    <member name="F:Nemerle.Compiler.FileSource._filePath" />
    <member name="F:Nemerle.Compiler.FileSource._checkDuplicatedFiles" />
    <member name="F:Nemerle.Compiler.FileSource._checkLastLineForLF" />
    <member name="M:Nemerle.Compiler.FileSource.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ICE" />
    <member name="M:Nemerle.Compiler.ICE.#ctor" />
    <member name="M:Nemerle.Compiler.ICE.#ctor(System.String)" />
    <member name="M:Nemerle.Compiler.ICE.#ctor(System.String,System.Exception)" />
    <member name="M:Nemerle.Compiler.ICE.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
    <member name="M:Nemerle.Compiler.ICE.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Recovery" />
    <member name="M:Nemerle.Compiler.Recovery.#ctor" />
    <member name="M:Nemerle.Compiler.Recovery.#ctor(System.String)" />
    <member name="M:Nemerle.Compiler.Recovery.#ctor(System.String,System.Exception)" />
    <member name="M:Nemerle.Compiler.Recovery.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
    <member name="M:Nemerle.Compiler.Recovery.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.BailOutException" />
    <member name="M:Nemerle.Compiler.BailOutException.#ctor" />
    <member name="M:Nemerle.Compiler.BailOutException.#ctor(System.String)" />
    <member name="M:Nemerle.Compiler.BailOutException.#ctor(System.String,System.Exception)" />
    <member name="M:Nemerle.Compiler.BailOutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
    <member name="M:Nemerle.Compiler.BailOutException.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Util" />
    <member name="M:Nemerle.Compiler.Util.next_id(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.Util.ice``1(System.String)" />
    <member name="M:Nemerle.Compiler.Util.is_capitalized(System.String)" />
    <member name="M:Nemerle.Compiler.Util.tmpname(System.String)" />
    <member name="M:Nemerle.Compiler.Util.escape_in_buffer(System.Text.StringBuilder,System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.Util.Escape(System.String)" />
    <member name="M:Nemerle.Compiler.Util.StripGenericMark(System.String)" />
    <member name="M:Nemerle.Compiler.Util.QidOfExpr(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Util.ExprOfQid(System.String)" />
    <member name="M:Nemerle.Compiler.Util.ExprOfList(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.Util.qidl_of_expr(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Util.QidOfList(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.Util.qid_of_list(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.Util.expr_of_qidl(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.Util.set(Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="T:Nemerle.Compiler.Message" />
    <member name="M:Nemerle.Compiler.Message.#cctor" />
    <member name="M:Nemerle.Compiler.Message.Error(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.Error(System.String)" />
    <member name="M:Nemerle.Compiler.Message.Warning(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.Warning(System.String)" />
    <member name="M:Nemerle.Compiler.Message.Warning(System.Int32,Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.Warning(System.Int32,System.String)" />
    <member name="M:Nemerle.Compiler.Message.findLoc(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Message.Hint(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.Hint(System.String)" />
    <member name="M:Nemerle.Compiler.Message.HintOnce(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.HintOnce(System.Int32,Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.HintOnce(System.Int32,System.String)" />
    <member name="M:Nemerle.Compiler.Message.HintOnce(System.String)" />
    <member name="F:Nemerle.Compiler.Message.ListenDebug" />
    <member name="M:Nemerle.Compiler.Message.Debug(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.Debug(System.String)" />
    <member name="M:Nemerle.Compiler.Message.FatalError2(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.MaybeBailout(System.Boolean)" />
    <member name="M:Nemerle.Compiler.Message.get_SeenError" />
    <member name="P:Nemerle.Compiler.Message.SeenError" />
    <member name="M:Nemerle.Compiler.Message.get_ErrorCount" />
    <member name="P:Nemerle.Compiler.Message.ErrorCount" />
    <member name="M:Nemerle.Compiler.Message.MaybeBailout" />
    <member name="M:Nemerle.Compiler.Message.report(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.Message.get_Manager" />
    <member name="P:Nemerle.Compiler.Message.Manager" />
    <member name="M:Nemerle.Compiler.Message.get_InternalType" />
    <member name="P:Nemerle.Compiler.Message.InternalType" />
    <member name="M:Nemerle.Compiler.Message.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.Message.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.Message.__fake" />
    <member name="T:Nemerle.Compiler.LocationStack" />
    <member name="F:Nemerle.Compiler.LocationStack._stack" />
    <member name="M:Nemerle.Compiler.LocationStack.get_Stack" />
    <member name="P:Nemerle.Compiler.LocationStack.Stack" />
    <member name="M:Nemerle.Compiler.LocationStack.Push(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.LocationStack.RemoveTop" />
    <member name="M:Nemerle.Compiler.LocationStack.Pop" />
    <member name="M:Nemerle.Compiler.LocationStack.Top" />
    <member name="T:Nemerle.Compiler.NemerleCodeCompiler" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler._N_err_event_50605(Nemerle.Compiler.NemerleCodeCompiler._N_closureOf_CompileAssemblyFromFileBatch_50581,System.Boolean,Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.#ctor" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit)" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.CompileAssemblyFromDomBatch(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.CompileAssemblyFromFileBatch(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.CompileAssemblyFromSourceBatch(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
    <member name="M:Nemerle.Compiler.NemerleCodeCompiler.GetTempFileNameWithExtension(System.CodeDom.Compiler.TempFileCollection,System.String)" />
    <member name="T:Nemerle.Compiler.NemerleCodeGenerator" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.#cctor" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.dont_write_semicolon" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.id" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.new_name" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.#ctor" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.options" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.get_Options" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.set_Options(System.CodeDom.Compiler.CodeGeneratorOptions)" />
    <member name="P:Nemerle.Compiler.NemerleCodeGenerator.Options" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.get_BracingStyle" />
    <member name="P:Nemerle.Compiler.NemerleCodeGenerator.BracingStyle" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.output" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.get_Output" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.set_Output(System.IO.TextWriter)" />
    <member name="P:Nemerle.Compiler.NemerleCodeGenerator.Output" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.get_Indent" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.set_Indent(System.Int32)" />
    <member name="P:Nemerle.Compiler.NemerleCodeGenerator.Indent" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.get_NullToken" />
    <member name="P:Nemerle.Compiler.NemerleCodeGenerator.NullToken" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateArrayCreateExpression(System.CodeDom.CodeArrayCreateExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateBaseReferenceExpression(System.CodeDom.CodeBaseReferenceExpression)" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.inNestedBinary" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateBinaryOperatorExpression(System.CodeDom.CodeBinaryOperatorExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateCastExpression(System.CodeDom.CodeCastExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateCompileUnitStart(System.CodeDom.CodeCompileUnit)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateDelegateCreateExpression(System.CodeDom.CodeDelegateCreateExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateDirectives(System.CodeDom.CodeDirectiveCollection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateSingleFloatValue(System.Single)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateDoubleValue(System.Double)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateFieldReferenceExpression(System.CodeDom.CodeFieldReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateArgumentReferenceExpression(System.CodeDom.CodeArgumentReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateVariableReferenceExpression(System.CodeDom.CodeVariableReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateIndexerExpression(System.CodeDom.CodeIndexerExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateArrayIndexerExpression(System.CodeDom.CodeArrayIndexerExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateSnippetExpression(System.CodeDom.CodeSnippetExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateMethodInvokeExpression(System.CodeDom.CodeMethodInvokeExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateMethodReferenceExpression(System.CodeDom.CodeMethodReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateEventReferenceExpression(System.CodeDom.CodeEventReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateDelegateInvokeExpression(System.CodeDom.CodeDelegateInvokeExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateObjectCreateExpression(System.CodeDom.CodeObjectCreateExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GeneratePropertyReferenceExpression(System.CodeDom.CodePropertyReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GeneratePropertySetValueReferenceExpression(System.CodeDom.CodePropertySetValueReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateThisReferenceExpression(System.CodeDom.CodeThisReferenceExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateExpressionStatement(System.CodeDom.CodeExpressionStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateIterationStatement(System.CodeDom.CodeIterationStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateStatements(System.CodeDom.CodeStatementCollection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateThrowExceptionStatement(System.CodeDom.CodeThrowExceptionStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateComment(System.CodeDom.CodeComment)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateMethodReturnStatement(System.CodeDom.CodeMethodReturnStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateConditionStatement(System.CodeDom.CodeConditionStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateTryCatchFinallyStatement(System.CodeDom.CodeTryCatchFinallyStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateAssignStatement(System.CodeDom.CodeAssignStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateAttachEventStatement(System.CodeDom.CodeAttachEventStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateRemoveEventStatement(System.CodeDom.CodeRemoveEventStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateGotoStatement(System.CodeDom.CodeGotoStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateLabeledStatement(System.CodeDom.CodeLabeledStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateSnippetCompileUnit(System.CodeDom.CodeSnippetCompileUnit)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateVariableDeclarationStatement(System.CodeDom.CodeVariableDeclarationStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateLinePragmaStart(System.CodeDom.CodeLinePragma)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateLinePragmaEnd(System.CodeDom.CodeLinePragma)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateEvent(System.CodeDom.CodeMemberEvent,System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateField(System.CodeDom.CodeMemberField)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputFieldScopeModifier(System.CodeDom.MemberAttributes)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputTypeAttributes(System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateSnippetMember(System.CodeDom.CodeSnippetTypeMember)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateSnippetStatement(System.CodeDom.CodeSnippetStatement)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateEntryPointMethod(System.CodeDom.CodeEntryPointMethod,System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateMethod(System.CodeDom.CodeMemberMethod,System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateProperty(System.CodeDom.CodeMemberProperty,System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateConstructor(System.CodeDom.CodeConstructor,System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateTypeConstructor(System.CodeDom.CodeTypeConstructor)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateTypes(System.CodeDom.CodeNamespace)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateTypeStart(System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateTypeEnd(System.CodeDom.CodeTypeDeclaration)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateNamespace(System.CodeDom.CodeNamespace)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateNamespaceStart(System.CodeDom.CodeNamespace)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateNamespaceEnd(System.CodeDom.CodeNamespace)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateNamespaceImport(System.CodeDom.CodeNamespaceImport)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateAttributeDeclarationsStart(System.CodeDom.CodeAttributeDeclarationCollection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateAttributeDeclarationsEnd(System.CodeDom.CodeAttributeDeclarationCollection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputType(System.CodeDom.CodeTypeReference)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputTypeNamePair(System.CodeDom.CodeTypeReference,System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputAttributeArgument(System.CodeDom.CodeAttributeArgument)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputAttributeDeclarations(System.CodeDom.CodeAttributeDeclarationCollection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputMemberAccessModifier(System.CodeDom.MemberAttributes)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputMemberScopeModifier(System.CodeDom.MemberAttributes)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputIdentifier(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputParameters(System.CodeDom.CodeParameterDeclarationExpressionCollection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.QuoteSnippetString(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateParameterDeclarationExpression(System.CodeDom.CodeParameterDeclarationExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GeneratePrimitiveExpression(System.CodeDom.CodePrimitiveExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateTypeOfExpression(System.CodeDom.CodeTypeOfExpression)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GenerateBlock(System.CodeDom.CodeStatementCollection,System.Boolean)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputBlockStart(Nemerle.Compiler.NemerleCodeGenerator.BracingType)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputBlockEnd(Nemerle.Compiler.NemerleCodeGenerator.BracingType,System.Boolean)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputOperator(System.CodeDom.CodeBinaryOperatorType)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputExpressionList(System.CodeDom.CodeExpressionCollection,System.Boolean)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.OutputDirection(System.CodeDom.FieldDirection)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.ContinueOnNewLine(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.CreateEscapedIdentifier(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.CreateValidIdentifier(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.IsValidIdentifier(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.Supports(System.CodeDom.Compiler.GeneratorSupport)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GetSafeName(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.GetSafeTypeName(System.String)" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.FillKeywordTable" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.typesTable" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.types" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.keywordsTable" />
    <member name="F:Nemerle.Compiler.NemerleCodeGenerator.keywords" />
    <member name="M:Nemerle.Compiler.NemerleCodeGenerator.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.NemerleCodeGenerator.BracingType" />
    <member name="T:Nemerle.Compiler.NemerleCodeProvider" />
    <member name="M:Nemerle.Compiler.NemerleCodeProvider.#ctor" />
    <member name="M:Nemerle.Compiler.NemerleCodeProvider.get_FileExtension" />
    <member name="P:Nemerle.Compiler.NemerleCodeProvider.FileExtension" />
    <member name="M:Nemerle.Compiler.NemerleCodeProvider.CreateCompiler" />
    <member name="M:Nemerle.Compiler.NemerleCodeProvider.CreateGenerator" />
    <member name="M:Nemerle.Compiler.NemerleCodeProvider.GetConverter(System.Type)" />
    <member name="M:Nemerle.Compiler.NemerleCodeProvider.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.NemerleMemberAttributeConverter" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.#cctor" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.#ctor" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext)" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)" />
    <member name="F:Nemerle.Compiler.NemerleMemberAttributeConverter.Default" />
    <member name="F:Nemerle.Compiler.NemerleMemberAttributeConverter._names" />
    <member name="F:Nemerle.Compiler.NemerleMemberAttributeConverter._values" />
    <member name="M:Nemerle.Compiler.NemerleMemberAttributeConverter.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ISupportRelocation" />
    <member name="M:Nemerle.Compiler.ISupportRelocation.RelocateImpl(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.RelocationInfo" />
    <member name="M:Nemerle.Compiler.RelocationInfo.#ctor(System.Int32,Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint,Nemerle.Compiler.TextPoint)" />
    <member name="F:Nemerle.Compiler.RelocationInfo.VisitedObjects" />
    <member name="F:Nemerle.Compiler.RelocationInfo.FileIndex" />
    <member name="F:Nemerle.Compiler.RelocationInfo.Begin" />
    <member name="F:Nemerle.Compiler.RelocationInfo.Old" />
    <member name="F:Nemerle.Compiler.RelocationInfo.New" />
    <member name="M:Nemerle.Compiler.RelocationInfo.ToString" />
    <member name="M:Nemerle.Compiler.RelocationInfo.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Completion" />
    <member name="M:Nemerle.Compiler.Completion._N_scanStaticMembers_51192(Nemerle.Compiler.Completion._N_closureOf_AddTypesAndNamespaces_51133,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.Completion._N_scanAndAdd_51158(Nemerle.Compiler.Completion._N_closureOf_AddTypesAndNamespaces_51133,Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.Completion._N_loop_51003(Nemerle.Compiler.Completion._N_closureOf_MatchName_50990,System.String,System.Int32,System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.Completion._N_relocatePoint_50924(Nemerle.Compiler.TextPoint,Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.Completion.Relocate(Nemerle.Compiler.Location,Nemerle.Compiler.RelocationInfo)">
      <summary>
        <para>Shift Location.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Completion.RelocateFile(Nemerle.Compiler.Location,Nemerle.Compiler.RelocationInfo)">
      <summary>
        <para>Shift Location.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Completion.CmpOptions">
      <summary>
        <para>Shift Location.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Completion.MatchName(System.String,System.String)" />
    <member name="M:Nemerle.Compiler.Completion.AddTypesAndNamespaces(System.Collections.Generic.List{Nemerle.Compiler.Elem},Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.Name,System.Boolean,System.Boolean)">
      <summary>
        <para>extract information about types/namespaces and add it to 'elems' list.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Completion.GetName(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.Completion.ReplaceSpecialName(System.String)">
      <summary>
        <para>Look for special names

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.Completion.RelocationFailedException" />
    <member name="T:Nemerle.Compiler.IEngine" />
    <member name="M:Nemerle.Compiler.IEngine.RequestOnBuildTypesTree">
      <summary>
        <para>Send request on Build the Types Tree. It not lead to immediately rebuild project.
 The project will be rebuilded when IDE turn into idle state (user will not be type in editor).

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.TyCodec">
      <summary>
        <para>This module is used to decode and encode Nemerle specific information about types,
 methods, etc. which are not directly expressible in .NET metadata.

</para>
      </summary> <remarks><para>We use custom attributes to save / read this data in emitted / loaded assemblies.

</para> <para>This module is stateless.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TyCodec._N_walk_51942(Nemerle.Compiler.TyCodec._N_closureOf_FlattenTerm_51934,Nemerle.Compiler.TyCodec.Term)" />
    <member name="M:Nemerle.Compiler.TyCodec._N_tryAddSuperType_51639(Nemerle.Compiler.TyCodec._N_closureOf_ReflectTypeBuilder_51581,System.Type)" />
    <member name="M:Nemerle.Compiler.TyCodec._N_typeof_type_51599(Nemerle.Compiler.TyCodec._N_closureOf_ReflectTypeBuilder_51581,System.Type)" />
    <member name="M:Nemerle.Compiler.TyCodec._N_get_list_51339(Nemerle.Compiler.TyCodec._N_closureOf_ParseTerm_51315,Nemerle.Core.list{Nemerle.Compiler.TyCodec.Term},System.Int32)" />
    <member name="M:Nemerle.Compiler.TyCodec._N_maybe_get_51333(Nemerle.Compiler.TyCodec._N_closureOf_ParseTerm_51315,System.Int32)" />
    <member name="M:Nemerle.Compiler.TyCodec._N_get_name_51323(Nemerle.Compiler.TyCodec._N_closureOf_ParseTerm_51315,System.Int32)" />
    <member name="M:Nemerle.Compiler.TyCodec.ParseTerm(System.String)" />
    <member name="M:Nemerle.Compiler.TyCodec.decode(Nemerle.Compiler.LibraryReference,Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},Nemerle.Compiler.TyCodec.Term)" />
    <member name="M:Nemerle.Compiler.TyCodec.reflect_typarms(Nemerle.Compiler.LibraryReference,Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.Type)" />
    <member name="M:Nemerle.Compiler.TyCodec.ReflectConstraints(Nemerle.Compiler.LibraryReference,Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.Type,Nemerle.Compiler.FixedType,Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar})" />
    <member name="M:Nemerle.Compiler.TyCodec.DecodeType(Nemerle.Compiler.LibraryReference,Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.String)">
      <summary>
        <para>Used to decode Nemerle types extracted from assembly metadata

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TyCodec.ReflectTypeBuilder(Nemerle.Compiler.LibraryReference,Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.Type)" />
    <member name="M:Nemerle.Compiler.TyCodec.ReflectTyparms(Nemerle.Compiler.LibraryReference,Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.Reflection.MethodBase)" />
    <member name="M:Nemerle.Compiler.TyCodec.FlattenTerm(Nemerle.Compiler.TyCodec.Term)" />
    <member name="M:Nemerle.Compiler.TyCodec.encode_tvs(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.TyCodec.encode_tv(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TyCodec.encode(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.TyCodec.EncodeType(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Used to emit Nemerle types in assembly metadata

</para>
      </summary> <remarks>
   <para>The type tree is converted to prefix, term-like notation.
 </para></remarks>

</member>
    <member name="T:Nemerle.Compiler.TyCodec.Term" />
    <member name="T:Nemerle.Compiler.LibraryReference">
      <summary>
        <para>This class stores information extracted from a referenced external library.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReference._N_lift_52787(Nemerle.Compiler.LibraryReference._N_closureOf_makeArg_52781,System.Object)" />
    <member name="M:Nemerle.Compiler.LibraryReference._N_make_tupl_52448(Nemerle.Compiler.LibraryReference._N_closureOf_TypeOfType_52403,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.LibraryReference._N_checkFriend_52341(Nemerle.Compiler.LibraryReference._N_closureOf_GetIsFriend_52310,System.Runtime.CompilerServices.InternalsVisibleToAttribute)" />
    <member name="M:Nemerle.Compiler.LibraryReference._N_generatePublicKeyToken_52335(System.Byte[])" />
    <member name="M:Nemerle.Compiler.LibraryReference._N_toHexString_52330(System.Byte[])" />
    <member name="M:Nemerle.Compiler.LibraryReference._N_snKey_52320(Nemerle.Compiler.LibraryReference._N_closureOf_GetIsFriend_52310)" />
    <member name="F:Nemerle.Compiler.LibraryReference._library">
      <summary>
        <para>The assembly associated with this object

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LibraryReference._location">
      <summary>
        <para>The location of this library

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LibraryReference._isFriend" />
    <member name="F:Nemerle.Compiler.LibraryReference._is_generated_by_nemerle">
      <summary>
        <para>If set to true, the current assembly declares itself
 to be generated by the Nemerle compiler.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LibraryReference.LibRefManager" />
    <member name="M:Nemerle.Compiler.LibraryReference.load_attr_from(System.Reflection.Assembly,System.String,System.Type@,System.String@)" />
    <member name="M:Nemerle.Compiler.LibraryReference.#ctor(Nemerle.Compiler.LibraryReferenceManager,System.Reflection.Assembly)">
      <summary>
        <para>Load an assembly. Extracts and processes the custom attributes array.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReference.GetIsFriend" />
    <member name="M:Nemerle.Compiler.LibraryReference.LoadContents" />
    <member name="M:Nemerle.Compiler.LibraryReference.ToString" />
    <member name="M:Nemerle.Compiler.LibraryReference.TypeOfType(Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.Type)">
      <summary>
        <para>Turns a Framework type into something edible by Nemerle's type system

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LibraryReference.doEnsureCached" />
    <member name="M:Nemerle.Compiler.LibraryReference.TypeInfoOfType(System.Type)" />
    <member name="M:Nemerle.Compiler.LibraryReference.ConstructTypeInfo(System.Type,Nemerle.Compiler.NamespaceTree.Node)">
      <summary>
        <para>Construct TypeInfo object from given type in current assembly.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReference.LookupInternalType(System.String)">
      <summary>
        <para>Looks for type named [name] that is internal to current assembly. Used
 by type attribute decoder.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReference.MethodOfMethodInfo(Nemerle.Collections.Map{System.String,Nemerle.Compiler.StaticTypeVar},System.Reflection.MethodInfo)" />
    <member name="M:Nemerle.Compiler.LibraryReference.ConvertCustomAttributesData(System.Collections.Generic.IList{System.Reflection.CustomAttributeData},Nemerle.Compiler.ManagerClass)" />
    <member name="F:Nemerle.Compiler.LibraryReference.Manager">
      <summary>
        <para>This class stores information extracted from a referenced external library.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReference.get_InternalType" />
    <member name="P:Nemerle.Compiler.LibraryReference.InternalType" />
    <member name="M:Nemerle.Compiler.LibraryReference.get_SystemTypeCache">
      <summary>
        <para>This class stores information extracted from a referenced external library.

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.LibraryReference.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.LibraryReference.__fake">
      <summary>
        <para>This class stores information extracted from a referenced external library.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReference.get_Assembly">
      <summary>
        <para>The assembly associated with this object

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.LibraryReference.Assembly" />
    <member name="M:Nemerle.Compiler.LibraryReference.get_IsFriend" />
    <member name="P:Nemerle.Compiler.LibraryReference.IsFriend" />
    <member name="M:Nemerle.Compiler.LibraryReference.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalTypeInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalNemerleTypeInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalMethodInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalFieldInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalEventInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalMemberInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalPropertyInfo" />
    <member name="T:Nemerle.Compiler.LibraryReference.ExternalPrimitiveTypeInfo" />
    <member name="T:Nemerle.Compiler.ExternalType" />
    <member name="F:Nemerle.Compiler.ExternalType.system_type" />
    <member name="F:Nemerle.Compiler.ExternalType.library" />
    <member name="F:Nemerle.Compiler.ExternalType.tycon" />
    <member name="M:Nemerle.Compiler.ExternalType.ConstructTypeInfo(Nemerle.Compiler.NamespaceTree.Node,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ExternalType.get_SystemType" />
    <member name="P:Nemerle.Compiler.ExternalType.SystemType" />
    <member name="M:Nemerle.Compiler.ExternalType.#ctor(System.Type,Nemerle.Compiler.LibraryReference,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.ExternalType.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.SystemTypeClass" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Array" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Boolean" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Byte" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Char" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Decimal" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Double" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Enum" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.FlagsAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Int16" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Int32" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Int64" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.IntPtr" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Delegate" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.MulticastDelegate" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Object" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Reflection_AssemblyConfigurationAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Reflection_FieldInfo" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Reflection_PropertyInfo" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Reflection_DefaultMemberAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Runtime_CompilerServices_IsVolatile" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.DebuggableAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.DebuggableAttribute_DebuggingModes" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.CompilationRelaxationsAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.SByte" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Single" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.String" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Type" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.UInt16" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.UInt32" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.UInt64" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Void" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.ParamArrayAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.ExtensionAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.ExtensionAttributeAssembly" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.SQ_ExtensionAttribute" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.SQ_ExtensionAttributeAssembly" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.RuntimeHelpers_get_OffsetToStringData" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Decimal_ctors" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Type_GetTypeFromHandle" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.MethodBase_GetMethodFromHandle" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.MethodBase_GetMethodFromHandle2" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.FieldInfo_GetFieldFromHandle" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.FieldInfo_GetFieldFromHandle2" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.AssemblyBuilder_EmbedResourceFile" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.String_opEquality" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.String_opInequality" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Decimal_opEquality" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.String_Concat" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.ObjectCtor" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Delegate_Combine" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Delegate_Remove" />
    <member name="F:Nemerle.Compiler.SystemTypeClass._N_field_nemerle_attribute_embeded_in_NemerleAttribute_3479" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_NemerleAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.set_NemerleAttribute(System.Type)" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.NemerleAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_NullMatchException" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.NullMatchException" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_ContainsMacroAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.ContainsMacroAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_VariantAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.VariantAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_VariantOptionAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.VariantOptionAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_VolatileModifier" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.VolatileModifier" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_ImmutableAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.ImmutableAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_ConstantVariantOptionAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.ConstantVariantOptionAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_TypeAliasAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.TypeAliasAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_ExtensionPatternEncodingAttribute" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.ExtensionPatternEncodingAttribute" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.Reflect(System.String)">
      <summary>
        <para>Reflects a type using NamespaceTree

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.SystemTypeClass.Init" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="F:Nemerle.Compiler.SystemTypeClass.Manager" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_InternalType" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.InternalType" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.SystemTypeClass.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.__fake" />
    <member name="M:Nemerle.Compiler.SystemTypeClass.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.TupleType" />
    <member name="M:Nemerle.Compiler.TupleType.#cctor" />
    <member name="F:Nemerle.Compiler.TupleType.tycon" />
    <member name="F:Nemerle.Compiler.TupleType.fields" />
    <member name="F:Nemerle.Compiler.TupleType.ctor" />
    <member name="M:Nemerle.Compiler.TupleType.GetField(System.Int32)" />
    <member name="M:Nemerle.Compiler.TupleType.get_Ctor" />
    <member name="P:Nemerle.Compiler.TupleType.Ctor" />
    <member name="M:Nemerle.Compiler.TupleType.get_TyCon" />
    <member name="P:Nemerle.Compiler.TupleType.TyCon" />
    <member name="M:Nemerle.Compiler.TupleType.Make(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TupleType.get_field(System.Int32)" />
    <member name="F:Nemerle.Compiler.TupleType.name" />
    <member name="M:Nemerle.Compiler.TupleType.IsTupleMember(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.TupleType.#ctor(Nemerle.Compiler.ManagerClass,System.Int32)" />
    <member name="M:Nemerle.Compiler.TupleType.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.FunctionType" />
    <member name="M:Nemerle.Compiler.FunctionType.#cctor" />
    <member name="F:Nemerle.Compiler.FunctionType.tycon" />
    <member name="F:Nemerle.Compiler.FunctionType.void_tycon" />
    <member name="F:Nemerle.Compiler.FunctionType.apply" />
    <member name="F:Nemerle.Compiler.FunctionType.apply_void" />
    <member name="F:Nemerle.Compiler.FunctionType.apply_tupled" />
    <member name="F:Nemerle.Compiler.FunctionType.apply_tupled_void" />
    <member name="M:Nemerle.Compiler.FunctionType.get_ApplyMethod" />
    <member name="P:Nemerle.Compiler.FunctionType.ApplyMethod" />
    <member name="M:Nemerle.Compiler.FunctionType.get_ApplyVoidMethod" />
    <member name="P:Nemerle.Compiler.FunctionType.ApplyVoidMethod" />
    <member name="M:Nemerle.Compiler.FunctionType.get_TyCon" />
    <member name="P:Nemerle.Compiler.FunctionType.TyCon" />
    <member name="M:Nemerle.Compiler.FunctionType.get_VoidTyCon" />
    <member name="P:Nemerle.Compiler.FunctionType.VoidTyCon" />
    <member name="F:Nemerle.Compiler.FunctionType.FromTupleTyCon" />
    <member name="F:Nemerle.Compiler.FunctionType.FromTupleVoidTyCon" />
    <member name="F:Nemerle.Compiler.FunctionType.FromTupleCtor" />
    <member name="F:Nemerle.Compiler.FunctionType.FromTupleVoidCtor" />
    <member name="M:Nemerle.Compiler.FunctionType.GetMethodWithReturnType(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.FunctionType.GetTupledMethodWithReturnType(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.FunctionType.Make(Nemerle.Compiler.TypeVar)" />
    <member name="F:Nemerle.Compiler.FunctionType.function_name" />
    <member name="F:Nemerle.Compiler.FunctionType.function_void_name" />
    <member name="F:Nemerle.Compiler.FunctionType.function_from_tuple_name" />
    <member name="F:Nemerle.Compiler.FunctionType.function_void_from_tuple_name" />
    <member name="M:Nemerle.Compiler.FunctionType.#ctor(Nemerle.Compiler.ManagerClass,System.Int32)" />
    <member name="M:Nemerle.Compiler.FunctionType.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.InternalTypeClass" />
    <member name="M:Nemerle.Compiler.InternalTypeClass._N_single_57201(Nemerle.Compiler.InternalTypeClass._N_closureOf_InitSystemTypes_57173,Nemerle.Compiler.TypeInfo,System.String)" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Void_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Array_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Attribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Boolean_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Byte_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Char_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Decimal_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Delegate_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.MulticastDelegate_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Double_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Enum_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Exception_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Int16_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Int32_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Int64_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IntPtr_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Object_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.SByte_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Single_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.String_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Type_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.MethodInfo_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ConstructorInfo_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.FieldInfo_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.PropertyInfo_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.UInt16_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.UInt32_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.UInt64_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ValueType_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.MatchFailureException_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.NullMatchException_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ContainsMacroAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.VariantAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ImmutableAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ExtensionAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.TypeAliasAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.VariantOptionAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.VolatileModifier_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ConstantVariantOptionAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ExtensionPatternEncodingAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.FlagsAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ParamArrayAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyVersionAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyKeyFileAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyCompanyAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyProductAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyTitleAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyDescriptionAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyCopyrightAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyCultureAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.AssemblyFileVersionAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Nemerle_list_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Nemerle_option_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IList_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ICollection_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IEnumerable_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IEnumerator_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Generic_IEnumerable_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Generic_IEnumerator_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Generic_IList_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Generic_ICollection_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Generic_Nullable_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.DllImport_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Serializable_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Obsolete_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Conditional_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IgnoreFieldAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IgnoreConstructorAttribute_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IdentityFunction_tc" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.function_types" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.tuple_types" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.array_types" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Void" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Array" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Attribute" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Boolean" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Byte" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Char" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Decimal" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Delegate" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Double" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Enum" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Exception" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Int16" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Int32" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Int64" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IntPtr" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Object" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.SByte" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Single" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.String" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Type" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.MethodInfo" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ConstructorInfo" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.FieldInfo" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.PropertyInfo" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.UInt16" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.UInt32" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.UInt64" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.ValueType" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.MatchFailureException" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.IObjectReference" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Reflection_Missing" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Delegate_Combine" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Delegate_Remove" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.String_Concat" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_IntegralTypes" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.IntegralTypes" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_NewMatchFailureException_ctor" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.NewMatchFailureException_ctor" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_MatchFailureException_ctor" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.MatchFailureException_ctor" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_String_opEquality" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.String_opEquality" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_Decimal_opEquality" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.Decimal_opEquality" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_single_method(Nemerle.Compiler.TypeInfo,System.String)" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.GetFunctionType(System.Int32)" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.GetTupleType(System.Int32)" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.GetArrayType(System.Int32)" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.lookup(System.String)" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.lookup(System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.InitSystemTypes" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.InitNemerleTypes" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="F:Nemerle.Compiler.InternalTypeClass.Manager" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_InternalType" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.InternalType" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.InternalTypeClass.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.__fake" />
    <member name="M:Nemerle.Compiler.InternalTypeClass.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LibraryReferenceManager">
      <summary>
        <para>LibRefManager for the referenced libraries

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager._N_loop_58735(Nemerle.Compiler.LibraryReferenceManager._N_closureOf_framework_nesting_58724,System.Type,Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager._N__N_lambda__58476_58502(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager._N__N_lambda__58470_58494(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager._N_assembly_by_name_58185(Nemerle.Compiler.LibraryReferenceManager._N_closureOf_LookupAssembly_58177,System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager._N_assembly_dir_57274(Nemerle.Compiler.LibraryReferenceManager._N_closureOf__ctor_57263,System.Type)" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager.NameTree" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager.add_buildins" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.#ctor(Nemerle.Compiler.ManagerClass,Nemerle.Core.list{System.String})">
      <summary>
        <para>constructor. Always load the Framework core library.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.AddLibrary(System.String)">
      <summary>
        <para>Stores the referenced library for later lookup by the namespaces. Also
 add transitive closure of libraries needed by given assembly.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.AddAssembly(System.Reflection.Assembly)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.GetExtensionMethods(System.String,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.GetExtensionMethodsForCompletion(System.String,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.GetExtensionMethodsForCompletion(System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.AddExtensionMethod(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.DirectoryOfCodebase(System.String)">
      <summary>
        <para>Remove assembly file name from URL returned by Assembly.CodeBase.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.assemblyLoad(System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.assemblyLoad(System.Reflection.AssemblyName)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.assemblyLoadFrom(System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.getAssemblyLocation(System.Reflection.Assembly)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.getAssemblyLocation(System.Reflection.AssemblyName)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LookupAssembly(System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.load_macro(System.Reflection.Assembly,System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LoadLibrariesContents" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LoadPluginsFrom(System.String,System.String,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LoadMacrosFrom(System.Reflection.Assembly)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LoadParsersFrom(System.Reflection.Assembly)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.IsAssemblyLoaded(System.String)" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager._lib_path">
      <summary>
        <para>List of directories we look for assemblies in.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.LibraryReferenceManager._loaded_assemblies_by_name" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager._loaded_macro_assemblies" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager._assemblies_loaded_by_hand" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager.namespace_nodes" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager._construct_right_away" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager._extension_methods" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.RemoveInternalExtensionMethods">
      <summary>
        <para>Remove extension methods defined in code (not external).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LoadExtensions" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.IsExtension(System.Reflection.ICustomAttributeProvider)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.LoadTypesFrom(Nemerle.Compiler.LibraryReference)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.CacheTypeInfo(System.Type,Nemerle.Compiler.TypeInfo,Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.GetInternalType(Nemerle.Compiler.LibraryReference,System.Type,Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.cache_namespace_node(System.String)" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.framework_nesting(System.Type)" />
    <member name="F:Nemerle.Compiler.LibraryReferenceManager.Manager">
      <summary>
        <para>LibRefManager for the referenced libraries

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.get_InternalType" />
    <member name="P:Nemerle.Compiler.LibraryReferenceManager.InternalType" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.get_SystemTypeCache">
      <summary>
        <para>LibRefManager for the referenced libraries

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.LibraryReferenceManager.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.__fake">
      <summary>
        <para>LibRefManager for the referenced libraries

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LibraryReferenceManager.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.NumericKind" />
    <member name="F:Nemerle.Compiler.NumericKind.value__" />
    <member name="F:Nemerle.Compiler.NumericKind.Signed" />
    <member name="F:Nemerle.Compiler.NumericKind.Unsigned" />
    <member name="F:Nemerle.Compiler.NumericKind.Float" />
    <member name="F:Nemerle.Compiler.NumericKind.Char" />
    <member name="T:Nemerle.Compiler.DecisionTreeCompiler" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler._N_make_stats_59797(Nemerle.Compiler.DecisionTreeCompiler._N_closureOf_get_stats_59779,Nemerle.Compiler.DecisionTreeBuilder.Decision,System.Int32,System.Boolean)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler._N_selectCases_59490(Nemerle.Compiler.DecisionTreeCompiler._N_closureOf_compile_switch_59468,Nemerle.Compiler.DecisionTreeBuilder.Decision)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler._N_compile_literal_59216(Nemerle.Compiler.DecisionTreeCompiler._N_closureOf_compile_ifeq_59193,Nemerle.Compiler.Literal,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler._N_compile_variant_59203(Nemerle.Compiler.DecisionTreeCompiler._N_closureOf_compile_ifeq_59193,Nemerle.Compiler.TypeInfo,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler._N_walk_patterns_58887(Nemerle.Compiler.DecisionTreeCompiler._N_closureOf_collect_effects_and_guards_58873,System.Int32,Nemerle.Compiler.DecisionTreeCompiler.SharedEffect,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr}}}},Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case})" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler._N_walk_cases_58881(Nemerle.Compiler.DecisionTreeCompiler._N_closureOf_collect_effects_and_guards_58873,System.Int32,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case})" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.tyvar" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.val" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.cases" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.decision" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.effects" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.shared_effects" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.guards" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.guardUsed" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.jump_out_id" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.typer3" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.min_switch_size_for_variants" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.min_switch_size_for_ordinals" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.#ctor(Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case},Nemerle.Compiler.Typer3)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.collect_effects_and_guards" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.Run">
      <summary>
        <para>Generate TExpr tree for decision tree stored in this matching compiler.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.Run(Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case},Nemerle.Compiler.Typer3)">
      <summary>
        <para>Build and compile decision tree for the given matching instance.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.compile(Nemerle.Compiler.DecisionTreeBuilder.Decision)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.compile2(Nemerle.Compiler.DecisionTreeBuilder.Decision)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.compile_ifeq(Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.compile_switch(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,System.Int32,Nemerle.Builtins.Function{Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,Nemerle.Builtins.Tuple{System.Boolean,System.Int32}},Nemerle.Builtins.Function{Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.compile_switch(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,System.Int32,Nemerle.Builtins.Function{Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,Nemerle.Builtins.Tuple{System.Boolean,System.Int32}},Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.compile_switch(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,System.Int32,Nemerle.Builtins.Function{Nemerle.Compiler.DecisionTreeBuilder.Decision.IfEq,Nemerle.Builtins.Tuple{System.Boolean,System.Int32}},Nemerle.Compiler.DecisionTreeCompiler.SingleSwitchCaseHandler)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.get_debug_loc(Nemerle.Compiler.DecisionTreeBuilder.Decision)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.get_path_expression(Nemerle.Compiler.DecisionTreeBuilder.Path)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.build_path_expression(Nemerle.Compiler.DecisionTreeBuilder.Path)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.get_stats(Nemerle.Compiler.DecisionTreeBuilder.Decision)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.dag_to_string(Nemerle.Compiler.DecisionTreeBuilder.Decision,System.Boolean)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.build_record_field_ref(Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.emit_compare_with(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Literal)">
      <summary>
        <para>Emit comparison code with specific literal.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.get_constant_object(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Returns the constant object for a parameterless variant constructor

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.If(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Location,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.Switch(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.option{Nemerle.Compiler.Typedtree.TExpr},Nemerle.Core.list{Nemerle.Builtins.Tuple{System.Int32,Nemerle.Compiler.Typedtree.TExpr}})" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.Cast(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.Sequence(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.HasType(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.ThrowMatchFailure" />
    <member name="F:Nemerle.Compiler.DecisionTreeCompiler.Manager" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.get_InternalType" />
    <member name="P:Nemerle.Compiler.DecisionTreeCompiler.InternalType" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.DecisionTreeCompiler.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.__fake" />
    <member name="M:Nemerle.Compiler.DecisionTreeCompiler.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.DecisionTreeCompiler.Path" />
    <member name="T:Nemerle.Compiler.DecisionTreeCompiler.Decision" />
    <member name="T:Nemerle.Compiler.DecisionTreeCompiler.SharedEffect" />
    <member name="T:Nemerle.Compiler.DecisionTreeCompiler.SingleSwitchCaseHandler" />
    <member name="T:Nemerle.Compiler.TypesManager">
      <summary>
        <para>This part of TypesManages is responsible for generation of System.Reflection.Emit structures
 composing program hierarchy. It executes emission of all classes and their members.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager._N_take_string_62921(Nemerle.Compiler.TypesManager._N_closureOf_CreateAssemblyName_62898,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.TypesManager._N_addAttributeForType_62554(Nemerle.Compiler.TypesManager._N_closureOf_loop_62522,Nemerle.Compiler.TypesManager._N_closureOf_GetInformationalAssemblyAttributes_62508,System.Type)" />
    <member name="M:Nemerle.Compiler.TypesManager._N_take_string_62543(Nemerle.Compiler.TypesManager._N_closureOf_loop_62522,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.TypesManager._N_add_62443(Nemerle.Compiler.TypesManager._N_closureOf_AddAssemblyAttribute_62431,Nemerle.MacroPhase)" />
    <member name="M:Nemerle.Compiler.TypesManager._N_allow_it_61631(Nemerle.Compiler.TypesManager._N_closureOf_compile_all_tyinfos_61621,Nemerle.Compiler.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.TypesManager._N_escape_resource_60962(System.String)" />
    <member name="M:Nemerle.Compiler.TypesManager.resolve_hack(System.Object,System.ResolveEventArgs)" />
    <member name="M:Nemerle.Compiler.TypesManager.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.TypesManager.Dispose" />
    <member name="M:Nemerle.Compiler.TypesManager.CreateAssembly" />
    <member name="M:Nemerle.Compiler.TypesManager.get_IsEmitting" />
    <member name="P:Nemerle.Compiler.TypesManager.IsEmitting" />
    <member name="M:Nemerle.Compiler.TypesManager.add_resources_to_assembly" />
    <member name="M:Nemerle.Compiler.TypesManager.EmitAuxDecls">
      <summary>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.EmitDecls">
      <summary>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.get_GeneratedAssembly" />
    <member name="P:Nemerle.Compiler.TypesManager.GeneratedAssembly">
      <summary>
        <para>Returns generated assembly for runtime instantations of its types

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.SaveAssembly">
      <summary>
        <para>Saves the constructed assembly to a file

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.compile_all_tyinfos(System.Boolean)">
      <summary>
        <para>- create S.R.E.TypeBuilders for entire hierarchy of program
 - add members to those TypeBuilders (only stubs for methods)
 - emit bodies of methods
 - finalize value types
 - finalize all types

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.EnsureEmitProgress(Nemerle.Compiler.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.TypesManager.MaybeCompile(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.MemberBuilder)" />
    <member name="M:Nemerle.Compiler.TypesManager.is_aux_decl(Nemerle.Compiler.TypeBuilder)">
      <summary>
        <para>Check if declaration is auxiliary, used internally etc.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.make_platform_flags(System.String)" />
    <member name="F:Nemerle.Compiler.TypesManager._assembly_name" />
    <member name="F:Nemerle.Compiler.TypesManager._assembly_builder" />
    <member name="F:Nemerle.Compiler.TypesManager._module_builder" />
    <member name="F:Nemerle.Compiler.TypesManager._debug_emit" />
    <member name="F:Nemerle.Compiler.TypesManager.contains_nemerle_specifics" />
    <member name="F:Nemerle.Compiler.TypesManager._need_entry_point" />
    <member name="F:Nemerle.Compiler.TypesManager._entry_point">
      <summary>
        <para>updated when method with static Main signature is met
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.TypesManager._OutputFileName" />
    <member name="F:Nemerle.Compiler.TypesManager._cgil_phase" />
    <member name="F:Nemerle.Compiler.TypesManager.infos" />
    <member name="F:Nemerle.Compiler.TypesManager.assembly_attributes" />
    <member name="F:Nemerle.Compiler.TypesManager.run_phase" />
    <member name="F:Nemerle.Compiler.TypesManager._codeWriter" />
    <member name="F:Nemerle.Compiler.TypesManager.attribute_macros_queue" />
    <member name="M:Nemerle.Compiler.TypesManager.Init" />
    <member name="M:Nemerle.Compiler.TypesManager.AddMacroExpansion(Nemerle.Compiler.TypesManager.AttributeMacroExpansion)" />
    <member name="F:Nemerle.Compiler.TypesManager.is_expanding" />
    <member name="M:Nemerle.Compiler.TypesManager.ExpandMacros" />
    <member name="M:Nemerle.Compiler.TypesManager.get_current_macro_phase" />
    <member name="P:Nemerle.Compiler.TypesManager.current_macro_phase" />
    <member name="M:Nemerle.Compiler.TypesManager.CreateTypeBuilder(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.TopDeclaration,Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.TypesManager.RemoveProgramTypes">
      <summary>
        <para>Clears the type tree from classes defined in currently analyzed program

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.determine_subtyping">
      <summary>
        <para>Construct datastructures we use to check subtyping relations.

</para>
      </summary> <remarks>
   <para>This probably the hardest part of processing type declarations.

</para>   <para>Each type directly subtypes types it extends or implements.  This
   pass computes transitive closure of direct subtyping relation
   and stores it [TypeBuilder.supertypes] map.  .NET generics doesn't allow
   same type to be subtyped under different instantiations, so we
   use map from (id of) subtyped TypeBuilder object to actual parameters
   of subtyped type.
 </para></remarks>

</member>
    <member name="M:Nemerle.Compiler.TypesManager.Iter(Nemerle.Core.list{Nemerle.Compiler.TypeBuilder},Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.TypeBuilder})" />
    <member name="M:Nemerle.Compiler.TypesManager.Iter(Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.TypeBuilder})">
      <summary>
        <para>Iterate over all types defined in source code.

</para>
      </summary> <remarks><para>Supertypes are always processed before subtypes otherwise
 source code order is retained.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypesManager.IterConditionally(Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.TypeBuilder},Nemerle.Builtins.Function{Nemerle.Compiler.TypeBuilder,System.Boolean})" />
    <member name="M:Nemerle.Compiler.TypesManager.TopTypeBuilders" />
    <member name="M:Nemerle.Compiler.TypesManager.TopIter(Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.TypeBuilder})">
      <summary>
        <para>Iterate over top level types in inheritance order.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.Run">
      <summary>
        <para>Main function of type declaration handling pass.

</para>
      </summary> <remarks>
   <para>- constructing typing environments [TypeBuilder.make_tyenvs]
   - binding types [TypeBuilder.bind_types]
   - determining subtyping relations [TypeBuilder.determine_subtyping]
   - checking subtyping constraints on types that are already bound
     [TypeBuilder.check_bound_types]
   - adding members [TypeBuilder.add_members]
   - adding the variant/variant option special matching methods
 </para></remarks>

</member>
    <member name="M:Nemerle.Compiler.TypesManager.SaveGeneratedSourceFile" />
    <member name="M:Nemerle.Compiler.TypesManager.GetNameForGeneratedSourceFile" />
    <member name="M:Nemerle.Compiler.TypesManager.CheckFinalization">
      <summary>
        <para>Called at the end of the finialization.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.CheckForUnusedGlobalSymbols">
      <summary>
        <para>This method iterates through all the known type builders,
 looking for unused global symbols.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.GenerateFakeSourceCode(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.TypesManager.read_keypair(Nemerle.Compiler.Location,System.String)" />
    <member name="M:Nemerle.Compiler.TypesManager.AddAssemblyAttribute(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypesManager.GetInformationalAssemblyAttributes" />
    <member name="M:Nemerle.Compiler.TypesManager.ParseVersion(System.String,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.TypesManager.CreateAssemblyName" />
    <member name="F:Nemerle.Compiler.TypesManager.Manager">
      <summary>
        <para>This part of TypesManages is responsible for generation of System.Reflection.Emit structures
 composing program hierarchy. It executes emission of all classes and their members.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.get_InternalType" />
    <member name="P:Nemerle.Compiler.TypesManager.InternalType" />
    <member name="M:Nemerle.Compiler.TypesManager.get_SystemTypeCache">
      <summary>
        <para>This part of TypesManages is responsible for generation of System.Reflection.Emit structures
 composing program hierarchy. It executes emission of all classes and their members.

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.TypesManager.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.TypesManager.__fake">
      <summary>
        <para>This part of TypesManages is responsible for generation of System.Reflection.Emit structures
 composing program hierarchy. It executes emission of all classes and their members.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypesManager.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.TypesManager.AttributeMacroExpansion" />
    <member name="T:Nemerle.Compiler.TypesManager.AssemblyAttributeMacroExpansion" />
    <member name="T:Nemerle.Compiler.TypeBuilder" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_isImplementInterface_67794(Nemerle.Compiler.TypeBuilder._N_closureOf_GetAllSubTypes_67754,Nemerle.Compiler.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_getDirectSubTypes_67766(Nemerle.Compiler.TypeBuilder._N_closureOf_GetAllSubTypes_67754,Nemerle.Compiler.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_check_for_invalid_attr_67636(Nemerle.Compiler.TypeBuilder._N_closureOf_CheckTypeAttributes_67615,Nemerle.Compiler.NemerleModifiers,System.String)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_title_67623(Nemerle.Compiler.TypeBuilder._N_closureOf_CheckTypeAttributes_67615)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_check_ctors_67440(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_scream_about_unimplemented_67017(Nemerle.Compiler.TypeBuilder._N_closureOf_resolve_method_implements_66661,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}})" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_create_additional_overrides_66969(Nemerle.Compiler.TypeBuilder._N_closureOf_resolve_method_implements_66661,System.String,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}})" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_bind_implicit_implements_66915(Nemerle.Compiler.TypeBuilder._N_closureOf_resolve_method_implements_66661,Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_partition_and_set_66836(Nemerle.Compiler.TypeBuilder._N_closureOf_bindOneExplicitMethodRef_66783,Nemerle.Compiler.TypeBuilder._N_closureOf_bind_explicit_implements_66765,Nemerle.Compiler.TypeBuilder._N_closureOf_resolve_method_implements_66661,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}},Nemerle.Collections.Hashtable{System.String,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}}})" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_bind_explicit_implements_66759(Nemerle.Compiler.TypeBuilder._N_closureOf_resolve_method_implements_66661,Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_collect_methods_66727(Nemerle.Compiler.FixedType.Class,Nemerle.Collections.Hashtable{System.String,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}}})" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_partition_correct_meth_66689(Nemerle.Compiler.TypeBuilder._N_closureOf_resolve_method_implements_66661,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}},Nemerle.Compiler.IMethod,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_is_cast_op_65690(Nemerle.Compiler.TypeBuilder._N_closureOf_replace_method_65667,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_replace_method_65661(Nemerle.Compiler.TypeBuilder._N_closureOf_AddMember_65648,Nemerle.Core.list{Nemerle.Compiler.IMember},Nemerle.Compiler.MethodBuilder,Nemerle.Core.list{Nemerle.Compiler.IMember})" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_inherit_it_65418(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_add_sr_65350(Nemerle.Compiler.TypeBuilder._N_closureOf_add_subtyping_of_65340,Nemerle.Collections.Map{Nemerle.Compiler.TypeInfo,Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.FixedType}}},Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.FixedType})" />
    <member name="M:Nemerle.Compiler.TypeBuilder._N_getLoc_64614(Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.CreateEmitBuilder">
      <summary>
        <para>This method makes a skeleton of a class -- the class partial type and
 partial types for the nested classes are created. The parent class and
 the interfaces being implemented are assumed to have been processed
 before constructing a dependant class. All the declarations and method
 implementations will be created successively in subsequent passes.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.make_nemerle_variant_attribute(Nemerle.Core.list{Nemerle.Compiler.TypeInfo})">
      <summary>
        <para>Builds a Nemerle variant attribute

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.make_nemerle_type_alias_attribute(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Builds a Nemerle type alias

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.make_nemerle_variant_option_attribute(System.Boolean)">
      <summary>
        <para>Builds a Nemerle variant option attribute

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.make_type_attributes(Nemerle.Compiler.NemerleModifiers,System.Boolean,System.Boolean)">
      <summary>
        <para>Converts Nemerle modifiers to the Framework type attributes.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.EmitImplementation">
      <summary>
        <para>Set up custom attributes on members of this TypeBuilder. Compile method's bodies.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.CreateEmitDeclarations">
      <summary>
        <para>This methods walks the class and adds field and method declarations.
 The method implementation will be filled in a separate pass.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.determine_inheritance">
      <summary>
        <para>Reads the inheritance list of a class and retrieves the base
 type and builds the array of interfaces implemented by the class.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.UpdateEmittedInheritance" />
    <member name="F:Nemerle.Compiler.TypeBuilder.tydecl" />
    <member name="F:Nemerle.Compiler.TypeBuilder.before_finalization" />
    <member name="F:Nemerle.Compiler.TypeBuilder.before_finalization2" />
    <member name="F:Nemerle.Compiler.TypeBuilder._declaringType" />
    <member name="F:Nemerle.Compiler.TypeBuilder.parent_type" />
    <member name="F:Nemerle.Compiler.TypeBuilder.forced_typarms" />
    <member name="F:Nemerle.Compiler.TypeBuilder.reflection_inheritance_emitted" />
    <member name="F:Nemerle.Compiler.TypeBuilder.is_lambda" />
    <member name="F:Nemerle.Compiler.TypeBuilder.t_implements" />
    <member name="F:Nemerle.Compiler.TypeBuilder.contained_types" />
    <member name="F:Nemerle.Compiler.TypeBuilder.variant_options" />
    <member name="F:Nemerle.Compiler.TypeBuilder.member_list" />
    <member name="F:Nemerle.Compiler.TypeBuilder.constant_object" />
    <member name="F:Nemerle.Compiler.TypeBuilder.underlying_enum_type" />
    <member name="F:Nemerle.Compiler.TypeBuilder._N_UnimplementedMembers_11628" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_UnimplementedMembers" />
    <member name="M:Nemerle.Compiler.TypeBuilder.set_UnimplementedMembers(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMember}})" />
    <member name="P:Nemerle.Compiler.TypeBuilder.UnimplementedMembers" />
    <member name="F:Nemerle.Compiler.TypeBuilder.init_list" />
    <member name="F:Nemerle.Compiler.TypeBuilder.tenv" />
    <member name="F:Nemerle.Compiler.TypeBuilder.type_builder" />
    <member name="F:Nemerle.Compiler.TypeBuilder.pt_name" />
    <member name="F:Nemerle.Compiler.TypeBuilder.name" />
    <member name="F:Nemerle.Compiler.TypeBuilder.loc" />
    <member name="F:Nemerle.Compiler.TypeBuilder.parts_location" />
    <member name="F:Nemerle.Compiler.TypeBuilder.modifiers" />
    <member name="F:Nemerle.Compiler.TypeBuilder.accessibility" />
    <member name="F:Nemerle.Compiler.TypeBuilder.typarms_count" />
    <member name="F:Nemerle.Compiler.TypeBuilder._ast" />
    <member name="F:Nemerle.Compiler.TypeBuilder.additional_decls" />
    <member name="F:Nemerle.Compiler.TypeBuilder.partial_parts" />
    <member name="F:Nemerle.Compiler.TypeBuilder._nameLocation" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_NameLocation" />
    <member name="P:Nemerle.Compiler.TypeBuilder.NameLocation" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_AstParts" />
    <member name="P:Nemerle.Compiler.TypeBuilder.AstParts" />
    <member name="F:Nemerle.Compiler.TypeBuilder.is_enum" />
    <member name="F:Nemerle.Compiler.TypeBuilder.is_finalized" />
    <member name="F:Nemerle.Compiler.TypeBuilder.cannot_finalize" />
    <member name="F:Nemerle.Compiler.TypeBuilder.m_has_been_used" />
    <member name="F:Nemerle.Compiler.TypeBuilder.instance_ctor_occured">
      <summary>
        <para>if it doesn't, we must add implicit empty constructor

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.TypeBuilder.phase">
      <summary>
        <para>Marker for [TypeBuilder.Iter].

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.TypeBuilder.is_delegate" />
    <member name="F:Nemerle.Compiler.TypeBuilder.TyManager" />
    <member name="F:Nemerle.Compiler.TypeBuilder.iterate_first">
      <summary>
        <para>Defining type if any and transitive closure of base types of this type.

</para>
      </summary> <remarks><para>Used by [TypeBuilder.Iter] function.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.TypeBuilder._userData" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_UserData" />
    <member name="P:Nemerle.Compiler.TypeBuilder.UserData" />
    <member name="F:Nemerle.Compiler.TypeBuilder.is_special_variant_methods_added" />
    <member name="M:Nemerle.Compiler.TypeBuilder.#ctor(Nemerle.Compiler.TypesManager,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.TopDeclaration,Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.CalcAccessibility" />
    <member name="M:Nemerle.Compiler.TypeBuilder.CreateVariant" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsInterface" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsInterface" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsDelegate" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsDelegate" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsAlias" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsAlias" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsStruct" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsStruct" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsValueType" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsValueType" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsVariantOption" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsVariantOption" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetModifiers" />
    <member name="M:Nemerle.Compiler.TypeBuilder.IsCustomAttributeDefined(System.String)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_GlobalEnv" />
    <member name="P:Nemerle.Compiler.TypeBuilder.GlobalEnv" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_ParsedName" />
    <member name="P:Nemerle.Compiler.TypeBuilder.ParsedName" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_ParsedDeclaration" />
    <member name="P:Nemerle.Compiler.TypeBuilder.ParsedDeclaration" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_ParsedTypeName" />
    <member name="P:Nemerle.Compiler.TypeBuilder.ParsedTypeName" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_DeclaringType" />
    <member name="P:Nemerle.Compiler.TypeBuilder.DeclaringType">
      <summary>
        <para>Return type we were defined in (null for toplevel types).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.get_OuterTypes" />
    <member name="P:Nemerle.Compiler.TypeBuilder.OuterTypes" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_Name" />
    <member name="P:Nemerle.Compiler.TypeBuilder.Name">
      <summary>
        <para>Return name without any dots.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.get_Accessibility" />
    <member name="P:Nemerle.Compiler.TypeBuilder.Accessibility" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsExternallyAccessible" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsExternallyAccessible" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_UnderlyingType" />
    <member name="P:Nemerle.Compiler.TypeBuilder.UnderlyingType" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_Location" />
    <member name="P:Nemerle.Compiler.TypeBuilder.Location" />
    <member name="M:Nemerle.Compiler.TypeBuilder.SetLocation(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.TypeBuilder.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.TypeBuilder.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_DeclaredTypeParametersCount" />
    <member name="P:Nemerle.Compiler.TypeBuilder.DeclaredTypeParametersCount">
      <summary>
        <para>Count of type parameters declared in this type (without type parameters of outer types)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.get_TyparmsCount" />
    <member name="P:Nemerle.Compiler.TypeBuilder.TyparmsCount">
      <summary>
        <para>Count of type parameters in this type and all outer types

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.AddImplementedInterface(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DefineNestedType(Nemerle.Compiler.Parsetree.ClassMember.TypeDeclaration,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DefineNestedType(Nemerle.Compiler.Parsetree.ClassMember.TypeDeclaration)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DefineAndReturn(Nemerle.Compiler.Parsetree.ClassMember)">
      <summary>
        <para>Adds a definition and returns the new MemberBuilder, if available

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.DefineAndReturn(Nemerle.Compiler.Parsetree.ClassMember,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DefineWithSource(Nemerle.Compiler.Parsetree.ClassMember,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.Define(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.Define(Nemerle.Compiler.Parsetree.ClassMember,System.Boolean)">
      <summary>
        <para>Adds a definition to this type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.Compile">
      <summary>
        <para>Builds this type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.FindAttributeWithArgs(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.FindAttributesWithArgs(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.FindAttribute(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_AttributeTargets" />
    <member name="P:Nemerle.Compiler.TypeBuilder.AttributeTargets" />
    <member name="M:Nemerle.Compiler.TypeBuilder.HasAttribute(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DisableImplicitConstructor" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DoBeforeFinalization(Nemerle.Builtins.FunctionVoid)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.DoBeforeFinalization2(Nemerle.Builtins.FunctionVoid)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.MarkWithSpecialName">
      <summary>
        <para>Marks this with the SpecialName attribute, the attribute will
 be propagated to members and contained types at a later stage.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.MarkAsDelegate" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetDirectSuperTypes">
      <summary>
        <para>Return list of types that we directly subtype.

</para>
      </summary> <remarks>
   <para>This includes [extends] and [implements], as well as parent variant
   type for variant options.
 </para></remarks>

</member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetConstantObject" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_BaseType" />
    <member name="P:Nemerle.Compiler.TypeBuilder.BaseType">
      <summary>
        <para>Returns null if there isn't any
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.SuperClass">
      <summary>
        <para>Return type we extend if any.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetTydecl" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_LookupMemberAvailable" />
    <member name="P:Nemerle.Compiler.TypeBuilder.LookupMemberAvailable" />
    <member name="M:Nemerle.Compiler.TypeBuilder.LookupMemberImpl(System.String)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>
        <para>Searches for the members defined for the current TypeInfo, using the specified
      binding constraints.

</para>
      </summary>      <remarks>
        <para>Members include properties, methods, fields, events, and so on.

</para>        <para>The following BindingFlags filter flags can be used to define which members to
        include in the search:
        <ul>
          <li>
            You must specify either BindingFlags.Instance or BindingFlags.Static in order to
            get a return.
          </li>
          <li>
            Specify BindingFlags.Public to include public members in the search.
          </li>
          <li>
            Specify BindingFlags.NonPublic to include non-public members (that is, private
            and protected members) in the search.
          </li>
        </ul>

</para>        <para>The following BindingFlags modifier flags can be used to change how the search
        works:

</para>        <para>BindingFlags.DeclaredOnly to search only the members declared on the TType,
        not members that were simply inherited.

</para>        <para>Calling this method with only the Public flag or only the NonPublic flag will
        return the specified members and does not require any other flags.

</para>        <para>See Nemerle.Compiler.BindingFlags for more information.
      </para></remarks>

</member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetMembers" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetParsedMembers(System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetFields" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>
        <para>Searches for the methods defined for the current TypeInfo, using the
      specified binding constraints.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetMethods" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>
        <para>Searches for the constructors defined for the current TypeBuilder, using the
      specified BindingFlags.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetConstructors" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>
        <para>Searches for the types defined for the current TypeInfo, using the
      specified BindingFlags.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetNestedTypes" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetProperties" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetEvents" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetDirectMembers">
      <summary>
        <para>Return list of all members defined in this very type.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetTypeBuilder" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetVariantOptionParent" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetVariantOptions" />
    <member name="M:Nemerle.Compiler.TypeBuilder.ReverseChildren" />
    <member name="M:Nemerle.Compiler.TypeBuilder.make_tyenvs">
      <summary>
        <para>Construct typing environments for each declaration.

</para>
      </summary> <remarks>
   <para>The first thing to do is to create typing environment [Tyvar.TEnv]
   for each type declaration.  Then typing environment is populated
   with type variables (transformed into [Tyvar.T] objects).  Finally
   constraints (type expressions, which are first bound) of each
   type variable are stored in [Tyvar.T].

</para>   <para>Typing environment maps names of type variables to [Tyvar.T] objects.
 </para></remarks>

</member>
    <member name="F:Nemerle.Compiler.TypeBuilder._nestingLevel" />
    <member name="M:Nemerle.Compiler.TypeBuilder.TryAddSuperType(Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.AddSuperType(Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.bind_types">
      <summary>
        <para>Bind type expressions occurring in type declarations. This
 includes [extends] type, [implements] list, and aliased type
 in case of type alias declaration.

</para>
      </summary> <remarks>
   <para>Binding type expression refers to rewriting [Parsetree.Type]
   into [Typedtree.TType], which involves resolving names of type
   constructors (to [TypeInfo] objects) and type variables (to [Tyvar.T]
   objects).
 </para></remarks>

</member>
    <member name="F:Nemerle.Compiler.TypeBuilder.subtyping_map_constructed" />
    <member name="M:Nemerle.Compiler.TypeBuilder.construct_subtyping_map" />
    <member name="M:Nemerle.Compiler.TypeBuilder.add_subtyping_of(Nemerle.Collections.Map{Nemerle.Compiler.TypeInfo,Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.FixedType}}},Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.TypeBuilder.add_derived_members" />
    <member name="M:Nemerle.Compiler.TypeBuilder.ExtendPartialClass(Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.constrain_member(Nemerle.Compiler.IMember,System.Reflection.BindingFlags)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_members(System.Reflection.BindingFlags,Nemerle.Builtins.Function{Nemerle.Compiler.IMember,System.Boolean})">
      <summary>
        <para>Note that [bindingAttr] is used only to check the case for DeclaredOnly
      members, so you have to provide filter function to check other flags
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.BindType(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BindFixedType(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BindType(Nemerle.Compiler.TypeVarEnv,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BindFixedType(Nemerle.Compiler.TypeVarEnv,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BindTyparms(Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BindTyparms(Nemerle.Compiler.TypeVarEnv,Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BindAndAddMember(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.AddMember(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_CannotFinalize" />
    <member name="M:Nemerle.Compiler.TypeBuilder.set_CannotFinalize(System.Boolean)" />
    <member name="P:Nemerle.Compiler.TypeBuilder.CannotFinalize" />
    <member name="M:Nemerle.Compiler.TypeBuilder.CreateSystemType" />
    <member name="M:Nemerle.Compiler.TypeBuilder.BeforeFinalizeType" />
    <member name="M:Nemerle.Compiler.TypeBuilder.FinalizeType" />
    <member name="M:Nemerle.Compiler.TypeBuilder.bind_and_add_member(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.handle_underlying_enum_type" />
    <member name="M:Nemerle.Compiler.TypeBuilder.calculate_enum_value(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Literal.Integer,Nemerle.Collections.Hashtable{System.String,Nemerle.Compiler.Literal.Integer})" />
    <member name="M:Nemerle.Compiler.TypeBuilder.AddEnumMembers" />
    <member name="M:Nemerle.Compiler.TypeBuilder.add_enum_members(Nemerle.Core.list{Nemerle.Compiler.Parsetree.ClassMember})" />
    <member name="M:Nemerle.Compiler.TypeBuilder.add_members">
      <summary>
        <para>Collect type members (fields and methods, but not types, which
 are already collected in [TypeBuilder.contained_types]) and store
 them in [TypeInfo.member_map] and [TypeBuilder.member_list].

</para>
      </summary> <remarks>
   <para>Members are first transferred from the [Parsetree] into the
   [Typedtree] namespace by binding appropriate types.
 </para></remarks>

</member>
    <member name="M:Nemerle.Compiler.TypeBuilder.add_constant_object_ctor" />
    <member name="M:Nemerle.Compiler.TypeBuilder.add_special_variant_methods">
      <summary>
        <para>Add special methods to variants and variant options. These methods
 are used to accelerate matching over variants, allowing us to use
 a single TExpr.Switch statement to identify a variant options instead of
 a series of TExpr.If/HasType instructions.


</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.add_constant_variant_ctors">
      <summary>
        <para>Add constant fields with single instance of parameter-less
 variant options.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.CheckFieldsInPartialVariantOption" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetTyparms" />
    <member name="M:Nemerle.Compiler.TypeBuilder.FixupDefinedClass" />
    <member name="M:Nemerle.Compiler.TypeBuilder.mark_members_with_special_name">
      <summary>
        <para>Propagates the SpecialName mark throughout the member hierarchy

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.resolve_method_implements">
      <summary>
        <para>Resolves overrides for the required interface methods

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.methods_matches_by_signature(Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod,Nemerle.Compiler.IMethod)">
      <summary>
        <para>determine equality of methods signatures taking into account types substitutions.
 For axample you can compare method of implemented interface and it implementation
 on current type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.get_method_type_after_subst(Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.InterfacesToImplement">
      <summary>
        <para>Return interfaces [this] needs to implement (that is it says it will
 implement them, but they are not implemented in base class).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.get_BaseClass" />
    <member name="P:Nemerle.Compiler.TypeBuilder.BaseClass" />
    <member name="M:Nemerle.Compiler.TypeBuilder.process_attributes(Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement},System.AttributeTargets,Nemerle.MacroPhase,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.add_macros_from_parsedmems(Nemerle.Compiler.Parsetree.ClassMember,Nemerle.MacroPhase)" />
    <member name="F:Nemerle.Compiler.TypeBuilder.process_macro_attributes_stage" />
    <member name="M:Nemerle.Compiler.TypeBuilder.process_macro_attributes(Nemerle.MacroPhase)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.check_bound_type(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.check_bound_types">
      <summary>
        <para>Check if types that are already bound are correctly applied.
      Check accessibility.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.check_ctor_constraints" />
    <member name="M:Nemerle.Compiler.TypeBuilder.check_for_unused_global_symbols" />
    <member name="M:Nemerle.Compiler.TypeBuilder.check_abstract">
      <summary>
        <para>Checks for abstract method in non-abstract class errors.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.CheckAccessAttributes(Nemerle.Compiler.NemerleModifiers)">
      <summary>
        <para>Performs access attributes related checks. Returns an optional
 description of the problem.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.CheckTypeAttributes">
      <summary>
        <para>Performs attributes checks for type definitions.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetDirectSubTypes">
      <summary>
        <para>Get direct (derived directly) subtypes of given type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.GetAllSubTypes">
      <summary>
        <para>Get all subtypes of given type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeBuilder.AddToAdditionalDecls(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.CanAccess(Nemerle.Compiler.TypeInfo)" />
    <member name="F:Nemerle.Compiler.TypeBuilder._conditions" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsConditional" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsConditional" />
    <member name="M:Nemerle.Compiler.TypeBuilder.GetConditions" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_DeclaredNestedTypes" />
    <member name="P:Nemerle.Compiler.TypeBuilder.DeclaredNestedTypes" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_Tenv" />
    <member name="P:Nemerle.Compiler.TypeBuilder.Tenv" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_PartsLocation" />
    <member name="P:Nemerle.Compiler.TypeBuilder.PartsLocation" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_Ast" />
    <member name="P:Nemerle.Compiler.TypeBuilder.Ast" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsEnum" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsEnum" />
    <member name="M:Nemerle.Compiler.TypeBuilder.get_IsFinalized" />
    <member name="M:Nemerle.Compiler.TypeBuilder.set_IsFinalized(System.Boolean)" />
    <member name="P:Nemerle.Compiler.TypeBuilder.IsFinalized" />
    <member name="M:Nemerle.Compiler.TypeBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.TypeBuilder.Relocate(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.TypeBuilder.Subinfo" />
    <member name="T:Nemerle.Compiler.TypeBuilder.RecursiveTypeDefinition" />
    <member name="T:Nemerle.Compiler.MethodBuilder" />
    <member name="M:Nemerle.Compiler.MethodBuilder._N_bind_70062(Nemerle.Compiler.MethodBuilder._N_closureOf__ctor_70005,Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.Nemerle#Compiler#IMethod#GetMethodInfo" />
    <member name="M:Nemerle.Compiler.MethodBuilder.Nemerle#Compiler#IMethod#GetConstructorInfo" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsAbstract" />
    <member name="M:Nemerle.Compiler.MethodBuilder.CreateEmitBuilder(System.Reflection.Emit.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.CompileAfterTyping">
      <summary>
        <para>Emits a method's body

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.parameter_attributes(Nemerle.Compiler.Typedtree.TParameter)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.emit_parameter_attributes" />
    <member name="M:Nemerle.Compiler.MethodBuilder.assign_parameter_indexes(System.Boolean)">
      <summary>
        <para>Assigns an ordinal index to each of a method's parameter

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.param_types" />
    <member name="M:Nemerle.Compiler.MethodBuilder.make_method_attributes(Nemerle.Compiler.NemerleModifiers)">
      <summary>
        <para>Converts Nemerle modifiers to the CLI method attributes.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.CreateMethodBuilder(System.Reflection.Emit.TypeBuilder)">
      <summary>
        <para>Adds a method builder to a type builder

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.CreateConstructorBuilder(System.Reflection.Emit.TypeBuilder)">
      <summary>
        <para>Adds a constructor builder to a type builder

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.Compile" />
    <member name="F:Nemerle.Compiler.MethodBuilder.fun_header" />
    <member name="F:Nemerle.Compiler.MethodBuilder.method_base">
      <summary>
        <para>system reflection emit method/constructor builder is stored here

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.MethodBuilder.overridden_method" />
    <member name="F:Nemerle.Compiler.MethodBuilder._N_ImplementedMethods_12239" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_ImplementedMethods" />
    <member name="M:Nemerle.Compiler.MethodBuilder.set_ImplementedMethods(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod}})" />
    <member name="P:Nemerle.Compiler.MethodBuilder.ImplementedMethods" />
    <member name="F:Nemerle.Compiler.MethodBuilder._N_field_is_extension_embeded_in_IsExtension_3445" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsExtension" />
    <member name="M:Nemerle.Compiler.MethodBuilder.set_IsExtension(System.Boolean)" />
    <member name="P:Nemerle.Compiler.MethodBuilder.IsExtension" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsConstructor" />
    <member name="P:Nemerle.Compiler.MethodBuilder.IsConstructor" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BodyLocation" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BodyLocation" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BodyInnerLocation" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BodyInnerLocation" />
    <member name="F:Nemerle.Compiler.MethodBuilder.is_var_args" />
    <member name="F:Nemerle.Compiler.MethodBuilder.return_value_modifiers" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_Ast" />
    <member name="P:Nemerle.Compiler.MethodBuilder.Ast">
      <summary>
        <para>Parsed representation (AST) of function.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.GetMethodBase" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_HasMethodBase" />
    <member name="P:Nemerle.Compiler.MethodBuilder.HasMethodBase" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetHandle" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetMemType" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetConstructorInfo" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetMethodInfo" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.MethodBuilder.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.MethodBuilder.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_HasAbstractBody" />
    <member name="P:Nemerle.Compiler.MethodBuilder.HasAbstractBody" />
    <member name="M:Nemerle.Compiler.MethodBuilder.RunBodyTyper" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_MemberKind" />
    <member name="P:Nemerle.Compiler.MethodBuilder.MemberKind" />
    <member name="F:Nemerle.Compiler.MethodBuilder._N_field__beforeBodyTyping_embeded_in_BeforeBodyTyping_3446" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BeforeBodyTyping" />
    <member name="M:Nemerle.Compiler.MethodBuilder.set_BeforeBodyTyping(Nemerle.Core.list{Nemerle.Builtins.Function{Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr}})" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BeforeBodyTyping" />
    <member name="M:Nemerle.Compiler.MethodBuilder.AddBeforeBodyTypingHandler(Nemerle.Builtins.Function{Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.MethodBuilder.ClearBeforeBodyTypingHandlers" />
    <member name="M:Nemerle.Compiler.MethodBuilder.NotSupported" />
    <member name="M:Nemerle.Compiler.MethodBuilder.EnsureCompiled" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BodyTokens" />
    <member name="M:Nemerle.Compiler.MethodBuilder.set_BodyTokens(Nemerle.Compiler.Token.BracesGroup)" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BodyTokens" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BodyParsed" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BodyParsed" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsBodyCompilable" />
    <member name="P:Nemerle.Compiler.MethodBuilder.IsBodyCompilable" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BodyTyped" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BodyTyped" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_Body" />
    <member name="M:Nemerle.Compiler.MethodBuilder.set_Body(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="P:Nemerle.Compiler.MethodBuilder.Body" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsFinal" />
    <member name="P:Nemerle.Compiler.MethodBuilder.IsFinal" />
    <member name="M:Nemerle.Compiler.MethodBuilder.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Function)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Function,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.IsVarianceValid(Nemerle.Compiler.TypeVar,System.Int32)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetHeader" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetParameters" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_ReturnType" />
    <member name="P:Nemerle.Compiler.MethodBuilder.ReturnType" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetFreshType" />
    <member name="M:Nemerle.Compiler.MethodBuilder.OperatorLongName(System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.CheckAttributes">
      <summary>
        <para>Performs attributes checks for method definitions.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MethodBuilder.AddAsExtensionMethod" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_BuiltinKind" />
    <member name="P:Nemerle.Compiler.MethodBuilder.BuiltinKind" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_MacroTarget" />
    <member name="P:Nemerle.Compiler.MethodBuilder.MacroTarget" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_MacroSelfParams" />
    <member name="P:Nemerle.Compiler.MethodBuilder.MacroSelfParams" />
    <member name="M:Nemerle.Compiler.MethodBuilder.ProcessMacroAttributes" />
    <member name="F:Nemerle.Compiler.MethodBuilder._isConditional" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsConditional" />
    <member name="P:Nemerle.Compiler.MethodBuilder.IsConditional" />
    <member name="M:Nemerle.Compiler.MethodBuilder.GetConditions" />
    <member name="M:Nemerle.Compiler.MethodBuilder.PrepareForEmission(Nemerle.Compiler.Typedtree.TFunHeader,Nemerle.Compiler.Subst)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.CreateImplementsWrapper" />
    <member name="M:Nemerle.Compiler.MethodBuilder.MakeImplWrapper(Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_Header" />
    <member name="P:Nemerle.Compiler.MethodBuilder.Header" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_IsVarArgs" />
    <member name="P:Nemerle.Compiler.MethodBuilder.IsVarArgs" />
    <member name="M:Nemerle.Compiler.MethodBuilder.get_ReturnValueModifiers" />
    <member name="P:Nemerle.Compiler.MethodBuilder.ReturnValueModifiers" />
    <member name="M:Nemerle.Compiler.MethodBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.MethodBuilder.BeforeBodyTypingHandler" />
    <member name="T:Nemerle.Compiler.FieldBuilder" />
    <member name="M:Nemerle.Compiler.FieldBuilder.Nemerle#Compiler#IField#GetFieldInfo" />
    <member name="M:Nemerle.Compiler.FieldBuilder.CreateEmitBuilder(System.Reflection.Emit.TypeBuilder)">
      <summary>
        <para>Adds a field builder

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FieldBuilder.Compile" />
    <member name="F:Nemerle.Compiler.FieldBuilder.field_builder" />
    <member name="F:Nemerle.Compiler.FieldBuilder.const_value" />
    <member name="F:Nemerle.Compiler.FieldBuilder.has_been_assigned" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_Ast" />
    <member name="P:Nemerle.Compiler.FieldBuilder.Ast">
      <summary>
        <para>Parsed representation (AST) of field.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FieldBuilder.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Field)" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_MemberKind" />
    <member name="P:Nemerle.Compiler.FieldBuilder.MemberKind" />
    <member name="F:Nemerle.Compiler.FieldBuilder._initializerLocation">
      <summary>
        <para>////////////////////////////////////////////////////////////////////////

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FieldBuilder.get_IsInitializerPresent" />
    <member name="P:Nemerle.Compiler.FieldBuilder.IsInitializerPresent" />
    <member name="M:Nemerle.Compiler.FieldBuilder.EnsureCompiled" />
    <member name="M:Nemerle.Compiler.FieldBuilder.LookupInitializerMethod" />
    <member name="M:Nemerle.Compiler.FieldBuilder.ResetCodeCache" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_InitializerTokens" />
    <member name="P:Nemerle.Compiler.FieldBuilder.InitializerTokens" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_InitializerParsed" />
    <member name="P:Nemerle.Compiler.FieldBuilder.InitializerParsed" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_InitializerTyped" />
    <member name="P:Nemerle.Compiler.FieldBuilder.InitializerTyped" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_IsMutable" />
    <member name="P:Nemerle.Compiler.FieldBuilder.IsMutable">
      <summary>
        <para>///////////////////////////////////////////////////////////////////////

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FieldBuilder.get_IsVolatile" />
    <member name="P:Nemerle.Compiler.FieldBuilder.IsVolatile" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_IsLiteral" />
    <member name="P:Nemerle.Compiler.FieldBuilder.IsLiteral" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_HasBeenAssigned" />
    <member name="M:Nemerle.Compiler.FieldBuilder.set_HasBeenAssigned(System.Boolean)" />
    <member name="P:Nemerle.Compiler.FieldBuilder.HasBeenAssigned" />
    <member name="M:Nemerle.Compiler.FieldBuilder.GetValue" />
    <member name="M:Nemerle.Compiler.FieldBuilder.GetFieldInfo" />
    <member name="M:Nemerle.Compiler.FieldBuilder.GetHandle" />
    <member name="M:Nemerle.Compiler.FieldBuilder.CheckAttributes">
      <summary>
        <para>Performs attributes checks for field definition.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FieldBuilder.get_MacroTarget" />
    <member name="P:Nemerle.Compiler.FieldBuilder.MacroTarget" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_MacroSelfParams" />
    <member name="P:Nemerle.Compiler.FieldBuilder.MacroSelfParams" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_ConstValue" />
    <member name="M:Nemerle.Compiler.FieldBuilder.set_ConstValue(Nemerle.Compiler.Literal)" />
    <member name="P:Nemerle.Compiler.FieldBuilder.ConstValue" />
    <member name="M:Nemerle.Compiler.FieldBuilder.get_InitializerLocation">
      <summary>
        <para>////////////////////////////////////////////////////////////////////////

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.FieldBuilder.InitializerLocation" />
    <member name="M:Nemerle.Compiler.FieldBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.PropertyBuilder" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.Nemerle#Compiler#IProperty#GetPropertyInfo" />
    <member name="M:Nemerle.Compiler.PropertyBuilder._N_process_accessor_71362(Nemerle.Compiler.PropertyBuilder._N_closureOf__ctor_71325,Nemerle.Core.option{Nemerle.Compiler.Parsetree.ClassMember.Function})" />
    <member name="M:Nemerle.Compiler.PropertyBuilder._N_chop_71166(System.Type[][])" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.CreateEmitBuilder(System.Reflection.Emit.TypeBuilder)">
      <summary>
        <para>Adds a property builder

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PropertyBuilder.Compile" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.is_mutable" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.getter" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.setter" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.parms" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.parent_property" />
    <member name="F:Nemerle.Compiler.PropertyBuilder._bodyLocation" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.property_builder" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_Ast" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.Ast">
      <summary>
        <para>Parsed representation (AST) of property.
 Note: available only in CompletionMode
 (if Manager.IsIntelliSenseMode = true)

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.PropertyBuilder.autoPropertyField" />
    <member name="F:Nemerle.Compiler.PropertyBuilder.isAutoProperty" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Property)" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_IsMutable" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.IsMutable" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_IsIndexer" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.IsIndexer" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_MemberKind" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.MemberKind" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.GetPropertyInfo" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_Getter" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.Getter" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_CanRead" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.CanRead" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.GetGetter" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_Setter" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.Setter" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_CanWrite" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.CanWrite" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.GetSetter" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.GetParameters" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.UpdateParentProperty(Nemerle.Compiler.IProperty)" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.GetHandle" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.CheckAttributes">
      <summary>
        <para>Performs attributes checks for properties definitions.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_MacroTarget" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.MacroTarget" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_MacroSelfParams" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.MacroSelfParams" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_BodyLocation" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.BodyLocation" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_AutoPropertyField" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.AutoPropertyField" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.get_IsAutoProperty" />
    <member name="P:Nemerle.Compiler.PropertyBuilder.IsAutoProperty" />
    <member name="M:Nemerle.Compiler.PropertyBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.EventBuilder" />
    <member name="M:Nemerle.Compiler.EventBuilder.Nemerle#Compiler#IEvent#GetRemover" />
    <member name="M:Nemerle.Compiler.EventBuilder.Nemerle#Compiler#IEvent#GetAdder" />
    <member name="M:Nemerle.Compiler.EventBuilder._N_make_method_71641(Nemerle.Compiler.EventBuilder._N_closureOf__ctor_71604,Nemerle.Compiler.Parsetree.ClassMember.Function)" />
    <member name="M:Nemerle.Compiler.EventBuilder._N_update_mfunction_71619(Nemerle.Compiler.EventBuilder._N_closureOf__ctor_71604,Nemerle.Compiler.Parsetree.ClassMember.Function,System.String)" />
    <member name="M:Nemerle.Compiler.EventBuilder.CreateEmitBuilder(System.Reflection.Emit.TypeBuilder)">
      <summary>
        <para>Adds an event builder

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.EventBuilder.Compile" />
    <member name="F:Nemerle.Compiler.EventBuilder.adder" />
    <member name="F:Nemerle.Compiler.EventBuilder.remover" />
    <member name="F:Nemerle.Compiler.EventBuilder.event_builder" />
    <member name="F:Nemerle.Compiler.EventBuilder.storage_field" />
    <member name="M:Nemerle.Compiler.EventBuilder.get_Ast" />
    <member name="P:Nemerle.Compiler.EventBuilder.Ast">
      <summary>
        <para>Parsed representation (AST) of event.
 Note: available only in CompletionMode
 (if Manager.IsIntelliSenseMode = true)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.EventBuilder.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Event)" />
    <member name="M:Nemerle.Compiler.EventBuilder.GetEventInfo" />
    <member name="M:Nemerle.Compiler.EventBuilder.get_MemberKind" />
    <member name="P:Nemerle.Compiler.EventBuilder.MemberKind" />
    <member name="M:Nemerle.Compiler.EventBuilder.GetHandle" />
    <member name="M:Nemerle.Compiler.EventBuilder.GetAdder" />
    <member name="M:Nemerle.Compiler.EventBuilder.GetRemover" />
    <member name="M:Nemerle.Compiler.EventBuilder.CheckAttributes">
      <summary>
        <para>Performs attributes checks for event definition.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.EventBuilder.get_MacroTarget" />
    <member name="P:Nemerle.Compiler.EventBuilder.MacroTarget" />
    <member name="M:Nemerle.Compiler.EventBuilder.get_MacroSelfParams" />
    <member name="P:Nemerle.Compiler.EventBuilder.MacroSelfParams" />
    <member name="M:Nemerle.Compiler.EventBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ILEmitter">
      <summary>
        <para>Generates the IL code for a method or a constructor

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter._N_fail_74456(Nemerle.Compiler.ILEmitter._N_closureOf_emit_value_type_conversion_74444)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_make_labels_74360(Nemerle.Compiler.ILEmitter._N_closureOf_emit_switch_74327,System.Int32,Nemerle.Core.list{Nemerle.Builtins.Tuple{System.Int32,Nemerle.Compiler.Typedtree.TExpr}})" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_emit_debug_74190(Nemerle.Compiler.ILEmitter._N_closureOf_emit_debug_info_74174,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_walk_case_73802(Nemerle.Compiler.ILEmitter._N_closureOf_emit_73286,Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_emit_br_73477(Nemerle.Compiler.ILEmitter._N_closureOf_emit_branch_73466,Nemerle.Compiler.ILEmitter._N_closureOf_emit_73286,System.Reflection.Emit.OpCode,System.Reflection.Emit.OpCode)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_emit_branch_73460(Nemerle.Compiler.ILEmitter._N_closureOf_emit_73286,Nemerle.Compiler.Typedtree.TExpr,System.Reflection.Emit.Label,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_emit_debug_73447(Nemerle.Compiler.ILEmitter._N_closureOf_emit_73286,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_emit_store_73391(Nemerle.Compiler.ILEmitter._N_closureOf_emit_73286,Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_is_single_arg_function_72854(Nemerle.Compiler.ILEmitter._N_closureOf_emit_tuple_function_conversion_72828,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.ILEmitter._N_interesting_part_72836(Nemerle.Compiler.ILEmitter._N_closureOf_emit_tuple_function_conversion_72828,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.ILEmitter.#cctor">
      <summary>
        <para>Generates the IL code for a method or a constructor

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.ILEmitter._N_lockVar_18325" />
    <member name="F:Nemerle.Compiler.ILEmitter._N_cache_18326" />
    <member name="F:Nemerle.Compiler.ILEmitter._module_builder" />
    <member name="F:Nemerle.Compiler.ILEmitter._ilg" />
    <member name="F:Nemerle.Compiler.ILEmitter._parent_type_builder" />
    <member name="F:Nemerle.Compiler.ILEmitter._this_is_value_type" />
    <member name="F:Nemerle.Compiler.ILEmitter._type_of_this" />
    <member name="F:Nemerle.Compiler.ILEmitter._method_name" />
    <member name="F:Nemerle.Compiler.ILEmitter._method_builder" />
    <member name="F:Nemerle.Compiler.ILEmitter._method_start_label" />
    <member name="F:Nemerle.Compiler.ILEmitter._debug_doc" />
    <member name="F:Nemerle.Compiler.ILEmitter._is_ctor" />
    <member name="F:Nemerle.Compiler.ILEmitter._is_lambda" />
    <member name="F:Nemerle.Compiler.ILEmitter._labels" />
    <member name="F:Nemerle.Compiler.ILEmitter._label_usage" />
    <member name="F:Nemerle.Compiler.ILEmitter.MS_NET_RUNTIME_TYPE" />
    <member name="F:Nemerle.Compiler.ILEmitter.MONO_RUNTIME_TYPE" />
    <member name="F:Nemerle.Compiler.ILEmitter.RUNTIME_TYPE" />
    <member name="M:Nemerle.Compiler.ILEmitter.#ctor(Nemerle.Compiler.MethodBuilder)">
      <summary>
        <para>Creates and executes a code generator for a method

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.Run" />
    <member name="M:Nemerle.Compiler.ILEmitter.is_always_true(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.DefineDebugDocument(System.Int32)" />
    <member name="M:Nemerle.Compiler.ILEmitter.SetDocument(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.ILEmitter.is_always_false(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.get_IsDebugEnabled" />
    <member name="P:Nemerle.Compiler.ILEmitter.IsDebugEnabled" />
    <member name="M:Nemerle.Compiler.ILEmitter.maybe_volatile(Nemerle.Compiler.Typedtree.TExpr)">
      <summary>
        <para>Emit volatile prefix if needed.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.need_reference(System.Type)">
      <summary>
        <para>Box the value of type [t] if needed.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.is_void(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.ILEmitter.is_ctor(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetHackishConstructor(System.Type,System.Reflection.ConstructorInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetHackishMethod(System.Type,System.Reflection.MethodInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetHackishField(System.Type,System.Reflection.FieldInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.FrameworkGetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.FrameworkGetMethod(System.Type,System.Reflection.MethodInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.FrameworkGetField(System.Type,System.Reflection.FieldInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetConstructorInfo(System.Type,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetMethodInfo(Nemerle.Compiler.FixedType,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetMethodInfo(Nemerle.Compiler.TypeVar,Nemerle.Compiler.IMethod,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetFieldInfo(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.IField)" />
    <member name="M:Nemerle.Compiler.ILEmitter.GetFieldInfo(System.Type,Nemerle.Compiler.IField)" />
    <member name="M:Nemerle.Compiler.ILEmitter.store_local(Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_parms(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="M:Nemerle.Compiler.ILEmitter.skipped(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.no_cast_needed(System.Type,System.Type)" />
    <member name="M:Nemerle.Compiler.ILEmitter.make_ref_type(System.Type)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_tuple_function_conversion(Nemerle.Compiler.FixedType,Nemerle.Compiler.FixedType,Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.ILEmitter.InversBool">
      <summary>
        <para>If stack contains 1 it plase and on the contrary

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit(Nemerle.Compiler.Typedtree.TExpr)">
      <summary>
        <para>Emits an expression.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_exprs(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_exprs_prepare(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_exprs_push(System.Reflection.Emit.LocalBuilder[],Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_debug_info(Nemerle.Compiler.Typedtree.TExpr.DebugInfo)" />
    <member name="M:Nemerle.Compiler.ILEmitter.array_set_method(System.Type)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_ce_ref(Nemerle.Compiler.LocalValue,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ILEmitter.array_set_method(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.array_get_method(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.array_addr_method(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_switch(Nemerle.Core.option{Nemerle.Compiler.Typedtree.TExpr},Nemerle.Core.list{Nemerle.Builtins.Tuple{System.Int32,Nemerle.Compiler.Typedtree.TExpr}})">
      <summary>
        <para>Emits the TExpr.Switch instruction

</para>
      </summary> <remarks><para>Asserts that the first of the case indices is zero. Quietly
 asserts that the indexer is verified to be in a valid range -- i.e.
 that the rescaling substraction does not overflow and that we never
 generate too long switch instructions -- assuring this should belong
 to a higher level logic.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_ldarg(System.Int32)">
      <summary>
        <para>Emits an LDARG instruction

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.store_argument(System.Int32)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_ldarga(System.Int32)">
      <summary>
        <para>Emits an LDARGA instruction

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_value_type_conversion(Nemerle.Compiler.Location,Nemerle.Compiler.FixedType,Nemerle.Compiler.FixedType,System.Boolean)">
      <summary>
        <para>Performs value type conversion form l to r

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_method_call(Nemerle.Compiler.Typedtree.TExpr,System.Boolean,System.Reflection.MethodInfo,Nemerle.Compiler.IMethod,Nemerle.Compiler.FixedType)">
      <summary>
        <para>Emits a method call.

</para>
      </summary> <remarks><para>If it is a tail call (which is checked based on [expr]), then we emit
 tail modifier.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_and_convert_to_address(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.declare_val_local_slot(Nemerle.Compiler.LocalValue)">
      <summary>
        <para>Declares a local variable

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.declare_val_local_slot_ex(Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.ILEmitter.declare_expr_local_slot(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_array_store_opcode(System.Type)">
      <summary>
        <para>Emits a STELEM instruction for a given type

</para>
      </summary> <remarks><para>NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_value_to_ptr_conversion(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.ILEmitter.get_elem_size(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_index_multiplier(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_index_multiplier(System.Int32)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_ptr_indexing(System.Boolean,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_array_load_opcode(System.Type)">
      <summary>
        <para>Emits a LDELEM instruction for a given type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_ldind_for_value_type(System.Type)">
      <summary>
        <para>Emits a LDIND instruction for a given value type

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.emit_i4(System.Int32)" />
    <member name="M:Nemerle.Compiler.ILEmitter.emit_literal(Nemerle.Compiler.Literal)">
      <summary>
        <para>Emits a literal

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.ILEmitter.Manager">
      <summary>
        <para>Generates the IL code for a method or a constructor

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.get_InternalType" />
    <member name="P:Nemerle.Compiler.ILEmitter.InternalType" />
    <member name="M:Nemerle.Compiler.ILEmitter.get_SystemTypeCache">
      <summary>
        <para>Generates the IL code for a method or a constructor

</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.ILEmitter.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.ILEmitter.__fake">
      <summary>
        <para>Generates the IL code for a method or a constructor

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ILEmitter.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ILEmitter.NemerleGenerator" />
    <member name="T:Nemerle.Compiler.Typer3" />
    <member name="M:Nemerle.Compiler.Typer3._N_walk_case_79208(Nemerle.Compiler.Typer3._N_closureOf_DoSubstExpr_79184,Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.Typer3._N_is_bool_pattern_78768(Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.Typer3._N_plain_call_78554(Nemerle.Compiler.Typer3._N_closureOf_EmitCall_78521)" />
    <member name="M:Nemerle.Compiler.Typer3._N_just_call_78543(Nemerle.Compiler.Typer3._N_closureOf_EmitCall_78521,Nemerle.Compiler.IMethod,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="M:Nemerle.Compiler.Typer3._N_properApply_78371(Nemerle.Compiler.Typer3._N_closureOf_EmitDelegateCtor_78339,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer3._N_addNames_78088(Nemerle.Compiler.Typer3._N_closureOf_addParamNames_78082,Nemerle.Compiler.Parsetree.PExpr,System.Collections.Generic.List{Nemerle.Compiler.Parsetree.Name})" />
    <member name="M:Nemerle.Compiler.Typer3._N_fix_type_78062(Nemerle.Compiler.Typer3._N_closureOf_EmitFunctionalValue_78038,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3._N_we_use_77658(Nemerle.Compiler.Typer3._N_closureOf_ComputeUsedClosures_77648,Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.Typer3._N_ctor_calls_77511(Nemerle.Compiler.Typer3._N_closureOf_FixBaseCall_77296,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3._N_ctor_calls_77468(Nemerle.Compiler.Typer3._N_closureOf_FixBaseCall_77296,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3._N_inject_76985(Nemerle.Compiler.Typer3._N_closureOf_InjectAroundCtor_76977,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3._N_alt_76801(Nemerle.Compiler.Typer3._N_closureOf_CtorCalls_76756,Nemerle.Core.list{Nemerle.Builtins.Tuple{System.Int32,System.Int32}})" />
    <member name="M:Nemerle.Compiler.Typer3._N_acc_76787(Nemerle.Compiler.Typer3._N_closureOf_CtorCalls_76756,Nemerle.Core.list{Nemerle.Builtins.Tuple{System.Int32,System.Int32}})" />
    <member name="M:Nemerle.Compiler.Typer3._N_ctor_calls_76781(Nemerle.Compiler.Typer3._N_closureOf_CtorCalls_76756,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3._N_fix_type_76342(Nemerle.Compiler.Typer3._N_closureOf_PrepareClosure_76327,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3._N_walk_case_76208(Nemerle.Compiler.Typer3._N_closureOf_RewriteTryFinally_76129,Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.Typer3._N_contains_yield_76159(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3._N_fix_type_75840(Nemerle.Compiler.Typer3._N_closureOf_EmitCtorProxy_75822,Nemerle.Compiler.TypeVar)" />
    <member name="F:Nemerle.Compiler.Typer3.top_typer" />
    <member name="M:Nemerle.Compiler.Typer3.get_Redirects" />
    <member name="P:Nemerle.Compiler.Typer3.Redirects" />
    <member name="M:Nemerle.Compiler.Typer3.get_StaticProxies" />
    <member name="P:Nemerle.Compiler.Typer3.StaticProxies" />
    <member name="M:Nemerle.Compiler.Typer3.get_CurrentType" />
    <member name="P:Nemerle.Compiler.Typer3.CurrentType" />
    <member name="F:Nemerle.Compiler.Typer3.local_function_type" />
    <member name="F:Nemerle.Compiler.Typer3.start_label" />
    <member name="F:Nemerle.Compiler.Typer3.parent" />
    <member name="F:Nemerle.Compiler.Typer3.ptyper" />
    <member name="F:Nemerle.Compiler.Typer3.ptyper2" />
    <member name="F:Nemerle.Compiler.Typer3.is_ctor" />
    <member name="F:Nemerle.Compiler.Typer3.is_in_ctor" />
    <member name="F:Nemerle.Compiler.Typer3.the_method" />
    <member name="F:Nemerle.Compiler.Typer3.current_local_fun" />
    <member name="F:Nemerle.Compiler.Typer3.current_method" />
    <member name="F:Nemerle.Compiler.Typer3.current_subst" />
    <member name="F:Nemerle.Compiler.Typer3.current_closure" />
    <member name="F:Nemerle.Compiler.Typer3.closure_fields" />
    <member name="F:Nemerle.Compiler.Typer3.closure_parms" />
    <member name="F:Nemerle.Compiler.Typer3.accumulated_typarms" />
    <member name="M:Nemerle.Compiler.Typer3.#ctor(Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.Typer,Nemerle.Compiler.Typer2)" />
    <member name="M:Nemerle.Compiler.Typer3.#ctor(Nemerle.Compiler.Typer3,Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.Typer,Nemerle.Compiler.Typer2)" />
    <member name="M:Nemerle.Compiler.Typer3.#ctor(Nemerle.Compiler.Typer3,Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.Run" />
    <member name="M:Nemerle.Compiler.Typer3.BuildRevSequence(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.Typer3.SingleMemberLookup(Nemerle.Compiler.TypeInfo,System.String)" />
    <member name="M:Nemerle.Compiler.Typer3.get_IsTopLevelFun" />
    <member name="P:Nemerle.Compiler.Typer3.IsTopLevelFun" />
    <member name="M:Nemerle.Compiler.Typer3.PlainRef(Nemerle.Compiler.LocalValue)">
      <summary>
        <para>Just a shorthand for TExpr.LocalRef.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer3.StaticRef(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.Typer3.CheckedConversion(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3.TupleParms(Nemerle.Compiler.Typedtree.TFunHeader,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm},System.Int32)">
      <summary>
        <para>Given a call with [parms] to [fh] return a list of parameters
        that should be passed along with any initialization code.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer3.WithCached(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.Typer3.IsObject(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3.CopyFunTyparms(System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer3.FunAndClassTyparmsRefs" />
    <member name="M:Nemerle.Compiler.Typer3.FixType(Nemerle.Compiler.TypeVar,Nemerle.Compiler.Subst)" />
    <member name="M:Nemerle.Compiler.Typer3.GetMethodClosure(System.Int32)" />
    <member name="M:Nemerle.Compiler.Typer3.GetClosure(System.Int32)" />
    <member name="M:Nemerle.Compiler.Typer3.ClosureRef(Nemerle.Compiler.Typedtree.TFunHeader)">
      <summary>
        <para>Return code referencing closure of [hd].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer3.LocalRef(Nemerle.Compiler.LocalValue,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitCtorProxy(Nemerle.Compiler.Typedtree.TExpr.ImplicitValueTypeCtor)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitStaticProxy(Nemerle.Compiler.Typedtree.TExpr.StaticRef)" />
    <member name="M:Nemerle.Compiler.Typer3.PrepareClosureParms" />
    <member name="M:Nemerle.Compiler.Typer3.PrepareEnumeratorObject(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3.PrepareEnumerableObject(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3.RewriteTryFinally(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.SetEnumeratorBody(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Subst,Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.Typer3.PrepareClosure" />
    <member name="M:Nemerle.Compiler.Typer3.LoadParameters" />
    <member name="M:Nemerle.Compiler.Typer3.SimpleFlow``1(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.option{``0}},``0,Nemerle.Builtins.Function{Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr},``0},Nemerle.Builtins.Function{Nemerle.Core.list{Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr}},``0})" />
    <member name="M:Nemerle.Compiler.Typer3.IsCtor(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.IsBaseCtor(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.IsThis(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.IsBaseField(Nemerle.Compiler.IField)" />
    <member name="M:Nemerle.Compiler.Typer3.IsBaseMethod(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.Typer3.CtorCalls(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.InjectAroundCtor(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.FixBaseCall(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.PrepareProlog" />
    <member name="M:Nemerle.Compiler.Typer3.ComputeUsedClosures(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.ClosureParmCount(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitStaticLocalFunction(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitStaticLocalFunction(Nemerle.Compiler.Typedtree.TFunHeader,Nemerle.Collections.Queue{Nemerle.Compiler.Typer3})" />
    <member name="M:Nemerle.Compiler.Typer3.IsIdentityFunction(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitIdentityValue(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitFunctionalValue(Nemerle.Compiler.Typedtree.TFunHeader,Nemerle.Collections.Queue{Nemerle.Compiler.Typer3})" />
    <member name="M:Nemerle.Compiler.Typer3.HandleLocalFunctions(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TFunHeader})" />
    <member name="M:Nemerle.Compiler.Typer3.EmitLoop(Nemerle.Compiler.Typedtree.TFunHeader,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="M:Nemerle.Compiler.Typer3.EmitDelegateCtor(Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr.StaticRef,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.EmitCall(Nemerle.Compiler.Location,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm},System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer3.CompileMatch(Nemerle.Compiler.Typedtree.TExpr.Match)" />
    <member name="M:Nemerle.Compiler.Typer3.Walk(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.DoWalk(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.SubstType(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer3.SubstTypes(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Typer3.SubstExpr(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.DoSubstExpr(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer3.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typer3.TopTyper" />
    <member name="T:Nemerle.Compiler.Typer4" />
    <member name="M:Nemerle.Compiler.Typer4._N_walk_case_79942(Nemerle.Compiler.Typer4._N_closureOf_NeedsEmptyStack_79890,Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.Typer4._N_walk_case_79674(Nemerle.Compiler.Typer4._N_closureOf_Throws_79571,Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="F:Nemerle.Compiler.Typer4.current_fun" />
    <member name="F:Nemerle.Compiler.Typer4.current_type" />
    <member name="F:Nemerle.Compiler.Typer4.messenger" />
    <member name="F:Nemerle.Compiler.Typer4.the_method" />
    <member name="F:Nemerle.Compiler.Typer4.is_instance_ctor" />
    <member name="M:Nemerle.Compiler.Typer4.#ctor(Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.Typer4.Run" />
    <member name="M:Nemerle.Compiler.Typer4.NeedBoxing(Nemerle.Compiler.FixedType,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.Box(Nemerle.Compiler.FixedType,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.Convert(Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="F:Nemerle.Compiler.Typer4.goto_targets" />
    <member name="M:Nemerle.Compiler.Typer4.HasJumpTarget(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.NoThrowPlease(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.NoDeepVoid(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer4.Throws(Nemerle.Compiler.Typedtree.TExpr,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer4.NeedsEmptyStack(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.UnShare(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.DoUnShare(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="F:Nemerle.Compiler.Typer4.current_try_block" />
    <member name="F:Nemerle.Compiler.Typer4.label_blocks" />
    <member name="M:Nemerle.Compiler.Typer4.Walk(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.WalkTry(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer4.DoWalk(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="F:Nemerle.Compiler.Typer4.Manager" />
    <member name="M:Nemerle.Compiler.Typer4.get_InternalType" />
    <member name="P:Nemerle.Compiler.Typer4.InternalType" />
    <member name="M:Nemerle.Compiler.Typer4.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.Typer4.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.Typer4.__fake" />
    <member name="M:Nemerle.Compiler.Typer4.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.BuiltinWrapMethod" />
    <member name="F:Nemerle.Compiler.BuiltinWrapMethod._unwrappedMethod" />
    <member name="F:Nemerle.Compiler.BuiltinWrapMethod._parent" />
    <member name="M:Nemerle.Compiler.BuiltinWrapMethod.#ctor(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMethod,Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinWrapMethod.GetHashCode" />
    <member name="M:Nemerle.Compiler.BuiltinWrapMethod.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.BuiltinWrapMethod.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.BuiltinMethod" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.Nemerle#Compiler#IMember#GetMemType" />
    <member name="M:Nemerle.Compiler.BuiltinMethod._N_fp_80610(Nemerle.Compiler.BuiltinMethod._N_closureOf__ctor_80602,System.String,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod._N_fp_80582(Nemerle.Compiler.BuiltinMethod._N_closureOf__ctor_80574,System.String,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod._N_fp_80555(Nemerle.Compiler.BuiltinMethod._N_closureOf__ctor_80547,System.String,Nemerle.Compiler.TypeVar)" />
    <member name="F:Nemerle.Compiler.BuiltinMethod.id" />
    <member name="F:Nemerle.Compiler.BuiltinMethod.header" />
    <member name="F:Nemerle.Compiler.BuiltinMethod.declaring" />
    <member name="F:Nemerle.Compiler.BuiltinMethod.special_kind" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_NameLocation" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.NameLocation" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.#ctor(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.#ctor(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMethod,Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.#ctor(Nemerle.Compiler.TypeInfo,System.String,Nemerle.Compiler.TypeVar,Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.#ctor(Nemerle.Compiler.TypeInfo,System.String,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.#ctor(Nemerle.Compiler.TypeInfo,System.String,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsConstructor" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsConstructor" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetMemType" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_Location" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.Location" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetHashCode" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetHandle" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.CanAccess(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo,System.Boolean)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.CanAccess(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetFreshType" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetHeader" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetParameters" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_ReturnType" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.ReturnType" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetMethodBase" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetMethodInfo" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetConstructorInfo" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsVarArgs" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsVarArgs" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsFinal" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsFinal" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsPrivate" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsPrivate" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsAbstract" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsAbstract" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsObsolete" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsObsolete" />
    <member name="F:Nemerle.Compiler.BuiltinMethod._N_field_is_extension_embeded_in_IsExtension_3448" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsExtension" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.set_IsExtension(System.Boolean)" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsExtension" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_DeclaringType" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.DeclaringType" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_Name" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.Name" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_MemberKind" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.MemberKind" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsStatic" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsStatic" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_Attributes" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.Attributes" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_IsConditional" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.IsConditional" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetConditions" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.GetModifiers" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.IsCustomAttributeDefined(System.String)" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_BuiltinKind" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.BuiltinKind" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.ToString" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.get_Header" />
    <member name="P:Nemerle.Compiler.BuiltinMethod.Header" />
    <member name="M:Nemerle.Compiler.BuiltinMethod.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.RefTo" />
    <member name="M:Nemerle.Compiler.RefTo.#ctor" />
    <member name="M:Nemerle.Compiler.RefTo._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.RefTo._N_GetVariantCodeSafe(Nemerle.Compiler.RefTo)" />
    <member name="M:Nemerle.Compiler.RefTo._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.RefTo.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.RefTo.None" />
    <member name="T:Nemerle.Compiler.RefTo.Method" />
    <member name="T:Nemerle.Compiler.RefTo.Methods" />
    <member name="T:Nemerle.Compiler.RefTo.Type" />
    <member name="T:Nemerle.Compiler.RefTo.Types" />
    <member name="T:Nemerle.Compiler.MemberBuilder" />
    <member name="M:Nemerle.Compiler.MemberBuilder.Nemerle#Compiler#IMember#get_DeclaringType" />
    <member name="M:Nemerle.Compiler.MemberBuilder._N_makeGetSet_68432(System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MemberBuilder._N_add_68424(System.String,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MemberBuilder._N_makeTypeName_68419(System.Type)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.GetConditions" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsConditional" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsStatic" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsPrivate" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsObsolete" />
    <member name="M:Nemerle.Compiler.MemberBuilder.CanAccess(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsConstructor" />
    <member name="F:Nemerle.Compiler.MemberBuilder._related">
      <summary>
        <para>Позволяет указать средствам интеллисенса, что данный член ссылается на
 некий (другой) метод. Этот метод может содержать код сгенерированный
 на основе кода члена содержащего данную ссылку.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.MemberBuilder.loc" />
    <member name="F:Nemerle.Compiler.MemberBuilder.name" />
    <member name="F:Nemerle.Compiler.MemberBuilder.accessibility" />
    <member name="F:Nemerle.Compiler.MemberBuilder.modifiers" />
    <member name="F:Nemerle.Compiler.MemberBuilder.declaring_type" />
    <member name="F:Nemerle.Compiler.MemberBuilder.id" />
    <member name="F:Nemerle.Compiler.MemberBuilder.ty" />
    <member name="F:Nemerle.Compiler.MemberBuilder.handle" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Attributes" />
    <member name="M:Nemerle.Compiler.MemberBuilder.set_Attributes(Nemerle.Compiler.NemerleModifiers)" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Attributes" />
    <member name="F:Nemerle.Compiler.MemberBuilder._ast" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsGenerated" />
    <member name="P:Nemerle.Compiler.MemberBuilder.IsGenerated" />
    <member name="F:Nemerle.Compiler.MemberBuilder.m_has_been_used" />
    <member name="F:Nemerle.Compiler.MemberBuilder.required_modifiers" />
    <member name="F:Nemerle.Compiler.MemberBuilder.optional_modifiers" />
    <member name="F:Nemerle.Compiler.MemberBuilder.Env" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_NameLocation" />
    <member name="P:Nemerle.Compiler.MemberBuilder.NameLocation" />
    <member name="M:Nemerle.Compiler.MemberBuilder.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.ResetCodeCache" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_BodyLocation" />
    <member name="P:Nemerle.Compiler.MemberBuilder.BodyLocation" />
    <member name="M:Nemerle.Compiler.MemberBuilder.CanAccess(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_OverloadName" />
    <member name="P:Nemerle.Compiler.MemberBuilder.OverloadName" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_MemberKind" />
    <member name="P:Nemerle.Compiler.MemberBuilder.MemberKind" />
    <member name="M:Nemerle.Compiler.MemberBuilder.GetMemType" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_GlobalEnv" />
    <member name="P:Nemerle.Compiler.MemberBuilder.GlobalEnv" />
    <member name="M:Nemerle.Compiler.MemberBuilder.Equals(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Location" />
    <member name="M:Nemerle.Compiler.MemberBuilder.set_Location(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Location" />
    <member name="M:Nemerle.Compiler.MemberBuilder.GetModifiers" />
    <member name="M:Nemerle.Compiler.MemberBuilder.IsCustomAttributeDefined(System.String)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.MemberBuilder.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.MemberBuilder.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.MemberBuilder.SetInstanceUsed" />
    <member name="M:Nemerle.Compiler.MemberBuilder.GetHashCode" />
    <member name="M:Nemerle.Compiler.MemberBuilder.GetHandle" />
    <member name="M:Nemerle.Compiler.MemberBuilder.MarkWithSpecialName" />
    <member name="M:Nemerle.Compiler.MemberBuilder.count_access(Nemerle.Compiler.NemerleModifiers)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.UpdateEmbeddedModifiers(Nemerle.Compiler.NemerleModifiers,Nemerle.Compiler.NemerleModifiers@)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.ToString" />
    <member name="M:Nemerle.Compiler.MemberBuilder.DescribeMember(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.CheckAttributes" />
    <member name="M:Nemerle.Compiler.MemberBuilder.check_for_invalid_attr(Nemerle.Compiler.NemerleModifiers,System.String)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.check_method_like_attributes(System.String,System.String)">
      <summary>
        <para>Performs the attributes checks that are common to methods and properties

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MemberBuilder.get_MacroTarget" />
    <member name="P:Nemerle.Compiler.MemberBuilder.MacroTarget" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_MacroSelfParams" />
    <member name="P:Nemerle.Compiler.MemberBuilder.MacroSelfParams" />
    <member name="M:Nemerle.Compiler.MemberBuilder.AddMacroAttribute(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.ProcessMacroAttributes" />
    <member name="M:Nemerle.Compiler.MemberBuilder.CreateEmitBuilder(System.Reflection.Emit.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.Compile" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_IsBodyless" />
    <member name="P:Nemerle.Compiler.MemberBuilder.IsBodyless" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Manager" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Manager" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_InternalType" />
    <member name="P:Nemerle.Compiler.MemberBuilder.InternalType" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.MemberBuilder.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.MemberBuilder.__fake" />
    <member name="M:Nemerle.Compiler.MemberBuilder.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Related">
      <summary>
        <para>Позволяет указать средствам интеллисенса, что данный член ссылается на
 некий (другой) метод. Этот метод может содержать код сгенерированный
 на основе кода члена содержащего данную ссылку.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MemberBuilder.set_Related(Nemerle.Compiler.RefTo)" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Related" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Name" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Name" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Modifiers" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Modifiers" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_DeclaringType" />
    <member name="P:Nemerle.Compiler.MemberBuilder.DeclaringType" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_Ast" />
    <member name="P:Nemerle.Compiler.MemberBuilder.Ast" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_RequiredModifiers" />
    <member name="M:Nemerle.Compiler.MemberBuilder.set_RequiredModifiers(Nemerle.Core.list{System.Type})" />
    <member name="P:Nemerle.Compiler.MemberBuilder.RequiredModifiers" />
    <member name="M:Nemerle.Compiler.MemberBuilder.get_OptionalModifiers" />
    <member name="M:Nemerle.Compiler.MemberBuilder.set_OptionalModifiers(Nemerle.Core.list{System.Type})" />
    <member name="P:Nemerle.Compiler.MemberBuilder.OptionalModifiers" />
    <member name="M:Nemerle.Compiler.MemberBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.AttributeCompilerClass" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass._N_problem_81901(Nemerle.Compiler.AttributeCompilerClass._N_closureOf_pre_compile_81878)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass._N_convert_81772(Nemerle.Compiler.AttributeCompilerClass._N_closureOf_compile_expr_81727,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass._N_compile_type_81737(Nemerle.Compiler.AttributeCompilerClass._N_closureOf_compile_expr_81727,Nemerle.Compiler.Location,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass._N_getErrorLocation_81633(Nemerle.Compiler.AttributeCompilerClass._N_closureOf_CheckConditional_81623)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass._N_is_attribute_80993(Nemerle.Compiler.AttributeCompilerClass._N_closureOf_ResolveAttribute_80957,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass._N_add_end_80967(Nemerle.Compiler.AttributeCompilerClass._N_closureOf_ResolveAttribute_80957,Nemerle.Core.list{System.String},System.String)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.CompileAttribute(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.ResolveAttribute(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.CheckAttribute(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.GetCompiledAssemblyAttributes(System.Collections.Generic.List{Nemerle.Builtins.Tuple{Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr}})" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.GetPermissionSets(System.Collections.Generic.IEnumerable{Nemerle.Builtins.Tuple{Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr}})" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.GetPermissionSets(Nemerle.Compiler.GlobalEnv,System.Collections.Generic.IEnumerable{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.MakeEmittedAttribute(System.Type,System.String)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.MakeEmittedAttribute(System.Type)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.MakeEmittedAttribute(System.Type,System.Int32)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.MakeEmittedAttribute(System.Type,System.Type[],System.Object)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.CheckPInvoking(Nemerle.Compiler.MethodBuilder,System.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes,System.Type[])" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.CheckConditional(Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.is_security_attribute(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.compile_expr(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Typer,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.pre_compile(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.do_compile(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.create_instance(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="F:Nemerle.Compiler.AttributeCompilerClass.Manager" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.get_InternalType" />
    <member name="P:Nemerle.Compiler.AttributeCompilerClass.InternalType" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.AttributeCompilerClass.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.__fake" />
    <member name="M:Nemerle.Compiler.AttributeCompilerClass.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Delegates" />
    <member name="M:Nemerle.Compiler.Delegates.GenerateDelegateClass(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Parsetree.PFunHeader)">
      <summary>
        <para>Generates a delegate class

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Delegates.create_begin_invoke_parms(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="T:Nemerle.Compiler.GlobalEnv" />
    <member name="M:Nemerle.Compiler.GlobalEnv._N_lookup_members_82774(Nemerle.Compiler.GlobalEnv._N_closureOf_LookupSymbolExt_82707,Nemerle.Compiler.NamespaceTree.Node,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMember}})" />
    <member name="M:Nemerle.Compiler.GlobalEnv._N_add_members_from_82729(Nemerle.Compiler.GlobalEnv._N_closureOf_LookupSymbolExt_82707,Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo},Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMember}})" />
    <member name="M:Nemerle.Compiler.GlobalEnv._N_check_access_82527(Nemerle.Compiler.GlobalEnv._N_closureOf_LookupType_82489,Nemerle.Core.option{Nemerle.Compiler.TypeInfo})" />
    <member name="M:Nemerle.Compiler.GlobalEnv._N_non_public_external_82511(Nemerle.Compiler.GlobalEnv._N_closureOf_LookupType_82489,Nemerle.Compiler.TypeInfo)" />
    <member name="F:Nemerle.Compiler.GlobalEnv.open_namespaces" />
    <member name="F:Nemerle.Compiler.GlobalEnv.current_namespace" />
    <member name="F:Nemerle.Compiler.GlobalEnv.namespace_aliases" />
    <member name="F:Nemerle.Compiler.GlobalEnv.macro_ctx_cache" />
    <member name="F:Nemerle.Compiler.GlobalEnv.SyntaxKeywords">
      <summary>
        <para>this is a map of keywords, which trigger syntax extensions

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.GlobalEnv.Keywords">
      <summary>
        <para>this is a set of keywords present in current global environment

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.GlobalEnv.UnaryOperators" />
    <member name="F:Nemerle.Compiler.GlobalEnv.Operators" />
    <member name="F:Nemerle.Compiler.GlobalEnv.Defines" />
    <member name="F:Nemerle.Compiler.GlobalEnv.nameTree" />
    <member name="M:Nemerle.Compiler.GlobalEnv.CreateCore(Nemerle.Compiler.NamespaceTree)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.#ctor(Nemerle.Compiler.GlobalEnv,Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.#ctor(Nemerle.Compiler.NamespaceTree)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.#ctor(Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node},Nemerle.Compiler.NamespaceTree.Node,Nemerle.Core.list{Nemerle.Builtins.Tuple{System.String,System.String}},Nemerle.Collections.Map{System.String,Nemerle.Compiler.GrammarElement},Nemerle.Collections.Set{System.String},Nemerle.Collections.Map{System.String,Nemerle.Compiler.MainParser.OperatorInfo},Nemerle.Collections.Map{System.String,Nemerle.Compiler.MainParser.OperatorInfo},Nemerle.Compiler.NamespaceTree,Nemerle.Collections.Map{System.String,System.Boolean})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.IsKeyword(System.String)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.FetchOperator(System.String)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.HasUnaryOperator(System.String)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.HasOperator(System.String)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupUnaryOperator(System.String)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupOperator(System.String)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.CreateExtended(Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node},Nemerle.Compiler.NamespaceTree.Node,Nemerle.Core.list{Nemerle.Builtins.Tuple{System.String,System.String}},Nemerle.Core.list{Nemerle.Core.list{Nemerle.Compiler.SyntaxDefinition}})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.Define(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.Define(Nemerle.Compiler.Parsetree.ClassMember,System.Boolean)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.GetType(Nemerle.Core.list{System.String},Nemerle.Compiler.TypeBuilder,System.Int32)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupType(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupMacro(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.BindType(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.BindFixedType(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.SymbolExists(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupType(Nemerle.Core.list{System.String},Nemerle.Compiler.TypeBuilder,System.Int32)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupSymbol(Nemerle.Core.list{System.String},Nemerle.Compiler.TypeBuilder,System.Boolean)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.LookupSymbolExt(Nemerle.Core.list{System.String},Nemerle.Compiler.TypeBuilder,System.Boolean)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.get_CurrentNamespace" />
    <member name="P:Nemerle.Compiler.GlobalEnv.CurrentNamespace" />
    <member name="M:Nemerle.Compiler.GlobalEnv.AddOpenNamespace(Nemerle.Core.list{System.String},Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.AddOpenNamespace(Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node},Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.AddNamespaceAlias(System.String,Nemerle.Core.list{System.String},Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.SetDefines(Nemerle.Collections.Map{System.String,System.Boolean})" />
    <member name="M:Nemerle.Compiler.GlobalEnv.IsOpenNamespace(Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.EnterIntoNamespace(Nemerle.Core.list{System.String})">
      <summary>
        <para>qid - relative (from current namespace) path to namespace node
 Note: Use  Manager.CoreEnv to open namespace frome root.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.GlobalEnv.EnterIntoNamespace(Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.GlobalEnv.add_open_nodes(Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node},Nemerle.Core.list{Nemerle.Compiler.NamespaceTree.Node},Nemerle.Compiler.Location,System.Boolean)">
      <summary>
        <para>this is the auxiliary function for making set of opened namespaces
        unique and warn if namespaces are opened multiple times by user

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.GlobalEnv.add_alias_nodes(System.String,Nemerle.Core.list{System.String})">
      <summary>
        <para>We substitute
        using Y = X.Z;
        by
        _tmp1.Y.pointed_by_X_Z // for each part in current namespace
        using _tmp1;

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.GlobalEnv.#ctor(System.String,Nemerle.Compiler.ManagerClass)">
      <summary>
        <para>Creates environment described by given string encoded for purpose of storing macro contexts

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.GlobalEnv.GetMacroContext" />
    <member name="M:Nemerle.Compiler.GlobalEnv.ToString" />
    <member name="F:Nemerle.Compiler.GlobalEnv.Manager" />
    <member name="M:Nemerle.Compiler.GlobalEnv.get_InternalType" />
    <member name="P:Nemerle.Compiler.GlobalEnv.InternalType" />
    <member name="M:Nemerle.Compiler.GlobalEnv.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.GlobalEnv.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.GlobalEnv.__fake" />
    <member name="M:Nemerle.Compiler.GlobalEnv.get_OpenNamespaces" />
    <member name="P:Nemerle.Compiler.GlobalEnv.OpenNamespaces" />
    <member name="M:Nemerle.Compiler.GlobalEnv.get_NamespaceAliases" />
    <member name="P:Nemerle.Compiler.GlobalEnv.NamespaceAliases" />
    <member name="M:Nemerle.Compiler.GlobalEnv.get_NameTree" />
    <member name="P:Nemerle.Compiler.GlobalEnv.NameTree" />
    <member name="M:Nemerle.Compiler.GlobalEnv.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.IMacro">
      <summary>
        <para>Interface, which will be implemented by class encapsulating macro
      function. It will allow dynamic execution of macro by compiler
      itself

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.IMacro.GetName" />
    <member name="M:Nemerle.Compiler.IMacro.GetNamespace" />
    <member name="M:Nemerle.Compiler.IMacro.Run(Nemerle.Compiler.Typer,Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement})" />
    <member name="M:Nemerle.Compiler.IMacro.CallTransform(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.IMacro.SyntaxExtension" />
    <member name="M:Nemerle.Compiler.IMacro.get_IsTailRecursionTransparent" />
    <member name="P:Nemerle.Compiler.IMacro.IsTailRecursionTransparent" />
    <member name="M:Nemerle.Compiler.IMacro.get_IsInherited" />
    <member name="P:Nemerle.Compiler.IMacro.IsInherited" />
    <member name="M:Nemerle.Compiler.IMacro.get_Keywords" />
    <member name="P:Nemerle.Compiler.IMacro.Keywords" />
    <member name="M:Nemerle.Compiler.IMacro.get_Usage" />
    <member name="P:Nemerle.Compiler.IMacro.Usage" />
    <member name="M:Nemerle.Compiler.IMacro.get_Location" />
    <member name="P:Nemerle.Compiler.IMacro.Location" />
    <member name="T:Nemerle.Compiler.MacroParm" />
    <member name="F:Nemerle.Compiler.MacroParm.value__" />
    <member name="F:Nemerle.Compiler.MacroParm.Expr" />
    <member name="F:Nemerle.Compiler.MacroParm.Exprs" />
    <member name="F:Nemerle.Compiler.MacroParm.Implicit" />
    <member name="T:Nemerle.Compiler.MacroClasses">
      <summary>
        <para>GENERATION OF MACRO CLASSES SECTION

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MacroClasses._N_create_transform_tree_84019(Nemerle.Compiler.MacroClasses._N_closureOf_GenerateMacroClass_83551,Nemerle.Core.list{Nemerle.Compiler.MacroParm})" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_makeRuleStr_83933(Nemerle.Compiler.MacroClasses._N_closureOf_makeGrammarString_83831,Nemerle.Compiler.Parsetree.PExpr,System.Text.StringBuilder)" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_makeParamType_83866(Nemerle.Compiler.Parsetree.PParameter)" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_makeParamDefaultValues_83838(Nemerle.Compiler.Parsetree.PParameter)" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_message_83701(Nemerle.Compiler.MacroClasses._N_closureOf_GenerateMacroClass_83551,Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_traverse_patterns_83683(Nemerle.Compiler.MacroClasses._N_closureOf_GenerateMacroClass_83551,Nemerle.Core.list{Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr}},Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr}},Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr}},Nemerle.Core.Cons[T]{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Core.Cons[T]{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_normal_parm_83644(Nemerle.Compiler.MacroClasses._N_closureOf_GenerateMacroClass_83551,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_roll_expr_83635(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr}},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_roll_83627(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MacroClasses._N_set_target_info_83596(Nemerle.Compiler.MacroClasses._N_closureOf_GenerateMacroClass_83551,System.Int32,System.Int32,System.String,System.String)" />
    <member name="M:Nemerle.Compiler.MacroClasses.GenerateMacroClass(Nemerle.Compiler.ManagerClass,Nemerle.Compiler.Parsetree.TopDeclaration.Macro,Nemerle.Compiler.NamespaceTree.Node)">
      <summary>
        <para>Generate class implementing interface [MacroRegistry.IMacro], which
        encapsulates execution of macro. Created methods are:
        [Run] for running macro,
        [GetName] for retrieving its name,
        [GetNamespace] for retrieving macro's definition site (namespace)
        [SyntaxExtension] for retrieving syntax extension it defines,
        [CallTransform] for transforming supported call parameters to
          description taken by [Run] method

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MacroClasses.convert_to_valid_type_name(System.String)" />
    <member name="M:Nemerle.Compiler.MacroClasses.lift_ge(Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.MacroClasses.analyze_syntax(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Collections.Map{System.String,Nemerle.Builtins.Tuple{System.Int32,Nemerle.Compiler.Parsetree.PExpr}})" />
    <member name="M:Nemerle.Compiler.MacroClasses.CreatePermutingFunction(Nemerle.Core.list{System.Int32})" />
    <member name="T:Nemerle.Compiler.NamespaceTree" />
    <member name="M:Nemerle.Compiler.NamespaceTree._N_resetChildren_84273(Nemerle.Compiler.NamespaceTree._N_closureOf_ResetAllTypes_84267,Nemerle.Collections.Hashtable{System.String,Nemerle.Compiler.NamespaceTree.Node})" />
    <member name="F:Nemerle.Compiler.NamespaceTree.macro_context" />
    <member name="F:Nemerle.Compiler.NamespaceTree.macro_contexts" />
    <member name="F:Nemerle.Compiler.NamespaceTree.macro_context_class" />
    <member name="F:Nemerle.Compiler.NamespaceTree.namespace_tree" />
    <member name="F:Nemerle.Compiler.NamespaceTree.referenced_namespace_nodes" />
    <member name="M:Nemerle.Compiler.NamespaceTree.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.Init" />
    <member name="M:Nemerle.Compiler.NamespaceTree.ResetAllTypes" />
    <member name="M:Nemerle.Compiler.NamespaceTree.AddType(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.NamespaceTree.Node,Nemerle.Compiler.Parsetree.TopDeclaration)">
      <summary>
        <para>Function for adding type to namespace tree.

</para>
      </summary>        <remarks><para>It checks if given
        class is already in namespace tree and if it is and has `partial' modifier
        it add members to existing type instead of creating new TypeBuilder.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.NamespaceTree.AddMacro(Nemerle.Core.list{System.String},Nemerle.Compiler.IMacro)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.AddMacro(Nemerle.Compiler.NamespaceTree.Node,Nemerle.Compiler.IMacro)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupInternalType(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupInternalType(Nemerle.Core.list{System.String},System.Int32)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupExactType(System.String)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupExactType(System.String,System.Int32)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupExactType(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupExactType(Nemerle.Core.list{System.String},System.Int32)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupSystemType(System.String)" />
    <member name="M:Nemerle.Compiler.NamespaceTree.ExactPath(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LookupExactMacro(Nemerle.Core.list{System.String})" />
    <member name="M:Nemerle.Compiler.NamespaceTree.CheckReferencedNamespaces" />
    <member name="M:Nemerle.Compiler.NamespaceTree.LiftMacroContexts" />
    <member name="M:Nemerle.Compiler.NamespaceTree.prepare_macro_context_class" />
    <member name="M:Nemerle.Compiler.NamespaceTree.FinishMacroContextClass" />
    <member name="F:Nemerle.Compiler.NamespaceTree.Manager" />
    <member name="M:Nemerle.Compiler.NamespaceTree.get_InternalType" />
    <member name="P:Nemerle.Compiler.NamespaceTree.InternalType" />
    <member name="M:Nemerle.Compiler.NamespaceTree.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.NamespaceTree.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.NamespaceTree.__fake" />
    <member name="M:Nemerle.Compiler.NamespaceTree.get_NamespaceTree" />
    <member name="P:Nemerle.Compiler.NamespaceTree.NamespaceTree" />
    <member name="M:Nemerle.Compiler.NamespaceTree.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.NamespaceTree.TypeInfoCache" />
    <member name="T:Nemerle.Compiler.NamespaceTree.Node" />
    <member name="T:Nemerle.Compiler.ScanTypeHierarchy" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy._N_handle_type_85475(Nemerle.Compiler.ScanTypeHierarchy._N_closureOf_ProcessDeclaration_85465,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.NamespaceTree.Node,Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy.ProcessDeclaration(Nemerle.Compiler.Parsetree.TopDeclaration)">
      <summary>
        <para>Process toplevel type declaration.

</para>
      </summary>        <remarks><para>This function does the very first pass, after parsing.
        It creates [TypeBuilder] object for each type and registers it
        in namespace hierarchy.
        It also creates classes of delegates and macros.

</para>        <para>This module is stateless.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.ScanTypeHierarchy.Manager" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy.get_InternalType" />
    <member name="P:Nemerle.Compiler.ScanTypeHierarchy.InternalType" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.ScanTypeHierarchy.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy.__fake" />
    <member name="M:Nemerle.Compiler.ScanTypeHierarchy.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.NameToMethodsMap" />
    <member name="T:Nemerle.Compiler.IfaceMethod" />
    <member name="T:Nemerle.Compiler.IfaceMethods" />
    <member name="T:Nemerle.Compiler.MemberKinds" />
    <member name="T:Nemerle.Compiler.BindingFlags" />
    <member name="T:Nemerle.Compiler.Accessibility" />
    <member name="F:Nemerle.Compiler.Accessibility.value__" />
    <member name="F:Nemerle.Compiler.Accessibility.Public" />
    <member name="F:Nemerle.Compiler.Accessibility.Internal" />
    <member name="F:Nemerle.Compiler.Accessibility.ProtectedOrInternal" />
    <member name="F:Nemerle.Compiler.Accessibility.ProtectedAndInternal" />
    <member name="F:Nemerle.Compiler.Accessibility.Protected" />
    <member name="F:Nemerle.Compiler.Accessibility.Private" />
    <member name="T:Nemerle.Compiler.BuiltinMethodKind" />
    <member name="M:Nemerle.Compiler.BuiltinMethodKind.#ctor" />
    <member name="M:Nemerle.Compiler.BuiltinMethodKind._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.BuiltinMethodKind._N_GetVariantCodeSafe(Nemerle.Compiler.BuiltinMethodKind)" />
    <member name="M:Nemerle.Compiler.BuiltinMethodKind._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.BuiltinMethodKind.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.BuiltinMethodKind.NotBuiltin" />
    <member name="T:Nemerle.Compiler.BuiltinMethodKind.OpCode" />
    <member name="T:Nemerle.Compiler.BuiltinMethodKind.CallWithCast" />
    <member name="T:Nemerle.Compiler.BuiltinMethodKind.ValueTypeConversion" />
    <member name="T:Nemerle.Compiler.BuiltinMethodKind.ExtensionMethod" />
    <member name="T:Nemerle.Compiler.IMember" />
    <member name="M:Nemerle.Compiler.IMember.get_IsConstructor" />
    <member name="P:Nemerle.Compiler.IMember.IsConstructor" />
    <member name="M:Nemerle.Compiler.IMember.GetMemType" />
    <member name="M:Nemerle.Compiler.IMember.get_Location" />
    <member name="P:Nemerle.Compiler.IMember.Location" />
    <member name="M:Nemerle.Compiler.IMember.GetHandle" />
    <member name="M:Nemerle.Compiler.IMember.CanAccess(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.IMember.CanAccess(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo,System.Boolean)" />
    <member name="M:Nemerle.Compiler.IMember.get_IsObsolete" />
    <member name="P:Nemerle.Compiler.IMember.IsObsolete" />
    <member name="M:Nemerle.Compiler.IMember.get_IsPrivate" />
    <member name="P:Nemerle.Compiler.IMember.IsPrivate" />
    <member name="M:Nemerle.Compiler.IMember.get_DeclaringType" />
    <member name="P:Nemerle.Compiler.IMember.DeclaringType" />
    <member name="M:Nemerle.Compiler.IMember.get_Name" />
    <member name="P:Nemerle.Compiler.IMember.Name" />
    <member name="M:Nemerle.Compiler.IMember.get_NameLocation" />
    <member name="P:Nemerle.Compiler.IMember.NameLocation" />
    <member name="M:Nemerle.Compiler.IMember.get_MemberKind" />
    <member name="P:Nemerle.Compiler.IMember.MemberKind" />
    <member name="M:Nemerle.Compiler.IMember.get_IsStatic" />
    <member name="P:Nemerle.Compiler.IMember.IsStatic" />
    <member name="M:Nemerle.Compiler.IMember.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.IMember.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.IMember.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.IMember.get_IsConditional" />
    <member name="P:Nemerle.Compiler.IMember.IsConditional" />
    <member name="M:Nemerle.Compiler.IMember.GetConditions" />
    <member name="M:Nemerle.Compiler.IMember.get_Attributes" />
    <member name="P:Nemerle.Compiler.IMember.Attributes" />
    <member name="M:Nemerle.Compiler.IMember.GetModifiers" />
    <member name="M:Nemerle.Compiler.IMember.IsCustomAttributeDefined(System.String)" />
    <member name="T:Nemerle.Compiler.IField" />
    <member name="M:Nemerle.Compiler.IField.get_IsMutable" />
    <member name="P:Nemerle.Compiler.IField.IsMutable" />
    <member name="M:Nemerle.Compiler.IField.get_IsVolatile" />
    <member name="P:Nemerle.Compiler.IField.IsVolatile" />
    <member name="M:Nemerle.Compiler.IField.get_IsLiteral" />
    <member name="P:Nemerle.Compiler.IField.IsLiteral" />
    <member name="M:Nemerle.Compiler.IField.GetValue" />
    <member name="M:Nemerle.Compiler.IField.GetFieldInfo" />
    <member name="M:Nemerle.Compiler.IField.get_HasBeenAssigned" />
    <member name="M:Nemerle.Compiler.IField.set_HasBeenAssigned(System.Boolean)" />
    <member name="P:Nemerle.Compiler.IField.HasBeenAssigned" />
    <member name="T:Nemerle.Compiler.IEvent" />
    <member name="M:Nemerle.Compiler.IEvent.GetEventInfo" />
    <member name="M:Nemerle.Compiler.IEvent.GetAdder" />
    <member name="M:Nemerle.Compiler.IEvent.GetRemover" />
    <member name="T:Nemerle.Compiler.IMethod" />
    <member name="M:Nemerle.Compiler.IMethod.GetFreshType" />
    <member name="M:Nemerle.Compiler.IMethod.get_Header" />
    <member name="P:Nemerle.Compiler.IMethod.Header" />
    <member name="M:Nemerle.Compiler.IMethod.GetHeader" />
    <member name="M:Nemerle.Compiler.IMethod.GetMethodBase" />
    <member name="M:Nemerle.Compiler.IMethod.GetMethodInfo" />
    <member name="M:Nemerle.Compiler.IMethod.GetConstructorInfo" />
    <member name="M:Nemerle.Compiler.IMethod.get_IsVarArgs" />
    <member name="P:Nemerle.Compiler.IMethod.IsVarArgs" />
    <member name="M:Nemerle.Compiler.IMethod.get_IsFinal" />
    <member name="P:Nemerle.Compiler.IMethod.IsFinal" />
    <member name="M:Nemerle.Compiler.IMethod.get_IsAbstract" />
    <member name="P:Nemerle.Compiler.IMethod.IsAbstract" />
    <member name="M:Nemerle.Compiler.IMethod.get_IsExtension" />
    <member name="P:Nemerle.Compiler.IMethod.IsExtension" />
    <member name="M:Nemerle.Compiler.IMethod.get_BuiltinKind" />
    <member name="P:Nemerle.Compiler.IMethod.BuiltinKind" />
    <member name="M:Nemerle.Compiler.IMethod.GetMemType" />
    <member name="M:Nemerle.Compiler.IMethod.GetParameters">
      <summary>
        <para>Obtains list of parameters of typed method

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.IMethod.get_ReturnType" />
    <member name="P:Nemerle.Compiler.IMethod.ReturnType">
      <summary>
        <para>Obtain return type of typed method. If it is already inferred/fixed
 the value is one of FixedType variant options.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.IProperty" />
    <member name="M:Nemerle.Compiler.IProperty.get_IsIndexer" />
    <member name="P:Nemerle.Compiler.IProperty.IsIndexer" />
    <member name="M:Nemerle.Compiler.IProperty.get_IsMutable" />
    <member name="P:Nemerle.Compiler.IProperty.IsMutable" />
    <member name="M:Nemerle.Compiler.IProperty.GetPropertyInfo" />
    <member name="M:Nemerle.Compiler.IProperty.GetGetter" />
    <member name="M:Nemerle.Compiler.IProperty.GetSetter" />
    <member name="T:Nemerle.Compiler.MemberInfo" />
    <member name="M:Nemerle.Compiler.MemberInfo.#ctor" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsConstructor" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsConstructor" />
    <member name="F:Nemerle.Compiler.MemberInfo.is_obsolete" />
    <member name="F:Nemerle.Compiler.MemberInfo.attributes" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsStatic" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsStatic" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsPublic" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsPublic" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsPrivate" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsPrivate" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsProtected" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsProtected" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsInternal" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsInternal" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsAbstract" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsAbstract" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.MemberInfo.set_HasBeenUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.MemberInfo.HasBeenUsed" />
    <member name="M:Nemerle.Compiler.MemberInfo.GetModifiers" />
    <member name="M:Nemerle.Compiler.MemberInfo.IsCustomAttributeDefined(System.String)" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_GlobalEnv" />
    <member name="P:Nemerle.Compiler.MemberInfo.GlobalEnv" />
    <member name="M:Nemerle.Compiler.MemberInfo.GetObsoletionDetails" />
    <member name="M:Nemerle.Compiler.MemberInfo.CanAccess(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo,System.Boolean)" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsConditional" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsConditional" />
    <member name="M:Nemerle.Compiler.MemberInfo.GetConditions" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_IsObsolete" />
    <member name="P:Nemerle.Compiler.MemberInfo.IsObsolete" />
    <member name="M:Nemerle.Compiler.MemberInfo.get_Attributes" />
    <member name="P:Nemerle.Compiler.MemberInfo.Attributes" />
    <member name="M:Nemerle.Compiler.MemberInfo.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.TypeInfo" />
    <member name="M:Nemerle.Compiler.TypeInfo.Nemerle#Compiler#IMember#GetMemType">
      <summary>
        <para>If this type was defined as [class Foo ('a, 'b) { ... }] then return
 type expression [Foo ('a, 'b)].

</para>
      </summary> <remarks><para>Used mainly with [FreshSubst ()] or [MakeSubst ()].

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeInfo._N_getGenericParamCount_54995(Nemerle.Compiler.IMember)">
      <summary>
        <para>workaround since generic parameters are not coming via signature

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.IsCustomAttributeDefined(System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetModifiers" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Attributes" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetConditions" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsConditional" />
    <member name="M:Nemerle.Compiler.TypeInfo.set_HasBeenUsed(System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_HasBeenUsed" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsPrivate" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsObsolete" />
    <member name="M:Nemerle.Compiler.TypeInfo.CanAccess(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsConstructor" />
    <member name="F:Nemerle.Compiler.TypeInfo.system_type" />
    <member name="F:Nemerle.Compiler.TypeInfo.id" />
    <member name="F:Nemerle.Compiler.TypeInfo.default_indexer" />
    <member name="F:Nemerle.Compiler.TypeInfo.typarms" />
    <member name="F:Nemerle.Compiler.TypeInfo.self_type" />
    <member name="F:Nemerle.Compiler.TypeInfo.fullname" />
    <member name="F:Nemerle.Compiler.TypeInfo.member_map" />
    <member name="F:Nemerle.Compiler.TypeInfo.extension_patterns" />
    <member name="F:Nemerle.Compiler.TypeInfo.namespace_nd" />
    <member name="F:Nemerle.Compiler.TypeInfo._superTypes" />
    <member name="F:Nemerle.Compiler.TypeInfo._superTypesLookup" />
    <member name="F:Nemerle.Compiler.TypeInfo._superTypeInfosLookup" />
    <member name="F:Nemerle.Compiler.TypeInfo._superTypesCalculated" />
    <member name="M:Nemerle.Compiler.TypeInfo.#ctor(Nemerle.Compiler.NamespaceTree.Node,Nemerle.Compiler.ManagerClass,System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetElementTypeInfo" />
    <member name="M:Nemerle.Compiler.TypeInfo.CleanUp" />
    <member name="M:Nemerle.Compiler.TypeInfo.MakePointerTypeInfo" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsFloating" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsFloating" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsPrimitive" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsPrimitive" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsNumeric" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsNumeric" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Size" />
    <member name="P:Nemerle.Compiler.TypeInfo.Size" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Unsigned" />
    <member name="P:Nemerle.Compiler.TypeInfo.Unsigned" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsPointer" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsPointer" />
    <member name="F:Nemerle.Compiler.TypeInfo._N_field_code_embeded_in_VariantOptionCode_3420" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_VariantOptionCode" />
    <member name="M:Nemerle.Compiler.TypeInfo.set_VariantOptionCode(System.Int32)" />
    <member name="P:Nemerle.Compiler.TypeInfo.VariantOptionCode" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_NamespaceNode" />
    <member name="P:Nemerle.Compiler.TypeInfo.NamespaceNode" />
    <member name="M:Nemerle.Compiler.TypeInfo.add_member_by_name(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddExtensionPattern(Nemerle.Compiler.ExtensionPattern)" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetExtensionPattern(System.String)" />
    <member name="F:Nemerle.Compiler.TypeInfo.special_members" />
    <member name="M:Nemerle.Compiler.TypeInfo.MakeSingleParm(System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.FixupCompare(System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.ForceIntType(System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddConversion(System.String,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddConversion(System.String,Nemerle.Compiler.TypeInfo,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddBuiltin(System.String,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddBuiltin(System.String,System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddBuiltin(System.String,Nemerle.Compiler.TypeVar,System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddBuiltin(System.String,System.String,System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.AddBuiltin(System.String,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.TypeInfo.InitBuiltinMembers" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetHandle" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetHashCode" />
    <member name="M:Nemerle.Compiler.TypeInfo.Equals(Nemerle.Compiler.TypeInfo)">
      <summary>
        <para>Compare types for equality.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.Equals(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.TypeInfo.CompareTo(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.ToString" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_AttributeTargets" />
    <member name="P:Nemerle.Compiler.TypeInfo.AttributeTargets">
      <summary>
        <para>Returns custom attribute targets valid for this custom attribute.

</para>
      </summary>     <remarks><para>Valid only for type representing custom attribute.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsStatic" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsStatic">
      <summary>
        <para>Types are always static
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsModule" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsModule" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsSealed" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsSealed" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsInterface" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsInterface">
      <summary>
        <para>Specifies if given type is an interface
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.GetLibraryReference" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_DefaultIndexerName" />
    <member name="P:Nemerle.Compiler.TypeInfo.DefaultIndexerName" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_FullName" />
    <member name="P:Nemerle.Compiler.TypeInfo.FullName">
      <summary>
        <para>Return full qualified type name with namespaces and nesting types,
      all .-separated.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.get_FrameworkTypeName" />
    <member name="P:Nemerle.Compiler.TypeInfo.FrameworkTypeName">
      <summary>
        <para>Return full qualified type name with namespaces (.-separated) and
      nesting types (+-separated).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.LookupMemberImpl(System.String)" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_LookupMemberAvailable" />
    <member name="P:Nemerle.Compiler.TypeInfo.LookupMemberAvailable" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetSignature(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.TypeInfo.Hides(Nemerle.Builtins.Tuple{Nemerle.Compiler.IMember,Nemerle.Core.option{Nemerle.Compiler.FixedType}},Nemerle.Builtins.Tuple{Nemerle.Compiler.IMember,Nemerle.Core.option{Nemerle.Compiler.FixedType}})" />
    <member name="M:Nemerle.Compiler.TypeInfo.RemoveHiddenMembers(Nemerle.Core.list{Nemerle.Core.list{Nemerle.Compiler.IMember}})" />
    <member name="M:Nemerle.Compiler.TypeInfo.LookupMember(System.String,System.Boolean)">
      <summary>
        <para>Look for specified member.

</para>
      </summary>      <remarks><para>Semantics of returning base class member is the same as for
      [System.Type.GetMember] method.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.TypeInfo._recursionLevel" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetTydecl">
      <summary>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.ConstructSubst(Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar},Nemerle.Core.list{Nemerle.Compiler.TypeVar},System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeInfo.MakeSubst(Nemerle.Core.list{Nemerle.Compiler.TypeVar})">
      <summary>
        <para>Construct substitution resulting from applying this type constructor
      to specified arguments.

</para>
      </summary>      <remarks><para>For example assuming our type parameters are are ('a, 'b), then
      [MakeSubst (t1, t2)] produces substitution { 'a := t1; 'b := t2 }.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeInfo.MakeUncheckedSubst(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.TypeInfo.FreshSubst">
      <summary>
        <para>Return substitution replacing each of our type parameters with fresh
 type variable.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.GetFreshType" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetTypeArgumentsForSuperClass(Nemerle.Compiler.TypeInfo)">
      <summary>
        <para>If $this subtypes of $typeInfo, then return list of type parameters under which we subtype given type.

</para>
      </summary> <remarks><para>For example if [A ['a] :&gt; B [int]], then ["A".GetTypeArgumentsForSuperClass ("B")]
 returns [[int]].

</para> <para>This information can be also fetched from [GetDirectSuperTypes()]
 method but this function is transitive.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeInfo.IsDerivedFrom(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.IsDerivedFrom(Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.TypeInfo.LookupParentClassInstantiation(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.LookupParentInstantiations(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.HasSuperType(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.SubtypingSubst(Nemerle.Compiler.TypeInfo)">
      <summary>
        <para>Return substitution to apply to types of members of our supertype [ti]
 to get types of members in [this].

</para>
      </summary> <remarks>
    <para>For example consider:
    </para><code>
      class A ['a] { f : 'a; }
      class B : A [int] { }
    </code>
    <para>Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
    it can be applied to type of [A.f] which is ['a], to obtain type
    of [B.f] which is [int].
 </para></remarks>

</member>
    <member name="M:Nemerle.Compiler.TypeInfo.NestingSubst(Nemerle.Compiler.TypeInfo)">
      <summary>
        <para>[parent] is one of the enclosing types of [this]. For Parent['a,'b]
      and This['a1,'b1,'c] returns ['a := 'a1, 'b := 'b1]. If there are types
      between [parent] and [this], their type variables are also replaced.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.SuperClass" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_BaseType" />
    <member name="P:Nemerle.Compiler.TypeInfo.BaseType">
      <summary>
        <para>Gets the direct base type of this type. Null if there isn't any
      (e.g. for interfaces)
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.GetMembers">
      <summary>
        <para>Return list of all members defined in this very type and its
      supertypes.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.GetMembers(System.Reflection.BindingFlags)">
      <summary>
        <para>Searches for the members defined for the current TypeInfo, using the
      specified binding constraints.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.GetFields(System.Reflection.BindingFlags)">
      <summary>
        <para>Searches for the fields defined for the current TypeInfo, using the
      specified binding constraints.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.GetConstructors(System.Reflection.BindingFlags)" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetSuperTypes" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetDirectSuperTypes" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetConstantObject">
      <summary>
        <para>If this is a constant variant option, this method returns static class member that shall be
 used instead of calling constructor. Otherwise [null] is returned.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsDelegate" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsDelegate" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsEnum" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsEnum" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Accessibility" />
    <member name="P:Nemerle.Compiler.TypeInfo.Accessibility" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsExternallyAccessible" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsExternallyAccessible">
      <summary>
        <para>True if the type will be accessible from an external assembly.
 This depends on this type's and parent types' accessibility.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.get_IsValueType" />
    <member name="P:Nemerle.Compiler.TypeInfo.IsValueType">
      <summary>
        <para>If this is constructor of value type (which is allocated on stack not on heap)
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeInfo.HasAttribute(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.GetMemType">
      <summary>
        <para>If this type was defined as [class Foo ('a, 'b) { ... }] then return
 type expression [Foo ('a, 'b)].

</para>
      </summary> <remarks><para>Used mainly with [FreshSubst ()] or [MakeSubst ()].

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeInfo.get_DeclaredTypeParametersCount" />
    <member name="P:Nemerle.Compiler.TypeInfo.DeclaredTypeParametersCount" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_TyparmsCount" />
    <member name="P:Nemerle.Compiler.TypeInfo.TyparmsCount" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_SourceTyparmsCount" />
    <member name="P:Nemerle.Compiler.TypeInfo.SourceTyparmsCount" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Typarms" />
    <member name="P:Nemerle.Compiler.TypeInfo.Typarms" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Location" />
    <member name="P:Nemerle.Compiler.TypeInfo.Location" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_NameLocation" />
    <member name="P:Nemerle.Compiler.TypeInfo.NameLocation" />
    <member name="M:Nemerle.Compiler.TypeInfo.CanAccess(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_DeclaringType" />
    <member name="P:Nemerle.Compiler.TypeInfo.DeclaringType" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_Name" />
    <member name="P:Nemerle.Compiler.TypeInfo.Name" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_MemberKind" />
    <member name="P:Nemerle.Compiler.TypeInfo.MemberKind" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_UnderlyingType" />
    <member name="P:Nemerle.Compiler.TypeInfo.UnderlyingType" />
    <member name="F:Nemerle.Compiler.TypeInfo.Manager" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_InternalType" />
    <member name="P:Nemerle.Compiler.TypeInfo.InternalType" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.TypeInfo.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.TypeInfo.__fake" />
    <member name="M:Nemerle.Compiler.TypeInfo.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.TypeInfo.get_SystemType" />
    <member name="P:Nemerle.Compiler.TypeInfo.SystemType" />
    <member name="M:Nemerle.Compiler.TypeInfo.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.XmlDoc" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_appendTypeName_87847(Nemerle.Compiler.XmlDoc._N_closureOf_GetKey_87835,System.Text.StringBuilder,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_indexOf_87744(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar},Nemerle.Compiler.StaticTypeVar)" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_appendTypeNameAndArgs_87697(Nemerle.Compiler.XmlDoc._N_closureOf_AppendParmTypeName_87689,System.Text.StringBuilder,System.String,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_open_fake_87328(Nemerle.Compiler.XmlDoc._N_closureOf_parse_comment_87257,System.String)" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_possibly_close_87318(Nemerle.Compiler.XmlDoc._N_closureOf_parse_comment_87257,Nemerle.Builtins.Function{System.String,System.Boolean})" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_output_87304(Nemerle.Compiler.XmlDoc._N_closureOf_parse_comment_87257,Nemerle.Compiler.XmlDoc.XToken)" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_skip_ws_87292(Nemerle.Compiler.XmlDoc._N_closureOf_parse_comment_87257)" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_is_text_holding_87283(System.String)" />
    <member name="M:Nemerle.Compiler.XmlDoc._N_scan_86961(Nemerle.Compiler.XmlDoc._N_closureOf_loop_86936,Nemerle.Compiler.XmlDoc._N_closureOf_tokenize_86903,Nemerle.Builtins.Function{System.Char,System.Boolean})" />
    <member name="F:Nemerle.Compiler.XmlDoc.document" />
    <member name="F:Nemerle.Compiler.XmlDoc.docNode" />
    <member name="F:Nemerle.Compiler.XmlDoc.last_loc" />
    <member name="M:Nemerle.Compiler.XmlDoc.#ctor(Nemerle.Collections.Map{Nemerle.Compiler.Location,System.String},System.String)" />
    <member name="F:Nemerle.Compiler.XmlDoc.OutputFileName" />
    <member name="F:Nemerle.Compiler.XmlDoc.Comments" />
    <member name="M:Nemerle.Compiler.XmlDoc.Save" />
    <member name="M:Nemerle.Compiler.XmlDoc.CreateMember(System.String)" />
    <member name="M:Nemerle.Compiler.XmlDoc.DumpMember(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.XmlDoc.tokenize(System.String)" />
    <member name="M:Nemerle.Compiler.XmlDoc.parse_comment(System.String)" />
    <member name="M:Nemerle.Compiler.XmlDoc.add_comments(System.Xml.XmlNode,Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.XmlDoc.DumpType(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.XmlDoc.AppendParmTypeName(System.Text.StringBuilder,Nemerle.Compiler.TypeVar,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.XmlDoc.GetKey(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.XmlDoc.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.XmlDoc.XToken" />
    <member name="T:Nemerle.Compiler.CompilerComponentsFactory" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.#ctor" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateMethodBuilder(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Function,System.Boolean)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateMethodBuilder(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.ClassMember.Function)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateTyper(Nemerle.Compiler.Typer,Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateTyper(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateTyper(Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateTyper(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.TypeVarEnv,Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.GlobalEnv)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateTyper(Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.CompilerComponentsFactory.CreateLibraryReferenceManager(Nemerle.Compiler.ManagerClass,Nemerle.Core.list{System.String})" />
    <member name="T:Nemerle.Compiler.WellTyped" />
    <member name="F:Nemerle.Compiler.WellTyped.value__" />
    <member name="F:Nemerle.Compiler.WellTyped.Yes" />
    <member name="F:Nemerle.Compiler.WellTyped.NotYet" />
    <member name="F:Nemerle.Compiler.WellTyped.Error" />
    <member name="T:Nemerle.Compiler.IExprWalkerCallback" />
    <member name="M:Nemerle.Compiler.IExprWalkerCallback.Push(Nemerle.Compiler.ExprWalkInfo)" />
    <member name="M:Nemerle.Compiler.IExprWalkerCallback.Pop(Nemerle.Compiler.ExprWalkInfo)" />
    <member name="M:Nemerle.Compiler.IExprWalkerCallback.Stop(Nemerle.Compiler.ExprWalkInfo)" />
    <member name="M:Nemerle.Compiler.IExprWalkerCallback.Skip(Nemerle.Compiler.ExprWalkInfo)" />
    <member name="T:Nemerle.Compiler.ExprWalkHandler" />
    <member name="M:Nemerle.Compiler.ExprWalkHandler.BeginInvoke(Nemerle.Compiler.ExprWalkInfo,System.AsyncCallback,System.Object)" />
    <member name="M:Nemerle.Compiler.ExprWalkHandler.EndInvoke(System.IAsyncResult)" />
    <member name="M:Nemerle.Compiler.ExprWalkHandler.Invoke(Nemerle.Compiler.ExprWalkInfo)" />
    <member name="M:Nemerle.Compiler.ExprWalkHandler.#ctor(System.Object,System.IntPtr)" />
    <member name="T:Nemerle.Compiler.ExprWalkInfo" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.#ctor" />
    <member name="F:Nemerle.Compiler.ExprWalkInfo._isStopped" />
    <member name="F:Nemerle.Compiler.ExprWalkInfo._isSkipped" />
    <member name="F:Nemerle.Compiler.ExprWalkInfo._handler" />
    <member name="F:Nemerle.Compiler.ExprWalkInfo._callback" />
    <member name="F:Nemerle.Compiler.ExprWalkInfo._node" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Init(Nemerle.Compiler.ExprWalkHandler,Nemerle.Compiler.IExprWalkerCallback)" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Push(System.Object)" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Pop" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Walk(Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.ExprWalker})" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Walk(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Walk(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Walk(Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Stop" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.Skip" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.get_Node" />
    <member name="P:Nemerle.Compiler.ExprWalkInfo.Node" />
    <member name="M:Nemerle.Compiler.ExprWalkInfo.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ExprWalker" />
    <member name="F:Nemerle.Compiler.ExprWalker._info" />
    <member name="F:Nemerle.Compiler.ExprWalker._callback" />
    <member name="M:Nemerle.Compiler.ExprWalker.#ctor" />
    <member name="M:Nemerle.Compiler.ExprWalker.#ctor(Nemerle.Compiler.IExprWalkerCallback)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Push(System.Object)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Pop" />
    <member name="M:Nemerle.Compiler.ExprWalker.Init(Nemerle.Compiler.ExprWalkHandler)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.ClassMember})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.Splicable})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.SyntaxElement})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.Function_decl})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.MatchCase})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.TryCase})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Try_case})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TParameter})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TFunHeader})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Pattern})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Core.list{Nemerle.Compiler.IMember})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.FunBody)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.Splicable)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.Typarms)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.PFunHeader)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.Function_decl)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.PParameter)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.TryCase)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.MatchCase)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.SyntaxElement)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Sort``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.Parm)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.TParameter)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.Match_case)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Go(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Walk(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.ExprWalkHandler)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Walk(Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.ExprWalkHandler)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Walk(Nemerle.Compiler.Parsetree.ClassMember,Nemerle.Compiler.ExprWalkHandler)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Walk(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.ExprWalkHandler)" />
    <member name="M:Nemerle.Compiler.ExprWalker.GetLocation(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ExprWalker.GetLocation(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.ExprWalker.Resolve(Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ExprWalker.ForEachUnresolvedDelayed(Nemerle.Compiler.ManagerClass,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.Typer.DelayedTyping})" />
    <member name="M:Nemerle.Compiler.ExprWalker.FindUnresolvedDelayed(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ExprWalker.IsWellTyped(Nemerle.Compiler.Typedtree.TExpr)">
      <summary>
        <para>Is subexpression nave all types infered, have no unresolved and no errors

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ExprWalker.get_Info" />
    <member name="P:Nemerle.Compiler.ExprWalker.Info" />
    <member name="M:Nemerle.Compiler.ExprWalker.get_Callback" />
    <member name="P:Nemerle.Compiler.ExprWalker.Callback" />
    <member name="M:Nemerle.Compiler.ExprWalker.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.PrettyPrint" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_case_91088(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_local_fun_decl_90958(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,System.String,Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_need_curly_braces_90937(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_is_list_nil_90928(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_is_list_cons_90920(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_fun_call_parms_90905(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_expr_list_90898(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,System.String,Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr},System.String,System.String)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_type_90891(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_recurse_and_indent_90884(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_recurse_no_indent_90877(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_append_90861(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyExpr_90845,System.String)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_expr_is_false_90424(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_expr_is_true_90416(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_expr_is_bool_90400(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_do_print_90373(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr}},System.String)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_patterns_90366(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr}}}})" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_pattern_90359(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_recurse_and_short_indent_90352(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_recurse_and_indent_90345(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_recurse_90338(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_indent_90331(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_append_90324(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintTyMatch_90310,System.String)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_record_field_90169(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintPattern_90124,Nemerle.Compiler.IMember,Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_pattern_90139(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintPattern_90124,Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_append_90132(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintPattern_90124,System.String)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_gel_89979(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintExpr_89679,Nemerle.Compiler.GrammarElement)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_case_89915(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintExpr_89679,Nemerle.Compiler.Parsetree.TryCase)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_sprint_ss_89743(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintExpr_89679,Nemerle.Compiler.Parsetree.Splicable)" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_funparms_89736(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintExpr_89679,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.PrettyPrint._N_print_tconstraints_89698(Nemerle.Compiler.PrettyPrint._N_closureOf_SprintExpr_89679,Nemerle.Core.list{Nemerle.Compiler.Parsetree.Constraint})" />
    <member name="M:Nemerle.Compiler.PrettyPrint.UpdateLocation(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.PrintName(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.LocatableTextWriter)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintExpr(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Parsetree.PExpr,System.String,Nemerle.Compiler.LocatableTextWriter)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintExpr(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.PrintExpr(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.SeparatedCalls``1(System.String,Nemerle.Core.list{``0},Nemerle.Builtins.FunctionVoid{``0},Nemerle.Compiler.LocatableTextWriter)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintTyMatch(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case})">
      <summary>
        <para>Pretty prints a match ('expr') { 'match_cases' } instruction.
 This is a string generating wrapper for SprintTyMatch/6.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintPattern(Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintTyMatch(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.option{System.String},Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case},System.String,System.Text.StringBuilder)">
      <summary>
        <para>Pretty prints a match ('expr') { 'match_cases' } instruction.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintTyExpr(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Typedtree.TExpr)">
      <summary>
        <para>Pretty prints a typed tree expression.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintTyExpr(Nemerle.Compiler.Typedtree.TExpr)">
      <summary>
        <para>Pretty prints a typed tree expression.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PrettyPrint.SprintTyExpr(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.option{System.String},System.Boolean,System.String,System.Text.StringBuilder)">
      <summary>
        <para>Pretty prints a typed tree expression.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PrettyPrint.GetIdName(Nemerle.Compiler.Typedtree.TExpr,System.Int32)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.TyVarToParseTree(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.MTypeToParseTree(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.PrettyPrint.strip_nemerle_core_dot_prefix(System.String)">
      <summary>
        <para>Strips the 'Nemerle.Core.' prefix from type names

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.PrettyPrint.print_fun_typarms(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar})">
      <summary>
        <para>Prints a type parameters of a function declaration

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.LocatableTextWriter" />
    <member name="F:Nemerle.Compiler.LocatableTextWriter.sbuilder" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.get_Loc" />
    <member name="P:Nemerle.Compiler.LocatableTextWriter.Loc" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.Write(System.String)" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.FetchUpdatedLocation(Nemerle.Compiler.Located,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.MoveLocation(System.Int32)" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.ToString" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.get_Sbuilder" />
    <member name="P:Nemerle.Compiler.LocatableTextWriter.Sbuilder" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.LocatableTextWriter.#ctor(System.Text.StringBuilder)" />
    <member name="T:Nemerle.Compiler.LocatingTextWriter" />
    <member name="F:Nemerle.Compiler.LocatingTextWriter.loc" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.Write(System.String)" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.moveLoc(System.String)" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.MoveLocation(System.Int32)" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.FetchUpdatedLocation(Nemerle.Compiler.Located,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.get_Loc" />
    <member name="P:Nemerle.Compiler.LocatingTextWriter.Loc" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.LocatingTextWriter.#ctor(System.Text.StringBuilder,Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.StatsClass" />
    <member name="M:Nemerle.Compiler.StatsClass.#ctor" />
    <member name="F:Nemerle.Compiler.StatsClass.PrintTemps" />
    <member name="F:Nemerle.Compiler.StatsClass.AllTypeBuilders" />
    <member name="F:Nemerle.Compiler.StatsClass.FirstClassFunctions" />
    <member name="F:Nemerle.Compiler.StatsClass.FunctionClosures" />
    <member name="F:Nemerle.Compiler.StatsClass.TimeStarted" />
    <member name="F:Nemerle.Compiler.StatsClass.Temp1" />
    <member name="F:Nemerle.Compiler.StatsClass.Temp2" />
    <member name="F:Nemerle.Compiler.StatsClass.Temp3" />
    <member name="M:Nemerle.Compiler.StatsClass.Reset" />
    <member name="M:Nemerle.Compiler.StatsClass.Run(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.StatsClass.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.NamespaceTreeUtils" />
    <member name="M:Nemerle.Compiler.NamespaceTreeUtils.GetReferencedNamespaces(Nemerle.Compiler.NamespaceTree)" />
    <member name="T:Nemerle.Compiler.CFG" />
    <member name="M:Nemerle.Compiler.CFG._N_NodesAddFromList_91466(Nemerle.Compiler.CFG._N_closureOf_BuildCFG_91444,Nemerle.Compiler.CFG._N_closureOf_BuildCFG_91426,Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.CFG._N_BuildCFG_91438(Nemerle.Compiler.CFG._N_closureOf_BuildCFG_91426,System.Int32,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.CFG.#ctor" />
    <member name="M:Nemerle.Compiler.CFG.BuildCFG(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.CFG.BuildExprAvail(CFG.Array)" />
    <member name="M:Nemerle.Compiler.CFG.BuildExprUsed(CFG.Array)" />
    <member name="M:Nemerle.Compiler.CFG.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.CFG.DefUseInOut" />
    <member name="T:Nemerle.Compiler.CFG.GenKillInOut" />
    <member name="T:CFG.Node" />
    <member name="F:CFG.Node.prev" />
    <member name="F:CFG.Node.next" />
    <member name="F:CFG.Node.expr" />
    <member name="M:CFG.Node.#ctor(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:CFG.Node.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:CFG.Array" />
    <member name="F:CFG.Array.iNode" />
    <member name="M:CFG.Array.#ctor" />
    <member name="M:CFG.Array.AddNode(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:CFG.Array.AddEdge(System.Int32,System.Int32)" />
    <member name="M:CFG.Array.Iterate(Nemerle.Builtins.Function{System.Int32,CFG.Node,System.Boolean})" />
    <member name="M:CFG.Array.ReverseIterate(Nemerle.Builtins.Function{System.Int32,CFG.Node,System.Boolean})" />
    <member name="M:CFG.Array.GetUse(System.Int32)" />
    <member name="M:CFG.Array.Count" />
    <member name="M:CFG.Array.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Decorator" />
    <member name="M:Nemerle.Compiler.Decorator._N_LayDefs_91986(Nemerle.Compiler.Decorator._N_closureOf_MultipleAssignResolver_91978,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr}})" />
    <member name="M:Nemerle.Compiler.Decorator.#ctor" />
    <member name="M:Nemerle.Compiler.Decorator.Propagatable(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Decorator.SetDefOf(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr.Def)" />
    <member name="M:Nemerle.Compiler.Decorator.MultipleAssignResolver(Nemerle.Compiler.Typedtree.TExpr.MultipleAssign)" />
    <member name="M:Nemerle.Compiler.Decorator.decorate(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Decorator.Decorate(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Decorator.Undecorate(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Decorator.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Optimizer" />
    <member name="M:Nemerle.Compiler.Optimizer.#cctor" />
    <member name="F:Nemerle.Compiler.Optimizer.e" />
    <member name="F:Nemerle.Compiler.Optimizer.the_method" />
    <member name="F:Nemerle.Compiler.Optimizer.OptCounter" />
    <member name="F:Nemerle.Compiler.Optimizer.ignoreOptRange" />
    <member name="F:Nemerle.Compiler.Optimizer.opt" />
    <member name="M:Nemerle.Compiler.Optimizer.#ctor(Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.Optimizer.StrippedOptimization(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.TParameter})" />
    <member name="M:Nemerle.Compiler.Optimizer.Run" />
    <member name="M:Nemerle.Compiler.Optimizer.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Preparer" />
    <member name="M:Nemerle.Compiler.Preparer._N_LayDefs_92517(Nemerle.Compiler.Preparer._N_closureOf_SplitTrivialTuple_92487,Nemerle.Core.list{Nemerle.Compiler.LocalValue},Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr},Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Preparer._N_CreateLocalValues_92501(Nemerle.Compiler.Preparer._N_closureOf_SplitTrivialTuple_92487,System.Int32,Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.Preparer.#ctor" />
    <member name="M:Nemerle.Compiler.Preparer.AddDefs(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.TParameter})" />
    <member name="M:Nemerle.Compiler.Preparer.RemoveDefs(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Preparer.TupleDismounter(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Preparer.Strip(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Preparer.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Propagator" />
    <member name="M:Nemerle.Compiler.Propagator.#ctor" />
    <member name="M:Nemerle.Compiler.Propagator.Worthy(System.Int32,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Propagator.Propagate(CFG.Array,Nemerle.Compiler.CFG.GenKillInOut[],Nemerle.Compiler.CFG.DefUseInOut[])" />
    <member name="M:Nemerle.Compiler.Propagator.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Unification" />
    <member name="M:Nemerle.Compiler.Unification._N_GetUnited_92916(Nemerle.Compiler.Unification._N_closureOf_Apply_92906,Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.Unification.#ctor" />
    <member name="M:Nemerle.Compiler.Unification.Calculate(CFG.Array,Nemerle.Compiler.CFG.DefUseInOut[],Nemerle.Core.list{Nemerle.Compiler.Typedtree.TParameter})" />
    <member name="M:Nemerle.Compiler.Unification.Apply(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Collections.Hashtable{Nemerle.Compiler.LocalValue,Nemerle.Compiler.LocalValue})" />
    <member name="M:Nemerle.Compiler.Unification.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Unification.Graph" />
    <member name="T:UseSetComparer" />
    <member name="M:UseSetComparer.#ctor" />
    <member name="M:UseSetComparer.GetHashCode(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:UseSetComparer.equals(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:UseSetComparer.Equals(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:UseSetComparer.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:UseSet" />
    <member name="F:UseSet.used" />
    <member name="M:UseSet.#ctor" />
    <member name="M:UseSet.Insert(Nemerle.Compiler.Typedtree.TExpr,System.Int32)" />
    <member name="M:UseSet.Get(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:UseSet.GetAllUsed" />
    <member name="M:UseSet.ToString" />
    <member name="M:UseSet.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.ConstantFolder" />
    <member name="M:Nemerle.Compiler.ConstantFolder._N_lookup_type_94012(Nemerle.Compiler.ConstantFolder._N_closureOf_fold_type_conversion_94002)" />
    <member name="M:Nemerle.Compiler.ConstantFolder._N_report_conversion_failure_93852(Nemerle.Compiler.ConstantFolder._N_closureOf_convert_integer_literal_93842)" />
    <member name="M:Nemerle.Compiler.ConstantFolder._N_positive_93445(Nemerle.Compiler.Literal.Integer)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.#cctor" />
    <member name="F:Nemerle.Compiler.ConstantFolder.known_operators" />
    <member name="M:Nemerle.Compiler.ConstantFolder.is_known_operator(System.String)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.UnsignedValue(Nemerle.Compiler.Literal.Integer)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.CheckInteger(Nemerle.Compiler.Literal.Integer)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldLiterals(System.Boolean,System.String,Nemerle.Compiler.Literal,Nemerle.Compiler.Literal)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.CheckAndNormalizeInteger(Nemerle.Compiler.Literal.Integer)" />
    <member name="F:Nemerle.Compiler.ConstantFolder.wide_rank" />
    <member name="M:Nemerle.Compiler.ConstantFolder.SelectWideType(Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldLiterals(System.Boolean,System.String,Nemerle.Compiler.Literal.Integer,Nemerle.Compiler.Literal.Integer)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.MaxValueMask(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.MaxSignedValueMask(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.ConvertSignTo(System.UInt64,Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldLiteral(System.Boolean,System.String,Nemerle.Compiler.Literal)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldLiteral(System.Boolean,System.String,Nemerle.Compiler.Literal.Integer)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.emit_flag_warning(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FieldValueAsLiteral(Nemerle.Compiler.IField,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FieldValueAsPureLiteral(Nemerle.Compiler.IField,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.literal_field_value(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.get_literal(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.literal_of_expr(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.fold_unary_operator(System.Boolean,System.String,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.fold_binary_operator(System.Boolean,System.String,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.ConvertLiteral(Nemerle.Compiler.Literal,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.convert_integer_literal(Nemerle.Compiler.Literal.Integer,System.String)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.fold_type_conversion(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.fold_constants(System.Boolean,Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.perform_check``1(System.Boolean,Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldTyped(System.String,Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldTyped(System.String,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldConstants(Nemerle.Compiler.Typer,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldConstants(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeBuilder)" />
    <member name="M:Nemerle.Compiler.ConstantFolder.FoldConstants(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder._N_traverse_94363(Nemerle.Compiler.DecisionTreeBuilder._N_closureOf_CheckMatching_94347,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.DecisionTreeBuilder.Path,Nemerle.Compiler.DecisionTreeBuilder.Con}},Nemerle.Compiler.DecisionTreeBuilder.Decision)" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.Build(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Typedtree.Pattern,System.Boolean,System.Int32}})">
      <summary>
        <para>Build decision tree for given list of (pattern, has_guard, id)
        triples.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.BuildCounterExample(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.DecisionTreeBuilder.Path,Nemerle.Compiler.DecisionTreeBuilder.Con}})" />
    <member name="F:Nemerle.Compiler.DecisionTreeBuilder.patterns" />
    <member name="F:Nemerle.Compiler.DecisionTreeBuilder.decision" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.#ctor(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case})" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.GetDecision" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.CheckMatching">
      <summary>
        <para>Give warnings about ``pattern matching not exhaustive'' and
        ``unused match clause''.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.CheckMatching(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Match_case})">
      <summary>
        <para>Construct a Decision tree and call CheckMatching () on it.
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.DecisionTreeBuilder.Manager" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.get_InternalType" />
    <member name="P:Nemerle.Compiler.DecisionTreeBuilder.InternalType" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.DecisionTreeBuilder.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.__fake" />
    <member name="M:Nemerle.Compiler.DecisionTreeBuilder.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.IgnoreCounterExample" />
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.Con" />
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.Skeleton">
      <summary>
        <para>Represent our current state of the knowledge about the term
        matched.
</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.Path">
      <summary>
        <para>Represent an access path to a subterm.
</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.Decision">
      <summary>
        <para>Represent a decision tree.
</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.TopLevelPattern">
      <summary>
        <para>Used for compilation of the top-level patterns.
</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.DecisionTreeBuilder.CounterExample">
      <summary>
        <para>Represent a counter example for non exhaustive matching.
</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.ErrorMessage" />
    <member name="M:Nemerle.Compiler.ErrorMessage.#ctor(System.String)" />
    <member name="M:Nemerle.Compiler.ErrorMessage.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LocalContext">
      <summary>
        <para>Represents a immutable typing context, corresponding to a specific
      place in the source code.

</para>
      </summary>      <remarks><para>It is stored with expressions pending to be typed.

</para></remarks></member>
    <member name="F:Nemerle.Compiler.LocalContext.locals" />
    <member name="F:Nemerle.Compiler.LocalContext.is_checked" />
    <member name="M:Nemerle.Compiler.LocalContext.ToString" />
    <member name="M:Nemerle.Compiler.LocalContext.FindLocal(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.LocalContext.Fold``1(``0,Nemerle.Builtins.Function{Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.LocalValue,``0,``0})" />
    <member name="M:Nemerle.Compiler.LocalContext.GetLocals" />
    <member name="M:Nemerle.Compiler.LocalContext.get_IsChecked" />
    <member name="P:Nemerle.Compiler.LocalContext.IsChecked">
      <summary>
        <para>[false] if we are in the [unchecked { ... }] block.
        Default behavior is defined by CheckIntegerOverflow compilation option.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.LocalContext.#ctor" />
    <member name="M:Nemerle.Compiler.LocalContext.#ctor(Nemerle.Compiler.LocalContext)" />
    <member name="M:Nemerle.Compiler.LocalContext.WithChecked(System.Boolean)" />
    <member name="M:Nemerle.Compiler.LocalContext.WithLocal(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.LocalValue)" />
    <member name="F:Nemerle.Compiler.LocalContext._N_field_empty_embeded_in_Empty_3406" />
    <member name="M:Nemerle.Compiler.LocalContext.get_Empty" />
    <member name="P:Nemerle.Compiler.LocalContext.Empty" />
    <member name="M:Nemerle.Compiler.LocalContext.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LocalContext.EmptyLocalContext">
      <summary>
        <para>Class provides access to CheckIntegerOverflow compilation option
        via IsChecked property.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.LocalValue" />
    <member name="F:Nemerle.Compiler.LocalValue.ty" />
    <member name="F:Nemerle.Compiler.LocalValue.is_registered" />
    <member name="F:Nemerle.Compiler.LocalValue.closure_field" />
    <member name="F:Nemerle.Compiler.LocalValue.kind" />
    <member name="M:Nemerle.Compiler.LocalValue.get_ValueKind" />
    <member name="P:Nemerle.Compiler.LocalValue.ValueKind" />
    <member name="F:Nemerle.Compiler.LocalValue.id" />
    <member name="F:Nemerle.Compiler.LocalValue._N_IsPinned_14793" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsPinned" />
    <member name="M:Nemerle.Compiler.LocalValue.set_IsPinned(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.IsPinned" />
    <member name="M:Nemerle.Compiler.LocalValue.get_CanInline" />
    <member name="P:Nemerle.Compiler.LocalValue.CanInline" />
    <member name="F:Nemerle.Compiler.LocalValue.name" />
    <member name="F:Nemerle.Compiler.LocalValue.is_mutable" />
    <member name="F:Nemerle.Compiler.LocalValue.defined_in" />
    <member name="F:Nemerle.Compiler.LocalValue.name_location" />
    <member name="F:Nemerle.Compiler.LocalValue.used_in" />
    <member name="F:Nemerle.Compiler.LocalValue.in_closure" />
    <member name="F:Nemerle.Compiler.LocalValue.ever_used" />
    <member name="F:Nemerle.Compiler.LocalValue.is_cache" />
    <member name="F:Nemerle.Compiler.LocalValue.is_managed_ptr" />
    <member name="F:Nemerle.Compiler.LocalValue.never_closurise" />
    <member name="F:Nemerle.Compiler.LocalValue.postponed_declaration" />
    <member name="F:Nemerle.Compiler.LocalValue.declare" />
    <member name="F:Nemerle.Compiler.LocalValue.expanded_block_return" />
    <member name="F:Nemerle.Compiler.LocalValue._N_field__userData_embeded_in_UserData_3405" />
    <member name="M:Nemerle.Compiler.LocalValue.get_UserData" />
    <member name="P:Nemerle.Compiler.LocalValue.UserData" />
    <member name="M:Nemerle.Compiler.LocalValue.#ctor(Nemerle.Compiler.Typedtree.TFunHeader,System.String,Nemerle.Compiler.TypeVar,Nemerle.Compiler.LocalValue.Kind,System.Boolean)" />
    <member name="M:Nemerle.Compiler.LocalValue.#ctor(Nemerle.Compiler.Typedtree.TFunHeader,System.String,Nemerle.Compiler.Location,Nemerle.Compiler.TypeVar,Nemerle.Compiler.LocalValue.Kind,System.Boolean)" />
    <member name="M:Nemerle.Compiler.LocalValue.Equals(Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.LocalValue.GetHashCode" />
    <member name="M:Nemerle.Compiler.LocalValue.UseFrom(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.LocalValue.get_Type" />
    <member name="P:Nemerle.Compiler.LocalValue.Type" />
    <member name="M:Nemerle.Compiler.LocalValue.get_ValKind" />
    <member name="P:Nemerle.Compiler.LocalValue.ValKind" />
    <member name="M:Nemerle.Compiler.LocalValue.ToString" />
    <member name="M:Nemerle.Compiler.LocalValue.CompareTo(Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.LocalValue.get_UsedInPatternBody" />
    <member name="M:Nemerle.Compiler.LocalValue.set_UsedInPatternBody(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.UsedInPatternBody" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsRegistered" />
    <member name="P:Nemerle.Compiler.LocalValue.IsRegistered" />
    <member name="M:Nemerle.Compiler.LocalValue.Register" />
    <member name="M:Nemerle.Compiler.LocalValue.get_ClosureField" />
    <member name="M:Nemerle.Compiler.LocalValue.set_ClosureField(Nemerle.Compiler.IField)" />
    <member name="P:Nemerle.Compiler.LocalValue.ClosureField" />
    <member name="M:Nemerle.Compiler.LocalValue.SetType(Nemerle.Compiler.TypeVar)" />
    <member name="F:Nemerle.Compiler.LocalValue.ilkind" />
    <member name="M:Nemerle.Compiler.LocalValue.CheckIL" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsByRefParm" />
    <member name="P:Nemerle.Compiler.LocalValue.IsByRefParm" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsParm" />
    <member name="P:Nemerle.Compiler.LocalValue.IsParm" />
    <member name="M:Nemerle.Compiler.LocalValue.get_LocalSlot" />
    <member name="M:Nemerle.Compiler.LocalValue.set_LocalSlot(System.Reflection.Emit.LocalBuilder)" />
    <member name="P:Nemerle.Compiler.LocalValue.LocalSlot" />
    <member name="M:Nemerle.Compiler.LocalValue.get_ParmIndex" />
    <member name="P:Nemerle.Compiler.LocalValue.ParmIndex" />
    <member name="M:Nemerle.Compiler.LocalValue.SetParmIndex(System.Int32,System.Boolean)" />
    <member name="M:Nemerle.Compiler.LocalValue.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.LocalValue.get_Name" />
    <member name="P:Nemerle.Compiler.LocalValue.Name" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsMutable" />
    <member name="P:Nemerle.Compiler.LocalValue.IsMutable" />
    <member name="M:Nemerle.Compiler.LocalValue.get_DefinedIn" />
    <member name="P:Nemerle.Compiler.LocalValue.DefinedIn" />
    <member name="M:Nemerle.Compiler.LocalValue.get_NameLocation" />
    <member name="P:Nemerle.Compiler.LocalValue.NameLocation" />
    <member name="M:Nemerle.Compiler.LocalValue.get_UsedIn" />
    <member name="P:Nemerle.Compiler.LocalValue.UsedIn" />
    <member name="M:Nemerle.Compiler.LocalValue.get_InClosure" />
    <member name="M:Nemerle.Compiler.LocalValue.set_InClosure(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.InClosure" />
    <member name="M:Nemerle.Compiler.LocalValue.get_EverUsed" />
    <member name="M:Nemerle.Compiler.LocalValue.set_EverUsed(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.EverUsed" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsCache" />
    <member name="M:Nemerle.Compiler.LocalValue.set_IsCache(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.IsCache" />
    <member name="M:Nemerle.Compiler.LocalValue.get_IsManagedPtr" />
    <member name="M:Nemerle.Compiler.LocalValue.set_IsManagedPtr(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.IsManagedPtr" />
    <member name="M:Nemerle.Compiler.LocalValue.get_NeverClosurise" />
    <member name="M:Nemerle.Compiler.LocalValue.set_NeverClosurise(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.NeverClosurise" />
    <member name="M:Nemerle.Compiler.LocalValue.get_PostponedDeclaration" />
    <member name="M:Nemerle.Compiler.LocalValue.set_PostponedDeclaration(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.PostponedDeclaration" />
    <member name="M:Nemerle.Compiler.LocalValue.get_Declare" />
    <member name="M:Nemerle.Compiler.LocalValue.set_Declare(Nemerle.Builtins.FunctionVoid)" />
    <member name="P:Nemerle.Compiler.LocalValue.Declare" />
    <member name="M:Nemerle.Compiler.LocalValue.get_ExpandedBlockReturn" />
    <member name="M:Nemerle.Compiler.LocalValue.set_ExpandedBlockReturn(System.Boolean)" />
    <member name="P:Nemerle.Compiler.LocalValue.ExpandedBlockReturn" />
    <member name="M:Nemerle.Compiler.LocalValue.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.LocalValue.ILKind" />
    <member name="T:Nemerle.Compiler.LocalValue.Kind" />
    <member name="T:Nemerle.Compiler.MacroColorizator">
      <summary>
        <para>A class responsible for assigning new colors to macro contexts.
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.MacroColorizator.Color" />
    <member name="F:Nemerle.Compiler.MacroColorizator.UseColor" />
    <member name="F:Nemerle.Compiler.MacroColorizator.UseContext" />
    <member name="F:Nemerle.Compiler.MacroColorizator.max_macro_color" />
    <member name="F:Nemerle.Compiler.MacroColorizator.colors_stack" />
    <member name="M:Nemerle.Compiler.MacroColorizator.#ctor" />
    <member name="M:Nemerle.Compiler.MacroColorizator.NewColor" />
    <member name="M:Nemerle.Compiler.MacroColorizator.InGlobalColor``1(Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.MacroColorizator.PushNewColor(System.Int32,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Creates new color for execution of macro expansion, stores
        this color as top of the stack, together with [macro_use]
        as context color of currently executed macro.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.MacroColorizator.PushUseSiteColor" />
    <member name="M:Nemerle.Compiler.MacroColorizator.PopColor">
      <summary>
        <para>Bring color context of previous execution of macro
        (occurs when macro expansion execution finishes).

</para>
      </summary>        <remarks><para>Assumes that [PushNewColor] was called before

</para></remarks></member>
    <member name="M:Nemerle.Compiler.MacroColorizator.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.MacroRegistry" />
    <member name="F:Nemerle.Compiler.MacroRegistry.extensions" />
    <member name="F:Nemerle.Compiler.MacroRegistry.implicit_ctx_name" />
    <member name="M:Nemerle.Compiler.MacroRegistry.GetImplicitCTXName" />
    <member name="M:Nemerle.Compiler.MacroRegistry.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.MacroRegistry.GetSyntaxExtensions(Nemerle.Compiler.NamespaceTree.Node)" />
    <member name="M:Nemerle.Compiler.MacroRegistry.AddOperatorDefinition(Nemerle.Compiler.OperatorDefinition)" />
    <member name="M:Nemerle.Compiler.MacroRegistry.RegisterMacro(Nemerle.Compiler.IMacro)" />
    <member name="M:Nemerle.Compiler.MacroRegistry.expand_one_macro(Nemerle.Compiler.Typer,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MacroRegistry.expand_macro(Nemerle.Compiler.Typer,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.MacroRegistry.lookup_macro(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr,System.String)" />
    <member name="F:Nemerle.Compiler.MacroRegistry.Manager" />
    <member name="M:Nemerle.Compiler.MacroRegistry.get_InternalType" />
    <member name="P:Nemerle.Compiler.MacroRegistry.InternalType" />
    <member name="M:Nemerle.Compiler.MacroRegistry.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.MacroRegistry.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.MacroRegistry.__fake" />
    <member name="M:Nemerle.Compiler.MacroRegistry.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Macros" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_top_decl_98769(Nemerle.Compiler.Macros._N_closureOf_TraverseExprWithContext_98662,Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_field_98760(Nemerle.Compiler.Macros._N_closureOf_TraverseExprWithContext_98662,Nemerle.Compiler.Parsetree.ClassMember.Field)" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_fun_head_98737(Nemerle.Compiler.Macros._N_closureOf_TraverseExprWithContext_98662,Nemerle.Compiler.Parsetree.PFunHeader)" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_funparms_98706(Nemerle.Compiler.Macros._N_closureOf_TraverseExprWithContext_98662,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_top_decl_98175(Nemerle.Compiler.Macros._N_closureOf_TraverseExpr_98067,Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_field_98166(Nemerle.Compiler.Macros._N_closureOf_TraverseExpr_98067,Nemerle.Compiler.Parsetree.ClassMember.Field)" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_fun_head_98143(Nemerle.Compiler.Macros._N_closureOf_TraverseExpr_98067,Nemerle.Compiler.Parsetree.PFunHeader)" />
    <member name="M:Nemerle.Compiler.Macros._N_trav_funparms_98112(Nemerle.Compiler.Macros._N_closureOf_TraverseExpr_98067,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter})" />
    <member name="M:Nemerle.Compiler.Macros._N_traversep_98105(Nemerle.Compiler.Macros._N_closureOf_TraverseExpr_98067,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Macros._N_convert_params_97790(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Core.list{Nemerle.Compiler.IField},Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Macros._N_constructor_97349(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Macros.#cctor">
      <summary>
        <para>PUBLIC API FOR USAGE IN MACROS

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.NewSymbol">
      <summary>
        <para>generates new unique symbol, which can be safely used
      as name of quoted variables, functions, etc.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.NewSymbol(System.String)">
      <summary>
        <para>generates new unique symbol, which can be safely used
      as name of quoted variables, functions, etc.
      The [root] parameter can be used to specify a string to be
      part of the name, mostly for debugging purposes.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.UseSiteSymbol(System.String)">
      <summary>
        <para>controlled hygiene breaking - generates symbol, which
      placed in generated code would bind to variables
      at macro-use site

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.IsTypeName(Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>Checks if given expression describes name of a type, like
      [System.Console] (it is a class)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.GetIfIsType(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>Checks if given expression describes name of a type, like
      [System.Console] (it is a class)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.DefaultValueOfType(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Macros.Lift(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})">
      <summary>
        <para>Lifts given list of expressions to syntax tree of list containing
 elements, whose syntax trees are defined by those expressions.
 (expressions on the list are not lifted)

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.Lift``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,Nemerle.Compiler.Parsetree.PExpr})">
      <summary>
        <para>Lifts given list to syntax tree of this list, applying
 supplied function to each of its elements. The function
 is used here to lift elements of list, so we can build
 entire syntax trees from them.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.Lift``1(Nemerle.Core.option{``0},Nemerle.Builtins.Function{``0,Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Macros.Lift(System.Int32)">
      <summary>
        <para>Creates syntax tree of given number (expression building it)
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.Lift(System.String)" />
    <member name="M:Nemerle.Compiler.Macros.TypedChoose(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Macros.TypedChoose(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose``1(``0)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose``1(Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.String)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Int32)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Byte)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.SByte)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Int16)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.UInt16)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.UInt32)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Int64)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.UInt64)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Boolean)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Char)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Single)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Double)" />
    <member name="M:Nemerle.Compiler.Macros.QuotationChoose(System.Decimal)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_sstring(Nemerle.Compiler.Parsetree.Splicable)">
      <summary>
        <para>Lifts up [Splicable]. [Splicable.Expression] is substituted by its
      content and appropriate [Splicable.Name] expression is created.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.quoted_name(Nemerle.Compiler.Parsetree.Name,System.Int32)">
      <summary>
        <para>Lifts up [Name] giving it supplied context number.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.quoted_name(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.Macros.QuotedMatchCase(Nemerle.Compiler.Parsetree.MatchCase)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_fparam(Nemerle.Compiler.Parsetree.PParameter)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_tparms(Nemerle.Core.list{Nemerle.Compiler.Parsetree.Splicable},Nemerle.Core.list{Nemerle.Compiler.Parsetree.Constraint})" />
    <member name="M:Nemerle.Compiler.Macros.make_quoted_funheader(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Macros.make_quoted_fundecl(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PParameter},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_attributes(Nemerle.Compiler.AttributesAndModifiers)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_member(Nemerle.Compiler.Parsetree.ClassMember)" />
    <member name="M:Nemerle.Compiler.Macros.lift_members(Nemerle.Core.list{Nemerle.Compiler.Parsetree.ClassMember})" />
    <member name="M:Nemerle.Compiler.Macros.lift_with_ellipsis(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Macros.quoted_tydecl(Nemerle.Compiler.Parsetree.TopDeclaration)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_funbody(Nemerle.Compiler.FunBody)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_literal(Nemerle.Compiler.Literal)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_fundecl(Nemerle.Compiler.Parsetree.Function_decl)" />
    <member name="M:Nemerle.Compiler.Macros.quoted_ttype(Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>Creates parse tree of (expression which builds) given typed type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.quoted_expr(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Macros.patternize_quotation(Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>transforms given expression (which is supposed to be generated from
      quoted expression) into pattern

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Macros.TraverseExpr(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Parsetree.PExpr,System.Boolean,Nemerle.Builtins.Function{System.Boolean,System.Boolean,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr})">
      <summary>
        <para>Allows recursive analysing and rewriting given parse tree expression easily. It calls supplied function on every
 node of tree returning its result as new node.

</para>
      </summary> <remarks><para>[ctx] - when specified, then expression is first macro-expanded and expansion result is then further analyzed
 [expr] - expression to be processed
 [in_pattern] - context boolean used to provide information if we are currently in match case pattern
 [call] - function called for each node of tree, first parameter hold the [in_pattern] semantics; second denotes if we are calling the
          function before processing of subnodes (==false) and after (==true) - the function is always called twice for each node;
          third passes the current node to operate on; return value (used only from second/postprocess call) is used as new node value

</para></remarks></member>
    <member name="M:Nemerle.Compiler.Macros.RecursiveRename(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.Macros.TraverseExprWithContext(Nemerle.Core.option{Nemerle.Compiler.Typer},Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TraverseContext,Nemerle.Builtins.Function{Nemerle.Compiler.TraverseContext,System.Boolean,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr})">
      <summary>
        <para>Allows recursive analysing and rewriting given parse tree expression easily. It calls supplied function on every
 node of tree returning its result as new node. Extended context is used, it may collect full parent expression information,
 or can collect only needed nodes

</para>
      </summary> <remarks><para>[ctx] - when specified, then expression is first macro-expanded and expansion result is then further analyzed
 [expr] - expression to be processed
 [context] - context used to provide information on expression and its parents. null parameter means Top context.
 TraverseContext.Top(flags : TraverseContext.CommonFlags) - initializes top context, flags can be initialized with value
 full history means collect all info, false only needed
 to manual use context (full_history = false), you must call Push() method in context in call before (after = false), and it used in next traversal
 You can store Data in context, you can access it later
 You can break traversing with Break() method on context, all your data and traversing info on this moment is saved and function exits
 [call] - function called for each node of tree, first parameter hold the [context] semantics; second denotes if we are calling the
          function before processing of subnodes (after == false) and after (after == true) - the function maybe called twice for each node;
          third parameter passes the current node to operate on;
          if call before returns new expression, it replace old expression (in normal skip mode) second call and traverse sub nodes is skipped
          in NoSkip mode flag with traverse is continued on return expression
          if we want to traverse sub nodes, in first call (after == false) we must necesseraly return null.
          return value (used only from second/postprocess call) is used as new node value

</para></remarks></member>
    <member name="M:Nemerle.Compiler.Macros.get_Manager" />
    <member name="P:Nemerle.Compiler.Macros.Manager" />
    <member name="M:Nemerle.Compiler.Macros.get_InternalType" />
    <member name="P:Nemerle.Compiler.Macros.InternalType" />
    <member name="M:Nemerle.Compiler.Macros.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.Macros.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.Macros.__fake" />
    <member name="T:Nemerle.Compiler.Messenger">
      <summary>
        <para>Class to deal with error/warning reporting.
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Messenger.seen_error" />
    <member name="F:Nemerle.Compiler.Messenger.first_error" />
    <member name="F:Nemerle.Compiler.Messenger.need_message" />
    <member name="F:Nemerle.Compiler.Messenger.throw_on_error" />
    <member name="F:Nemerle.Compiler.Messenger.previous" />
    <member name="F:Nemerle.Compiler.Messenger.in_error_mode" />
    <member name="F:Nemerle.Compiler.Messenger.saved_error" />
    <member name="F:Nemerle.Compiler.Messenger.local_error" />
    <member name="M:Nemerle.Compiler.Messenger.CopyFrom(Nemerle.Compiler.Messenger)" />
    <member name="M:Nemerle.Compiler.Messenger.PushState" />
    <member name="M:Nemerle.Compiler.Messenger.PopState" />
    <member name="M:Nemerle.Compiler.Messenger.#ctor" />
    <member name="M:Nemerle.Compiler.Messenger.Error(System.String)" />
    <member name="M:Nemerle.Compiler.Messenger.Cleanup" />
    <member name="M:Nemerle.Compiler.Messenger.CleanLocalError" />
    <member name="M:Nemerle.Compiler.Messenger.SaveError(System.String)" />
    <member name="M:Nemerle.Compiler.Messenger.DumpSavedError">
      <summary>
        <para>A debug tool.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Messenger.MarkError">
      <summary>
        <para>Set the messenger to be in the error state.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Messenger.get_NeedMessage" />
    <member name="M:Nemerle.Compiler.Messenger.set_NeedMessage(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Messenger.NeedMessage" />
    <member name="M:Nemerle.Compiler.Messenger.get_SeenError" />
    <member name="M:Nemerle.Compiler.Messenger.set_SeenError(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Messenger.SeenError">
      <summary>
        <para>Check if we have encountered an error in the current state.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Messenger.get_IsTopLevel" />
    <member name="P:Nemerle.Compiler.Messenger.IsTopLevel" />
    <member name="M:Nemerle.Compiler.Messenger.get_LocalError" />
    <member name="P:Nemerle.Compiler.Messenger.LocalError" />
    <member name="M:Nemerle.Compiler.Messenger.get_LocalErrorCount" />
    <member name="P:Nemerle.Compiler.Messenger.LocalErrorCount" />
    <member name="M:Nemerle.Compiler.Messenger.get_InErrorMode" />
    <member name="M:Nemerle.Compiler.Messenger.set_InErrorMode(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Messenger.InErrorMode" />
    <member name="M:Nemerle.Compiler.Messenger.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.FixedType">
      <summary>
        <para>Represent top-level type constructor for a given type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType._N_makeTyArgs_102088(Nemerle.Compiler.FixedType._N_closureOf_GetInstantiatedSuperType_102056,Nemerle.Compiler.FixedType.Class,Nemerle.Core.list{Nemerle.Compiler.FixedType})" />
    <member name="M:Nemerle.Compiler.FixedType._N_get_siblings_101834(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.FixedType._N_unifyTypeArgs_101292(Nemerle.Compiler.FixedType._N_closureOf_Require_101191,Nemerle.Core.list{Nemerle.Compiler.FixedType},Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo,Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.FixedType._N_covariant_check_101198(Nemerle.Compiler.StaticTypeVar,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.FixedType.Equals(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Check for type equality, taking intersection types
        into account.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.GetHashCode``1(System.Int32,Nemerle.Core.list{``0})" />
    <member name="M:Nemerle.Compiler.FixedType.GetHashCode" />
    <member name="M:Nemerle.Compiler.FixedType.GetNonVoidSystemType" />
    <member name="M:Nemerle.Compiler.FixedType.GetSystemType" />
    <member name="M:Nemerle.Compiler.FixedType.pairWiseUnify(Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.FixedType.TryEnforcingEquality(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Check for type equality, taking intersection types
        into account. If it's possible that types are equal -- enforce
        that.  Assume non-seperated types.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.Require(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Enforce [this] to be subtype of [t].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.Unify(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Enforce [this] to be equal [t].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.ToString" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsSeparated" />
    <member name="P:Nemerle.Compiler.FixedType.IsSeparated">
      <summary>
        <para>Check if given type cannot be supertyped by a plain type
        constructor.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.get_IsNullable" />
    <member name="P:Nemerle.Compiler.FixedType.IsNullable" />
    <member name="M:Nemerle.Compiler.FixedType.get_CanBeNull" />
    <member name="P:Nemerle.Compiler.FixedType.CanBeNull" />
    <member name="M:Nemerle.Compiler.FixedType.get_NeedNoSubst" />
    <member name="P:Nemerle.Compiler.FixedType.NeedNoSubst" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsPointer" />
    <member name="P:Nemerle.Compiler.FixedType.IsPointer" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsInterface" />
    <member name="P:Nemerle.Compiler.FixedType.IsInterface" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsSystemObject" />
    <member name="P:Nemerle.Compiler.FixedType.IsSystemObject" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsPrimitive" />
    <member name="P:Nemerle.Compiler.FixedType.IsPrimitive" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsValueType" />
    <member name="P:Nemerle.Compiler.FixedType.IsValueType" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsEnum" />
    <member name="P:Nemerle.Compiler.FixedType.IsEnum" />
    <member name="M:Nemerle.Compiler.FixedType.get_IsFunction" />
    <member name="P:Nemerle.Compiler.FixedType.IsFunction" />
    <member name="M:Nemerle.Compiler.FixedType.get_TypeInfo" />
    <member name="P:Nemerle.Compiler.FixedType.TypeInfo" />
    <member name="M:Nemerle.Compiler.FixedType.ConstructFunctionType(Nemerle.Core.list{Nemerle.Compiler.FixedType},Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.FixedType.ConstructFunctionType(Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.FixedType.ConstructFunctionType(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.FixedType.GetFunctionArguments" />
    <member name="M:Nemerle.Compiler.FixedType.GetUnfixedFunctionArguments" />
    <member name="M:Nemerle.Compiler.FixedType.AccessibilityIntersect(Nemerle.Compiler.Accessibility,Nemerle.Compiler.Accessibility)" />
    <member name="M:Nemerle.Compiler.FixedType.CheckAccessibility(Nemerle.Compiler.IMember,Nemerle.Compiler.Accessibility)">
      <summary>
        <para>Check if [access] doesn't grant more access than any of tycons in
        [this].  The [what] parameter is used only for error messages.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.TypeOfMember(Nemerle.Compiler.IMember)">
      <summary>
        <para>Get type of member when referenced on value of the current type,
 which has to be fixed.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.ConstructSubstForTypeInfo(Nemerle.Compiler.TypeInfo)">
      <summary>
        <para>Returns substitution which should be applied to types of members of $from in order to get their
 instatiation in $this, like  SCG.List[int].ConstructSubstForTypeInfo (SCG.ICollection) --&gt; { T := int }

</para>
      </summary> <remarks><para>It supports only FixedType.Class

</para></remarks></member>
    <member name="M:Nemerle.Compiler.FixedType.TypeOfMethodWithTyparms(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.FixedType.TypeOfMethod(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.FixedType.Expand">
      <summary>
        <para>This is a hack used in external/Codec.n to expand type aliases
        in imported types.  NTE won't generate aliases there, so it shouldn't
        be needed later.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType.GetInstantiatedSuperType(Nemerle.Compiler.TypeInfo)">
      <summary>
        <para>Get the exact instantiation upon which [this] implements [super_type].

</para>
      </summary>    <remarks><para>For example for:
      class Bar[X, Y] { }
      class Foo[T] : Bar[int, list[T]] { }
    the call:
      Foo[string].GetInstantiatedSuperType(Bar)
    will return:
      Bar[int, list[string]]

</para></remarks></member>
    <member name="M:Nemerle.Compiler.FixedType.FunReturnTypeAndParms" />
    <member name="M:Nemerle.Compiler.FixedType.FunReturnTypeAndParms(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.FixedType.FunParamsTypes(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.FixedType.SigRequire(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.FixedType.TrySigRequire(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.FixedType.Iter(Nemerle.Builtins.FunctionVoid{Nemerle.Compiler.FixedType})" />
    <member name="M:Nemerle.Compiler.FixedType.Validate" />
    <member name="M:Nemerle.Compiler.FixedType.Require(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.FixedType.Provide(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.FixedType.Provide(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.FixedType.Fix" />
    <member name="M:Nemerle.Compiler.FixedType.get_FixedValue" />
    <member name="P:Nemerle.Compiler.FixedType.FixedValue" />
    <member name="M:Nemerle.Compiler.FixedType.IsAccessibleFrom(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.FixedType.#ctor" />
    <member name="M:Nemerle.Compiler.FixedType.MakePointerType" />
    <member name="M:Nemerle.Compiler.FixedType._N_GetVariantCode">
      <summary>
        <para>Represent top-level type constructor for a given type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.FixedType._N_GetVariantCodeSafe(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.FixedType._N_GetVariantCodeObject(System.Object)" />
    <member name="T:Nemerle.Compiler.FixedType.Class">
      <summary>
        <para>Represent a class type with given type parameters, like "string" or "list[int]".

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.StaticTypeVarRef">
      <summary>
        <para>In code like:
      class Foo[T] { bar : list[T]; }
   The "T" in "list[T]" would be represented by a StaticTypeVarRef.
   You can get StaticTypeVar objects from the type builder of Foo class.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.Fun">
      <summary>
        <para>Represent a function type "from -&gt; to".
   If the function takes more than one parameter, the "from" is a tuple. */

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.Tuple">
      <summary>
        <para>Represent a tuple, like "int * string * list[float]"

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.Array">
      <summary>
        <para>Represent an array type, rank refers to the number of dimensions.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.Ref">
      <summary>
        <para>These are used in signatures of functions taking ref/out parameter.
   For example in:
      foo (x : ref int) : void
   the x has type "Ref(Class(InternalType.Int32_tc,[]))".
   They are not used in function types though!

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.Out" />
    <member name="T:Nemerle.Compiler.FixedType.Void">
      <summary>
        <para>Represent the unit type.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.FixedType.Intersection">
      <summary>
        <para>Used when given value is required to have all the listed types.

</para>
      </summary>       <remarks><para>Invariant 1: the types listed cannot be in the subtyping relation
       pairwise.

</para>       <para>Invariant 2: there can be only Class() objects inside.

</para>       <para>This type is not expressible in the .NET type system directly,
       it can be however expressed with type variable bounds in some
       cases. *
</para></remarks></member>
    <member name="T:Nemerle.Compiler.OverloadPossibility">
      <summary>
        <para>Represents a single possibility in the overloading resulution process.
      It is used in the TExpr.Overloaded node.
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.OverloadPossibility.expr" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.ty" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.member" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.solver" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.is_static" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.from" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.method_typarms" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.local_context" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.generic_specifier" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.IsBaseCall" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.VarArgs" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.ExtensionMethodObject" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.IsConstantObject" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.UsedDefaultParms" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.UsedLastTime" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.permutation_array" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.formal_types" />
    <member name="F:Nemerle.Compiler.OverloadPossibility.did_mambo_jumbo" />
    <member name="F:Nemerle.Compiler.OverloadPossibility._N_ResolvedCallParameters_15651" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_ResolvedCallParameters" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.set_ResolvedCallParameters(Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.ResolvedCallParameters" />
    <member name="F:Nemerle.Compiler.OverloadPossibility._N_IsAllNestedDelayedTypingResolved_15658" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_IsAllNestedDelayedTypingResolved" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.set_IsAllNestedDelayedTypingResolved(System.Boolean)" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.IsAllNestedDelayedTypingResolved" />
    <member name="F:Nemerle.Compiler.OverloadPossibility._N_IsNeedTupleConvertion_15665" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_IsNeedTupleConvertion" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.set_IsNeedTupleConvertion(System.Boolean)" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.IsNeedTupleConvertion" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.#ctor(Nemerle.Compiler.Typer,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.IMember,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_Type" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.Type" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_Member" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.Member" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_From" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.From" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_StillPossible" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.StillPossible">
      <summary>
        <para>Tell if this overload is still possible in the current solver.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.OverloadPossibility.SetGenericSpecifier(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.CheckGenericSpecifier" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.Compile">
      <summary>
        <para>Enforce this particular overloading possibility in the current solver.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.OverloadPossibility.ToString" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.Equals(Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.GetHashCode" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.ResetOverloadSelectionStuff" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.set_PermutationArray(System.Int32[])" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.PermutationArray" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_DidMamboJumbo" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.DidMamboJumbo" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_IsGeneric" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.IsGeneric" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_FormalTypes" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.set_FormalTypes(Nemerle.Compiler.TypeVar[])" />
    <member name="P:Nemerle.Compiler.OverloadPossibility.FormalTypes" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.Unique(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility})" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.OnlyPossible(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility},Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typer)">
      <summary>
        <para>Filter out impossible overloads from the list.  If there are no
 possible overloads and we are in the error reporting mode, present
 an appropriate error message.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_Manager">
      <summary>
        <para>Represents a single possibility in the overloading resulution process.
      It is used in the TExpr.Overloaded node.
</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.OverloadPossibility.Manager" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_InternalType">
      <summary>
        <para>Represents a single possibility in the overloading resulution process.
      It is used in the TExpr.Overloaded node.
</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.OverloadPossibility.InternalType" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.get_SystemTypeCache">
      <summary>
        <para>Represents a single possibility in the overloading resulution process.
      It is used in the TExpr.Overloaded node.
</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.OverloadPossibility.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.__fake">
      <summary>
        <para>Represents a single possibility in the overloading resulution process.
      It is used in the TExpr.Overloaded node.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.OverloadPossibility.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.OverloadPossibility.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.RestartInErrorMode" />
    <member name="M:Nemerle.Compiler.RestartInErrorMode.#ctor" />
    <member name="M:Nemerle.Compiler.RestartInErrorMode.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Solver">
      <summary>
        <para>A constraint solver.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Solver._N_add_supertypes_103763(Nemerle.Compiler.Solver._N_closureOf_sum_list_103751,Nemerle.Collections.Set{Nemerle.Compiler.TypeInfo})" />
    <member name="M:Nemerle.Compiler.Solver._N_sum_list_103745(Nemerle.Compiler.Solver._N_closureOf_Sum_103733,Nemerle.Core.list{Nemerle.Compiler.FixedType},System.Boolean)" />
    <member name="M:Nemerle.Compiler.Solver._N_intersect_classes_103510(Nemerle.Compiler.Solver._N_closureOf_Intersect_103502,Nemerle.Compiler.FixedType.Class,Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.Solver.PushState">
      <summary>
        <para>Store current constraint state.

</para>
      </summary>        <remarks><para>Called before some speculative type checking fragment, like
        overload resolution.
</para></remarks></member>
    <member name="M:Nemerle.Compiler.Solver.PopState">
      <summary>
        <para>Go one constraint state back.

</para>
      </summary>        <remarks><para>This function rollbacks all constraints made in current state,
        and also clear the error state if it was in
</para></remarks></member>
    <member name="M:Nemerle.Compiler.Solver.Unwind" />
    <member name="M:Nemerle.Compiler.Solver.CanEnterPossiblyLooping" />
    <member name="M:Nemerle.Compiler.Solver.LeavePossiblyLooping" />
    <member name="M:Nemerle.Compiler.Solver.FreshTyVar" />
    <member name="M:Nemerle.Compiler.Solver.FreshTypeVar">
      <summary>
        <para>Generate a new type variable.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Solver.MonoTypes(Nemerle.Core.list{Nemerle.Compiler.FixedType})" />
    <member name="M:Nemerle.Compiler.Solver.FixedValues(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Solver.Fix(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Solver.PushRank">
      <summary>
        <para>Increment current type variable rank.

</para>
      </summary>        <remarks><para>Called before typing of a local function.
</para></remarks></member>
    <member name="M:Nemerle.Compiler.Solver.PopRank">
      <summary>
        <para>Restore previous type variable rank.

</para>
      </summary>        <remarks><para>Called after typing of a local function.
</para></remarks></member>
    <member name="M:Nemerle.Compiler.Solver.Enqueue(Nemerle.Builtins.FunctionVoid)" />
    <member name="F:Nemerle.Compiler.Solver.comp_queue" />
    <member name="F:Nemerle.Compiler.Solver.locked" />
    <member name="M:Nemerle.Compiler.Solver.Intersect(Nemerle.Compiler.FixedType,Nemerle.Compiler.FixedType)">
      <summary>
        <para>Return the biggest type [t] such that [t &lt;: t1] and [t &lt;: t2].
        It doesn't work for separated types.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Solver.Sum(Nemerle.Compiler.FixedType,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Solver.get_CurrentMessenger" />
    <member name="P:Nemerle.Compiler.Solver.CurrentMessenger" />
    <member name="M:Nemerle.Compiler.Solver.get_IsTopLevel" />
    <member name="P:Nemerle.Compiler.Solver.IsTopLevel" />
    <member name="M:Nemerle.Compiler.Solver.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="F:Nemerle.Compiler.Solver.dt_store" />
    <member name="F:Nemerle.Compiler.Solver.dt_stack" />
    <member name="F:Nemerle.Compiler.Solver.serial_stack" />
    <member name="F:Nemerle.Compiler.Solver.serial_stack_top" />
    <member name="F:Nemerle.Compiler.Solver.top_serial" />
    <member name="F:Nemerle.Compiler.Solver.last_serial" />
    <member name="F:Nemerle.Compiler.Solver.possibly_looping" />
    <member name="F:Nemerle.Compiler.Solver.CyclicTypeCount" />
    <member name="F:Nemerle.Compiler.Solver.InUse" />
    <member name="F:Nemerle.Compiler.Solver.current_rank" />
    <member name="F:Nemerle.Compiler.Solver.messenger" />
    <member name="F:Nemerle.Compiler.Solver.Manager">
      <summary>
        <para>A constraint solver.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Solver.get_InternalType" />
    <member name="P:Nemerle.Compiler.Solver.InternalType" />
    <member name="M:Nemerle.Compiler.Solver.get_SystemTypeCache">
      <summary>
        <para>A constraint solver.
</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.Solver.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.Solver.__fake">
      <summary>
        <para>A constraint solver.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Solver.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.StaticTypeVar">
      <summary>
        <para>Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.StaticTypeVar._N_check_constraints_104595(Nemerle.Compiler.FixedType,Nemerle.Builtins.Function{Nemerle.Compiler.FixedType,System.Boolean})" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.gtype" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.id" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.name" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.special" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.constraints" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.current_type" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.current_method" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.ToString" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.DebugToString" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_Constraints" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.set_Constraints(Nemerle.Core.list{Nemerle.Compiler.FixedType})" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.Constraints">
      <summary>
        <para>Return lower constraints on given type variable (that is the
 [where] clauses). The constraints should be already normalized (that
 is they should follow FixedType.Intersection invariants).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_LowerBound" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.LowerBound" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_Name" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.Name" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_Id" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.Id" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.#ctor(Nemerle.Compiler.ManagerClass,System.String)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.#ctor(Nemerle.Compiler.StaticTypeVar)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.#ctor(Nemerle.Compiler.ManagerClass,System.String,System.Type)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.GetSystemType" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.ApplySubst(Nemerle.Compiler.Subst)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_SpecialConstraints" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.SpecialConstraints" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.SetConstraints(System.Reflection.GenericParameterAttributes,Nemerle.Core.list{Nemerle.Compiler.FixedType})" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_IsValueType" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.IsValueType" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_HasDefaultConstructor" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.HasDefaultConstructor" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_IsCovariant" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.IsCovariant" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_IsContravariant" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.IsContravariant" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.Equals(Nemerle.Compiler.StaticTypeVar)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.CopyList(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar})">
      <summary>
        <para>Copy a list of type parameters for use in a new type.
        Also return a substitution from the old to the new list.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.StaticTypeVar.SetGenericBuilder(System.Reflection.Emit.GenericTypeParameterBuilder)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.UpdateConstraints" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.CheckConstraints(Nemerle.Compiler.TypeVar,System.Object)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.TryCheckConstraints(Nemerle.Compiler.TypeVar,System.Object,System.Boolean)">
      <summary>
        <para>Check if [tv] fullfills [this]'s constraints.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_HasConstraints" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.HasConstraints" />
    <member name="F:Nemerle.Compiler.StaticTypeVar.Manager">
      <summary>
        <para>Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_InternalType" />
    <member name="P:Nemerle.Compiler.StaticTypeVar.InternalType" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.get_SystemTypeCache">
      <summary>
        <para>Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types.
</para>
      </summary>
    </member>
    <member name="P:Nemerle.Compiler.StaticTypeVar.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.__fake">
      <summary>
        <para>Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.StaticTypeVar.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.StaticTypeVar.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Subst">
      <summary>
        <para>Represent a substitution, from static type variables to types
      (represented by plain type variables).
</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Subst.map" />
    <member name="F:Nemerle.Compiler.Subst.empty" />
    <member name="M:Nemerle.Compiler.Subst.#ctor" />
    <member name="M:Nemerle.Compiler.Subst.ToString" />
    <member name="M:Nemerle.Compiler.Subst.get_IsEmpty" />
    <member name="P:Nemerle.Compiler.Subst.IsEmpty" />
    <member name="M:Nemerle.Compiler.Subst.Add(Nemerle.Compiler.StaticTypeVar,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Subst.AddList(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar},Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Subst.Copy" />
    <member name="M:Nemerle.Compiler.Subst.MonoApply(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Subst.ApplyTv(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Subst.Apply(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Subst.AddSubst(Nemerle.Compiler.Subst)">
      <summary>
        <para>[other] has to be independent, that is [this] and [other] shall not
        share variables, or use variables from the other one in result
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Subst.Combine(Nemerle.Compiler.Subst)">
      <summary>
        <para>Used for combining T3 substitutions together.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Subst.Fresh(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar})" />
    <member name="M:Nemerle.Compiler.Subst.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.TraverseStateFlag" />
    <member name="F:Nemerle.Compiler.TraverseStateFlag.value__" />
    <member name="F:Nemerle.Compiler.TraverseStateFlag.None" />
    <member name="F:Nemerle.Compiler.TraverseStateFlag.FullHistory" />
    <member name="F:Nemerle.Compiler.TraverseStateFlag.Breaked" />
    <member name="F:Nemerle.Compiler.TraverseStateFlag.NoSkip" />
    <member name="T:Nemerle.Compiler.TraverseContext">
      <summary>
        <para>Class containing Traverse context for current traversing expression
 </para>
      </summary>

</member>
    <member name="F:Nemerle.Compiler.TraverseContext.nexpr" />
    <member name="F:Nemerle.Compiler.TraverseContext.flags" />
    <member name="M:Nemerle.Compiler.TraverseContext.get_Data" />
    <member name="M:Nemerle.Compiler.TraverseContext.set_Data(System.Object)" />
    <member name="P:Nemerle.Compiler.TraverseContext.Data">
      <summary>
        <para>Data storage, this maybe useful if you want to save data while traversing expressions, and access it after traversing
 </para>
      </summary>

</member>
    <member name="F:Nemerle.Compiler.TraverseContext.pushed" />
    <member name="M:Nemerle.Compiler.TraverseContext.Next">
      <summary>
        <para>called for next traversing, and creates new context
 </para>
      </summary>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext.get_IsBreaked" />
    <member name="P:Nemerle.Compiler.TraverseContext.IsBreaked">
      <summary>
        <para>Gives information that traversing is breaked
</para>
      </summary>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext.get_NoSkip" />
    <member name="P:Nemerle.Compiler.TraverseContext.NoSkip">
      <summary>
        <para>No skip mode, every returned node is traversed normally, rather than skipped
</para>
      </summary>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext.Push">
      <summary>
        <para>Push context manually
 </para>
      </summary>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext.Break">
      <summary>
        <para>Breaks expression traversing after this expression, after this traversing aborts and returns expression
 processed to this point
 </para>
      </summary>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext.#ctor(Nemerle.Compiler.TraverseContext.CommonFlags)">
      <summary>
        <para>Constructor
 </para>
      </summary>
 <param name="full_hist"><para>indicates that need full context history saving</para></param>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext.#ctor(Nemerle.Compiler.TraverseStateFlag)" />
    <member name="M:Nemerle.Compiler.TraverseContext._N_GetVariantCode">
      <summary>
        <para>Class containing Traverse context for current traversing expression
 </para>
      </summary>

</member>
    <member name="M:Nemerle.Compiler.TraverseContext._N_GetVariantCodeSafe(Nemerle.Compiler.TraverseContext)" />
    <member name="M:Nemerle.Compiler.TraverseContext._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.TraverseContext.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.TraverseContext.Top">
      <summary>
        <para>top context, in begin of traversing process
 </para>
      </summary>

</member>
    <member name="T:Nemerle.Compiler.TraverseContext.Uncached">
      <summary>
        <para>not saved context, in manual mode (see TraverseExprWithContext comments), when not manual saved
 </para>
      </summary>

</member>
    <member name="T:Nemerle.Compiler.TraverseContext.Expr">
      <summary>
      </summary>

</member>
    <member name="T:Nemerle.Compiler.TraverseContext.CommonFlags" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration" />
    <member name="M:Nemerle.Compiler.Typedtree.TypeDeclaration.#ctor" />
    <member name="M:Nemerle.Compiler.Typedtree.TypeDeclaration.ToString" />
    <member name="M:Nemerle.Compiler.Typedtree.TypeDeclaration._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Typedtree.TypeDeclaration._N_GetVariantCodeSafe(Nemerle.Compiler.Typedtree.TypeDeclaration)" />
    <member name="M:Nemerle.Compiler.Typedtree.TypeDeclaration._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Typedtree.TypeDeclaration.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration.Class" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration.Alias" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration.Interface" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration.Variant" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration.VariantOption" />
    <member name="T:Nemerle.Compiler.Typedtree.TypeDeclaration.Enum" />
    <member name="T:Nemerle.Compiler.Typedtree.TParameter" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_AttributesAndModifiers" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.AttributesAndModifiers" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_Modifiers" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.Modifiers" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_CustomAttributes" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.CustomAttributes" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_Name" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.Name" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter._N_NameLocation_16093" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_NameLocation" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.set_NameLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.NameLocation" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_Type" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.Type" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_TypeLocation" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.set_TypeLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.TypeLocation" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_Color" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.Color" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_Kind" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.Kind" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_DefaultValue" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.DefaultValue" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_Declaration" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.Declaration" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter._N_PatternHack_16120" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_PatternHack" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.set_PatternHack(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.PatternHack" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_HasDefaultValue" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.HasDefaultValue" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.name" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.color" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.ty" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.ty_loc" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.kind" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.modifiers" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.required_modifiers" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.optional_modifiers" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.default_value" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.decl" />
    <member name="F:Nemerle.Compiler.Typedtree.TParameter.builder" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.#ctor(Nemerle.Compiler.Location,System.String,Nemerle.Compiler.Location,System.Int32,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Location,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Typedtree.ParmKind,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.#ctor(System.String,System.Int32,Nemerle.Compiler.TypeVar,Nemerle.Compiler.AttributesAndModifiers,Nemerle.Compiler.Typedtree.ParmKind)" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.Clone" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.GetSystemType" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.GetParsedName" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.AsParsed" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.get_ReferencingExpr" />
    <member name="P:Nemerle.Compiler.Typedtree.TParameter.ReferencingExpr" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.DefaultValueAsTExpr(Nemerle.Compiler.Solver)" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.GetLocalDefaultValueFromModifiers(Nemerle.Compiler.Typer)" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.GetLocalDefaultValueFromExpr(Nemerle.Compiler.Typer,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.GetDefaultValueFromModifiers(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.TypeVarEnv)" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.GetDefaultValueFromExpr(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.TypeVarEnv,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.ToString" />
    <member name="M:Nemerle.Compiler.Typedtree.TParameter.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typedtree.FunctionUsage" />
    <member name="F:Nemerle.Compiler.Typedtree.FunctionUsage.value__" />
    <member name="F:Nemerle.Compiler.Typedtree.FunctionUsage.NotUsed" />
    <member name="F:Nemerle.Compiler.Typedtree.FunctionUsage.UsedJustOnce" />
    <member name="F:Nemerle.Compiler.Typedtree.FunctionUsage.Used" />
    <member name="F:Nemerle.Compiler.Typedtree.FunctionUsage.UsedAsFirstClass" />
    <member name="T:Nemerle.Compiler.Typedtree.TFunHeader" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_Name_16170" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_Name" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_Name(System.String)" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.Name" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_ReturnType_16177" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ReturnType" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_ReturnType(Nemerle.Compiler.TypeVar)" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ReturnType" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_ReturnTypeLocation_16184" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ReturnTypeLocation" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_ReturnTypeLocation(Nemerle.Compiler.Location)" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ReturnTypeLocation" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_Parameters_16191" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_Parameters" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_Parameters(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TParameter})" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.Parameters" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_TypeParameters_16198" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_TypeParameters" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_TypeParameters(Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar})" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.TypeParameters" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_TypeVarEnv" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.TypeVarEnv" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_Body" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.Body" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ClosureVars" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ClosureVars" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_Declaration" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.Declaration" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_Parsed_16217" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_Parsed" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_Parsed(Nemerle.Compiler.Parsetree.Function_decl)" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.Parsed" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_RetTypeLoc" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.RetTypeLoc" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_RetType" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.RetType" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_name" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.name" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.id" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ret_type" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ret_type" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ret_type_loc" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ret_type_loc" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_parms" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.parms" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_typarms" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.typarms" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.tenv" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.ret_type_required_modifiers" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.ret_type_optional_modifiers" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.usage" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.body" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.has_1st_class_child" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.cannot_inline" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader._N_ConvertToLoopWithClosure_16253" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ConvertToLoopWithClosure" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.set_ConvertToLoopWithClosure(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ConvertToLoopWithClosure" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.closure_vars">
      <summary>
        <para>local values defined in this function, which are closurised (used by children)

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.decl">
      <summary>
        <para>local value, which is declaring this function (valid for local funs)

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.all_locals" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.children_funs" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.uses_try_block" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.yield_type" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.is_in_closure_of" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.used_closures" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.static_method" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.typarms_to_pass" />
    <member name="F:Nemerle.Compiler.Typedtree.TFunHeader.closure_type" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.#ctor(Nemerle.Compiler.Location,System.String,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Location,Nemerle.Core.list{Nemerle.Compiler.Typedtree.TParameter},Nemerle.Core.list{Nemerle.Compiler.StaticTypeVar},Nemerle.Compiler.TypeVarEnv)" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.Reset" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.CompareTo(Nemerle.Compiler.Typedtree.TFunHeader)" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.GetParents">
      <summary>
        <para>Retrieves functions in which current function is nested. Empty list if
  this is a plain method of some class.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.ToString" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.GetRetTypeRequiredModifiers" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.GetRetTypeOptionalModifiers" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.GetParamTypeRequiredModifiers" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.GetParamTypeOptionalModifiers" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ParametersDeclarations" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ParametersDeclarations" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.get_ParametersReferences" />
    <member name="P:Nemerle.Compiler.Typedtree.TFunHeader.ParametersReferences" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.CreateAliasMethod(Nemerle.Compiler.NemerleModifiers,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Subst)" />
    <member name="M:Nemerle.Compiler.Typedtree.TFunHeader.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern._N_do_walk_106188(Nemerle.Compiler.Typedtree.Pattern._N_closureOf_Walk_106178,Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="F:Nemerle.Compiler.Typedtree.Pattern.ty" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.#ctor" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.#ctor(Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.GetSystemType" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.get_Type" />
    <member name="P:Nemerle.Compiler.Typedtree.Pattern.Type" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.StripEnums" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.Walk(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.Typedtree.Pattern})">
      <summary>
        <para>Walk [this] with the function [f].

</para>
      </summary>        <remarks><para>The function is applied to each and every pattern node.

</para>        <para>If [f] returns a value different than [null], the value is
        returned, from this [Walk] function.

</para>        <para>If it returns [null], the walking function descends into tree
        elements in a map-like fashion.

</para>        <para>If the type of pattern returned was to be [null], it is set to
        the type of the original pattern.

</para>        <para>This function implements the visitor pattern.
</para></remarks></member>
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.ToString" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern._N_GetVariantCodeSafe(Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.#ctor(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typedtree.Pattern.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.TypeVar)" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Wildcard" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.As" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.HasType" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Tuple" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Record" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Application" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Enum" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Literal" />
    <member name="T:Nemerle.Compiler.Typedtree.Pattern.Error" />
    <member name="T:Nemerle.Compiler.Typedtree.Try_case" />
    <member name="M:Nemerle.Compiler.Typedtree.Try_case._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Typedtree.Try_case._N_GetVariantCodeSafe(Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.Typedtree.Try_case._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Typedtree.Try_case.#ctor" />
    <member name="M:Nemerle.Compiler.Typedtree.Try_case.#ctor(Nemerle.Compiler.Location)" />
    <member name="T:Nemerle.Compiler.Typedtree.Try_case.Fault" />
    <member name="T:Nemerle.Compiler.Typedtree.Try_case.Catch" />
    <member name="T:Nemerle.Compiler.Typedtree.Try_case.Filter" />
    <member name="T:Nemerle.Compiler.Typedtree.Match_case" />
    <member name="F:Nemerle.Compiler.Typedtree.Match_case.patterns" />
    <member name="F:Nemerle.Compiler.Typedtree.Match_case.body" />
    <member name="F:Nemerle.Compiler.Typedtree.Match_case.disable_warnings" />
    <member name="M:Nemerle.Compiler.Typedtree.Match_case.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.Typedtree.Match_case.#ctor(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr}}}},Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typedtree.Match_case.#ctor(Nemerle.Compiler.Location,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Typedtree.Pattern,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.LocalValue,Nemerle.Compiler.Typedtree.TExpr}}}},Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind" />
    <member name="M:Nemerle.Compiler.Typedtree.ConversionKind.#ctor" />
    <member name="M:Nemerle.Compiler.Typedtree.ConversionKind._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Typedtree.ConversionKind._N_GetVariantCodeSafe(Nemerle.Compiler.Typedtree.ConversionKind)" />
    <member name="M:Nemerle.Compiler.Typedtree.ConversionKind._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Typedtree.ConversionKind.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.MethodCall" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.IL" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.UpCast" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.DownCast" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.Implicit" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.IgnoreValue" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.Unspecified" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.GenericSim" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.Boxing" />
    <member name="T:Nemerle.Compiler.Typedtree.ConversionKind.Nop" />
    <member name="T:Nemerle.Compiler.Typedtree.TExprFlags" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.value__" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.IsAssigned" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.Visited" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.Throws" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.ThrowsComputed" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.NeedAddress" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.Addressable" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.AddressableComputed" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.JumpTarget" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.Constrained" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.GenerateTail" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.SkipWriteCheck" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.NeedsEmptyStack" />
    <member name="F:Nemerle.Compiler.Typedtree.TExprFlags.NeedsEmptyStackComputed" />
    <member name="T:Nemerle.Compiler.Typedtree.CacheDesc" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc._N_get_ref_106896(Nemerle.Compiler.Typedtree.CacheDesc._N_closureOf_Finalize_106838,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc._N_cache_obj_106884(Nemerle.Compiler.Typedtree.CacheDesc._N_closureOf_Finalize_106838,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc._N_unfold_106852(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="F:Nemerle.Compiler.Typedtree.CacheDesc.p_indices" />
    <member name="F:Nemerle.Compiler.Typedtree.CacheDesc.p_expr" />
    <member name="F:Nemerle.Compiler.Typedtree.CacheDesc.t_indices" />
    <member name="F:Nemerle.Compiler.Typedtree.CacheDesc.t_expr" />
    <member name="F:Nemerle.Compiler.Typedtree.CacheDesc.ref_is" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.get_Type" />
    <member name="P:Nemerle.Compiler.Typedtree.CacheDesc.Type" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.Resolve(Nemerle.Compiler.Typer)" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.Finalize(Nemerle.Compiler.Typedtree.TFunHeader,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.#ctor(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.get_PExpr" />
    <member name="P:Nemerle.Compiler.Typedtree.CacheDesc.PExpr" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.get_TExpr" />
    <member name="P:Nemerle.Compiler.Typedtree.CacheDesc.TExpr" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.get_RefIs" />
    <member name="P:Nemerle.Compiler.Typedtree.CacheDesc.RefIs" />
    <member name="M:Nemerle.Compiler.Typedtree.CacheDesc.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr" />
    <member name="F:Nemerle.Compiler.Typedtree.TExpr._ty" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_ty" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_ty(Nemerle.Compiler.TypeVar)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.ty" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_Type" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_Type(Nemerle.Compiler.TypeVar)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.Type" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.CheckAfterT2" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.CheckAfterT3" />
    <member name="F:Nemerle.Compiler.Typedtree.TExpr.flags" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_Throws" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_Throws(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.Throws" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_NeedsEmptyStack" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_NeedsEmptyStack(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.NeedsEmptyStack" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_NeedsConstrained" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_NeedsConstrained(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.NeedsConstrained" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_IsAddressable" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_IsAddressable(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.IsAddressable" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_NeedAddress" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.NeedAddress" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.setNeedAddress(System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.GetType(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.TryInitType(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.FixedType" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.GetSystemType" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.#ctor" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.#ctor(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.#ctor(Nemerle.Compiler.Location,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.ToString" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.Copy" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.do_copy(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.walk(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr},Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.null_walk(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr},Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.walks(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr},Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.do_walk(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr},Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.Walk(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr})">
      <summary>
        <para>Walk [this] with the function [f].

</para>
      </summary>        <remarks><para>The function is applied to each and every expression node.

</para>        <para>If [f] returns a value different than [null], the value is
        returned, from this [Walk] function.

</para>        <para>If it returns [null], the walking function descends into tree
        elements in a map-like fashion.

</para>        <para>If the type of expression returned was to be [null], it is set
        to the type of the original expression.

</para>        <para>This function implements the visitor pattern.
</para></remarks></member>
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.BoolLiteral(Nemerle.Compiler.ManagerClass,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.TrueLiteral(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.FalseLiteral(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_SkipWriteCheck" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_SkipWriteCheck(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.SkipWriteCheck" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_GenerateTail" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_GenerateTail(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.GenerateTail" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_Visited" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_Visited(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.Visited" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_JumpTarget" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_JumpTarget(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.JumpTarget" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.get_IsAssigned" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr.set_IsAssigned(System.Boolean)" />
    <member name="P:Nemerle.Compiler.Typedtree.TExpr.IsAssigned" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr._N_GetVariantCodeSafe(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.TExpr._N_GetVariantCodeObject(System.Object)" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.StaticRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.LocalRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.ImplicitValueTypeCtor" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.FieldMember" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.MethodRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Call" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Assign" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.DefValIn" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Throw" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.TryFinally" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Try" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Literal" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.This" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Base" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.TypeConversion" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Sequence" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Tuple" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Array" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.TypeOf" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.MethodOf" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.CtorOf" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.FieldOf" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.ClosureObjectOf" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.ClosureFieldOf" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.ArrayIndexer" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.PointerIndexer" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.TupleIndexer" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.OpCode" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.MacroEnvelope" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.PropertyMember" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.StaticPropertyRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.EventMember" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.StaticEventRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.ConstantObjectRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Block" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Delayed" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Cache" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.CacheRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Error" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.DefFunctionsIn" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Match" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.SelfTailCall" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.LocalFunRef" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.MethodAddress" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.MultipleAssign" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Label" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Goto" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.DefaultValue" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.If" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.HasType" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Switch" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.DebugInfo" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Def" />
    <member name="T:Nemerle.Compiler.Typedtree.TExpr.Use" />
    <member name="T:Nemerle.Compiler.Typedtree.ParmKind" />
    <member name="F:Nemerle.Compiler.Typedtree.ParmKind.value__" />
    <member name="F:Nemerle.Compiler.Typedtree.ParmKind.Normal" />
    <member name="F:Nemerle.Compiler.Typedtree.ParmKind.Ref" />
    <member name="F:Nemerle.Compiler.Typedtree.ParmKind.Out" />
    <member name="T:Nemerle.Compiler.Typedtree.Parm" />
    <member name="F:Nemerle.Compiler.Typedtree.Parm.kind" />
    <member name="F:Nemerle.Compiler.Typedtree.Parm.expr" />
    <member name="F:Nemerle.Compiler.Typedtree.Parm.name" />
    <member name="F:Nemerle.Compiler.Typedtree.Parm.IsByDefault" />
    <member name="F:Nemerle.Compiler.Typedtree.Parm.required_type" />
    <member name="F:Nemerle.Compiler.Typedtree.Parm._N_NameToComplete_17326" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.get_NameToComplete" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.set_NameToComplete(System.String)" />
    <member name="P:Nemerle.Compiler.Typedtree.Parm.NameToComplete" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.#ctor(Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.#ctor(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.ToString" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.Typedtree.Parm.#ctor(Nemerle.Compiler.Typedtree.ParmKind,Nemerle.Compiler.Typedtree.TExpr,System.String,Nemerle.Compiler.TypeVar)" />
    <member name="T:Nemerle.Compiler.Typer" />
    <member name="M:Nemerle.Compiler.Typer._N_le_117352``1(Nemerle.Compiler.Typer._N_closureOf_MinimalTypesWithImplicit_117344{``0},Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer._N_makeArgsTypes_117014(Nemerle.Compiler.Typer._N_closureOf_IsBetterOverload_116959,Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer._N_getBetterList_116837(Nemerle.Compiler.Typer._N_closureOf_IsBetterOverload_116808,Nemerle.Compiler.TypeVar[],Nemerle.Compiler.TypeVar[])" />
    <member name="M:Nemerle.Compiler.Typer._N_real_check_116672(Nemerle.Compiler.Typer._N_closureOf_IsBetterType_116664,Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer._N_print_error_message_116250(Nemerle.Compiler.Typer._N_closureOf_ResolveOverload_116214,Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer._N_transform_parms_115991(Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Typer._N_checkMatch_115627(Nemerle.Compiler.Typer._N_closureOf_TypeMatch_115580)" />
    <member name="M:Nemerle.Compiler.Typer._N_decode_assigns_115435(Nemerle.Compiler.Typer._N_closureOf_TypePatterns_115418,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Typer._N_decode_when_115425(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr}})" />
    <member name="M:Nemerle.Compiler.Typer._N_is_void_115262(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer._N_is_enum_115252(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer._N_is_strange_type_115242(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer._N_get_convertion_operators_115216(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer._N_refout_114959(Nemerle.Compiler.Typer._N_closureOf_TypeCall_114951,System.String,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer._N_tryInterpretAsEnumField_114571(Nemerle.Compiler.Typer._N_closureOf_TypeNameFull_114467,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer._N_lookup_114112(Nemerle.Compiler.Typer._N_closureOf_TypeMember_114077,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer._N_single_113865(Nemerle.Compiler.Typer._N_closureOf_InterpretGlobal_113853,Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.Typer._N_make_overload_113820(Nemerle.Compiler.Typer._N_closureOf_ConstructMethodOverload_113794)" />
    <member name="M:Nemerle.Compiler.Typer._N_loop_113598(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.Typer._N_flatten_113174(Nemerle.Compiler.Typer._N_closureOf_TypeArray_113129,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{System.Int32})" />
    <member name="M:Nemerle.Compiler.Typer._N_dimensions_113158(Nemerle.Compiler.Typer._N_closureOf_TypeArray_113129,Nemerle.Compiler.Parsetree.PExpr,System.Int32)" />
    <member name="M:Nemerle.Compiler.Typer._N_expr_list_flatten_and_count_113139(Nemerle.Compiler.Typer._N_closureOf_TypeArray_113129,Nemerle.Compiler.Parsetree.PExpr,System.Int32)" />
    <member name="M:Nemerle.Compiler.Typer._N_warn_112866(Nemerle.Compiler.Typer._N_closureOf_TypeLocalDefinition_112853,System.String,System.String)" />
    <member name="M:Nemerle.Compiler.Typer._N_truncate_112771(Nemerle.Compiler.Typer._N_closureOf_truncateLoc_112749,Nemerle.Compiler.Typer._N_closureOf_GetDebugLocation_112686,System.Int32,System.Int32,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer._N_skip_112693(Nemerle.Compiler.Location,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.Location,Nemerle.Compiler.Parsetree.PExpr}})" />
    <member name="M:Nemerle.Compiler.Typer._N_list_of_zeros_112522(Nemerle.Compiler.Typer._N_closureOf_DoType_111913,System.UInt64)" />
    <member name="M:Nemerle.Compiler.Typer._N_list_of_zeros_112512(Nemerle.Compiler.Typer._N_closureOf_DoType_111913,System.Int32)" />
    <member name="M:Nemerle.Compiler.Typer._N_has_constraint_112448(Nemerle.Compiler.StaticTypeVar)" />
    <member name="M:Nemerle.Compiler.Typer._N_do_type_conversion_112439(Nemerle.Compiler.Typer._N_closureOf_DoType_111913)" />
    <member name="M:Nemerle.Compiler.Typer._N_loop_112099(Nemerle.Compiler.Typer._N_closureOf_DoType_111913,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Typer._N_resolve_111356(Nemerle.Compiler.Typer._N_closureOf_TryResolveNestedDelayedTyping_111343,System.Collections.Generic.IEnumerable{Nemerle.Compiler.Typer.DelayedTyping},System.Int32,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer._N_addDelegateCtor_111149(Nemerle.Compiler.Typer._N_closureOf_NonLiteralCast_111090,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer._N_fresh_type_110858(Nemerle.Compiler.IMethod)" />
    <member name="F:Nemerle.Compiler.Typer.is_instance_ctor" />
    <member name="F:Nemerle.Compiler.Typer.field_inits_typed" />
    <member name="F:Nemerle.Compiler.Typer.is_method" />
    <member name="F:Nemerle.Compiler.Typer.env" />
    <member name="F:Nemerle.Compiler.Typer.tenv" />
    <member name="F:Nemerle.Compiler.Typer.current_fun" />
    <member name="F:Nemerle.Compiler.Typer.current_type" />
    <member name="F:Nemerle.Compiler.Typer.parent_typer" />
    <member name="F:Nemerle.Compiler.Typer.local_context" />
    <member name="F:Nemerle.Compiler.Typer.messenger" />
    <member name="F:Nemerle.Compiler.Typer.solver" />
    <member name="F:Nemerle.Compiler.Typer.locals_stack" />
    <member name="F:Nemerle.Compiler.Typer.current_method_builder" />
    <member name="F:Nemerle.Compiler.Typer.skip_n_return" />
    <member name="F:Nemerle.Compiler.Typer.inside_yielding_function" />
    <member name="F:Nemerle.Compiler.Typer.yield_labels" />
    <member name="F:Nemerle.Compiler.Typer.return_local" />
    <member name="F:Nemerle.Compiler.Typer.badness_allowed" />
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.MethodBuilder)">
      <summary>
        <para>Prepared for walking through method body typing it.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.TypeVarEnv,Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Prepared as reduced version of typer, ready to be passed to macros
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.GlobalEnv)">
      <summary>
        <para>Prepared as reduced version of typer for typing custom attribute constructors
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder)">
      <summary>
        <para>Prepared as reduced version of typer for typing custom attribute constructors
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.Typer,Nemerle.Compiler.Typedtree.TFunHeader)">
      <summary>
        <para>Prepared for walking through a local function body typing it.
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.Typer.#ctor(Nemerle.Compiler.ManagerClass,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.Typer.GetTopTyper" />
    <member name="M:Nemerle.Compiler.Typer.RunFullTyping" />
    <member name="M:Nemerle.Compiler.Typer.put_in_error_mode(System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.get_TriggerObsoleteWarning" />
    <member name="P:Nemerle.Compiler.Typer.TriggerObsoleteWarning" />
    <member name="M:Nemerle.Compiler.Typer.GetMethodBuilder" />
    <member name="M:Nemerle.Compiler.Typer.MaybeDumpTypedTree(System.String)" />
    <member name="M:Nemerle.Compiler.Typer.InitLocalContext(Nemerle.Compiler.LocalContext)">
      <summary>
        <para>Init local_context and copy parameters into it.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.RunTyper" />
    <member name="M:Nemerle.Compiler.Typer.RunSecondPass(Nemerle.Compiler.MethodBuilder)" />
    <member name="M:Nemerle.Compiler.Typer.get_BadnessAllowed" />
    <member name="P:Nemerle.Compiler.Typer.BadnessAllowed" />
    <member name="M:Nemerle.Compiler.Typer.RunDelayedTypings" />
    <member name="M:Nemerle.Compiler.Typer.get_CurrentFunction" />
    <member name="P:Nemerle.Compiler.Typer.CurrentFunction" />
    <member name="M:Nemerle.Compiler.Typer.get_Env" />
    <member name="P:Nemerle.Compiler.Typer.Env" />
    <member name="M:Nemerle.Compiler.Typer.get_CurrentTypeBuilder" />
    <member name="P:Nemerle.Compiler.Typer.CurrentTypeBuilder" />
    <member name="M:Nemerle.Compiler.Typer.get_IsTopLevel" />
    <member name="P:Nemerle.Compiler.Typer.IsTopLevel" />
    <member name="M:Nemerle.Compiler.Typer.AddLocal(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.Typer.TypeOf(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer.DefineLocal(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.TypeVar,Nemerle.Compiler.LocalValue.Kind,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.AddRedirection(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.BindType(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.BindType(Nemerle.Compiler.Parsetree.PExpr,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.BindFixedType(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.Delay(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Typer.DelayedTyping.Kind,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.DelayMacro(Nemerle.Builtins.Function{System.Boolean,Nemerle.Core.option{Nemerle.Compiler.Parsetree.PExpr}},Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Delay execution of the current macro. You need to provide a function
        that will resolve it at a later time, when more info is needed. It shall
        take one boolean parameter, when it is true, you should fail with a
        descriptive error message stating that more typing information is needed.
        If it is false, you should just return None ().

</para>
      </summary>        <remarks><para>For example:

</para>        <para>macro foo (x) {
          def x' = Macros.ImplicitCTX ().TypeExpr (x);

</para>          <para>Macros.ImplicitCTX ().DelayMacro (fun (fail_loudly) {
            match (x'.Type.Hint) {
              | Some (t) =&gt;
                // do something with the type
                Some (...)
              | None =&gt;
                when (fail_loudly)
                  Message.Error (x.loc, $ "cannot deduce type of $x");
                None ()
            }
          })
        }

</para>        <para>This function will first try to call your resolution function and only if
        it fails, it will get queued for later.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.Typer.TransformWhenAllTypesWouldBeInfered(Nemerle.Builtins.Function{Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>Wait for all types for subexpressions will be inferred and all nested
 delay typing action will be resolved. Do transformation after that.
 If nested subexpressions contains fesh (not inferred) types,
 typing errors or delay typing action the transformation not do.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.DelayAction(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typer.DelayedAction)" />
    <member name="M:Nemerle.Compiler.Typer.MakeOverloadedNode(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility},Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Filter out wrong nodes, and if more then one left -- make the
        [Overloaded] node, and register it.  Removes duplicates.

</para>
      </summary>        <remarks><para>Wrong node is not [StillPossible] node, or one type of which
        cannot unify with [expected].

</para></remarks></member>
    <member name="M:Nemerle.Compiler.Typer.TryTyping(Nemerle.Builtins.Function{Nemerle.Compiler.Typedtree.TExpr})">
      <summary>
        <para>Run given typing action, without possiblity of any error messages.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.IsError(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer.IsLValue(Nemerle.Compiler.Typedtree.TExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.CheckLValue(Nemerle.Compiler.Typedtree.TExpr,System.Boolean,System.String)">
      <summary>
        <para>Check if [e] is an l-value, and if not display an error message
        mentioning [desc]. Additionally is [need_ref] require location of
        the expression to be known (i.e. no properties and indexers).

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.LookupStaticMethod(Nemerle.Compiler.TypeInfo,System.String)" />
    <member name="M:Nemerle.Compiler.Typer.LookupStaticMethod(Nemerle.Compiler.FixedType,System.String)" />
    <member name="M:Nemerle.Compiler.Typer.SquashDuplicates``1(System.Collections.Generic.IEnumerable{``0})" />
    <member name="M:Nemerle.Compiler.Typer.This" />
    <member name="M:Nemerle.Compiler.Typer.StripRefOut(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.JustTry``1(Nemerle.Builtins.Function{``0})" />
    <member name="M:Nemerle.Compiler.Typer.ImplicitCast(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.CanBeTypeName(Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>Heuristics to decide how we treat rhs of 'is' operator: type or pattern

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.IsFunctional(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer.LookupConversions(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.SubtypingOrImplicitConv(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.TExpr.StaticRef@)" />
    <member name="M:Nemerle.Compiler.Typer.AddCastTo(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,System.String)" />
    <member name="M:Nemerle.Compiler.Typer.LiteralConversionPossible(Nemerle.Compiler.Literal,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer.TryExtractFunType(Nemerle.Core.option{Nemerle.Compiler.FixedType})">
      <summary>
        <para>Returns: delegateTyInf expressinTreeTyInf * fromTyInf * toTyInf for ty or nulls.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.NonLiteralCast(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,System.Boolean@,System.Boolean)">
      <summary>
        <para>Returns null if has no cast

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.TryAddCastTo(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.TryAddCastTo(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,System.Boolean@,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.TryResolveNestedDelayedTyping(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr},System.Boolean@,System.Boolean)">
      <summary>
        <para>Returns true if no error. This method does not guarantee absence the unresolved delayed typind.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.FreshTyVar" />
    <member name="M:Nemerle.Compiler.Typer.FreshTypeVar" />
    <member name="M:Nemerle.Compiler.Typer.ConstructFunctionType(Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.AtLeast(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.PushLocals" />
    <member name="M:Nemerle.Compiler.Typer.PopLocals" />
    <member name="M:Nemerle.Compiler.Typer.TypeExpr(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.TypeExpr(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.TypeExpr(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.get_InErrorMode" />
    <member name="P:Nemerle.Compiler.Typer.InErrorMode" />
    <member name="M:Nemerle.Compiler.Typer.get_IsMainPass" />
    <member name="P:Nemerle.Compiler.Typer.IsMainPass" />
    <member name="M:Nemerle.Compiler.Typer.DoExpect(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,System.String,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.Expect(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,System.String)" />
    <member name="M:Nemerle.Compiler.Typer.ExpectSubtyping(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar,System.String)" />
    <member name="M:Nemerle.Compiler.Typer.DoType(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="F:Nemerle.Compiler.Typer.debugInfos" />
    <member name="F:Nemerle.Compiler.Typer.firstExpr" />
    <member name="M:Nemerle.Compiler.Typer.GetDebugLocation(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.TypeLocalDefinition(System.Boolean,Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.TypeDefPattern(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.TypeLocalFunction(Nemerle.Core.list{Nemerle.Compiler.Parsetree.Function_decl})" />
    <member name="M:Nemerle.Compiler.Typer.FixupSequence(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})">
      <summary>
        <para>Given a sequence of expression in a sequence (in reverse order),
        reverse them and nest properly (def ... =&gt; let ... in ...).
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.TypeArray(System.Int32,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.TypeOfLiteral(Nemerle.Compiler.ManagerClass,Nemerle.Compiler.Literal)" />
    <member name="M:Nemerle.Compiler.Typer.TypeIndexer(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.DelayTypingOfIndexerExpr(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.ConstrainLeadingTyparms(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.FixedType.Class)" />
    <member name="M:Nemerle.Compiler.Typer.TypeToConstructor(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.InCurrentType(Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.Typer.ConstructEnclosingType(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMember,Nemerle.Core.list{Nemerle.Compiler.FixedType})" />
    <member name="M:Nemerle.Compiler.Typer.ConstructMethodOverload(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMethod,Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.InterpretGlobal(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMember)" />
    <member name="M:Nemerle.Compiler.Typer.InterpretGlobals(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeInfo,Nemerle.Compiler.IMember}},Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.TypeMemberExpr(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Parsetree.Splicable.Name,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.TypeMember(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.IsBlockReturn(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.Typer.TypeLocal(Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.UnboundName(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.TypeNameFull(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.TypeName(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.TypeName(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.ApplyGenericSpecifier(Nemerle.Compiler.IMember,Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Typer.ApplyGenericSpecifier(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="F:Nemerle.Compiler.Typer.binary_operators" />
    <member name="F:Nemerle.Compiler.Typer.unary_operators" />
    <member name="F:Nemerle.Compiler.Typer._binary_names" />
    <member name="F:Nemerle.Compiler.Typer._unary_names" />
    <member name="M:Nemerle.Compiler.Typer.IsBinaryOperatorName(System.String)" />
    <member name="M:Nemerle.Compiler.Typer.IsUnaryOperatorName(System.String)" />
    <member name="M:Nemerle.Compiler.Typer.GetBinaryOperatorSymbolOrDefault(System.String)" />
    <member name="M:Nemerle.Compiler.Typer.GetUnaryOperatorSymbolOrDefault(System.String)" />
    <member name="M:Nemerle.Compiler.Typer.#cctor" />
    <member name="M:Nemerle.Compiler.Typer.IsOperator(System.String)" />
    <member name="M:Nemerle.Compiler.Typer.TryTypeCall(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm},Nemerle.Compiler.TypeVar,System.Boolean,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.GetBaseOverloads(Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.TypeCall(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr},Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.TypeConversion(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer.TypePatterns(Nemerle.Compiler.TypeVar,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.Typer.FixupMatchCase(Nemerle.Compiler.Typedtree.Match_case)" />
    <member name="M:Nemerle.Compiler.Typer.TypeMatch(Nemerle.Compiler.Parsetree.PExpr.Match,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.TypeBlock(Nemerle.Compiler.Parsetree.PExpr.Ref,Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.MakeImplicitBlockJumpOut(System.String,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.InterceptSpecialMacros(Nemerle.Compiler.Parsetree.PExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.WrapYieldingFunction(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.CanYield" />
    <member name="M:Nemerle.Compiler.Typer.GetYieldType" />
    <member name="M:Nemerle.Compiler.Typer.HandleYield(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.Typer.AddYieldLabel(System.Int32)" />
    <member name="M:Nemerle.Compiler.Typer.AddYieldStateMachine(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer.PartialApplication(Nemerle.Compiler.Parsetree.PExpr)">
      <summary>
        <para>Transform [_.foo] to [fun (x) { x.foo }] and [foo (_, 3)] to
        [fun (x) { foo (x, 3) }].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.DescribeExpression(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer.IsNullableBinaryOperator(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.ResolveOverload(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility},Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm},Nemerle.Compiler.TypeVar,System.Boolean,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Typer.PreferLessGenericMethods(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility})" />
    <member name="M:Nemerle.Compiler.Typer.PreferLessGenericMethods(Nemerle.Compiler.IMethod,Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.Typer.try_type(Nemerle.Compiler.OverloadPossibility,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm},Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer.IsMemberLocationCorrect(Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer.GetMinimal``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,``0,System.Boolean})">
      <summary>
        <para>A simple O(n^2) algorithm for finding a set of minimal elements
        of [lst] using strict partial order [less].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.IsBetterType(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer.IsBetterOverload(Nemerle.Compiler.OverloadPossibility,Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer.IsBetterOverload(Nemerle.Compiler.OverloadPossibility,Nemerle.Compiler.OverloadPossibility,Nemerle.Core.list{Nemerle.Compiler.TypeVar})">
      <summary>
        <para>Compare two overloads fore better match type of arguments.
 It prefer overload whith exect match type of arguments.
 For example, if we have ? -&gt; ? and (? * ?) -&gt; ? overloads and argument list
 [?] this function prefer first overload (? -&gt; ?) because overload (? * ?) -&gt; ?
 demand of convertion from ? to ? * ?.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.AintExtension(Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer.AintVarArgs(Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer.DidntMamboJumbo(Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer.AintGeneric(Nemerle.Compiler.OverloadPossibility)" />
    <member name="M:Nemerle.Compiler.Typer.RemoveExtensionMethods(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility})" />
    <member name="M:Nemerle.Compiler.Typer.RemoveOverloadsWithTupleConvertion(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility})" />
    <member name="M:Nemerle.Compiler.Typer.FilterIfExists``1(Nemerle.Core.list{``0},Nemerle.Builtins.Function{``0,System.Boolean})" />
    <member name="M:Nemerle.Compiler.Typer.GetBestOverloads(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility})" />
    <member name="M:Nemerle.Compiler.Typer.GetBestOverloads(Nemerle.Core.list{Nemerle.Compiler.OverloadPossibility},Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Typer.MinimalTypes``1(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeVar,``0}})" />
    <member name="M:Nemerle.Compiler.Typer.MinimalTypesWithImplicit``1(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.TypeVar,``0}})" />
    <member name="M:Nemerle.Compiler.Typer.GetBestOverloadsWithoutImplicitConversions(Nemerle.Core.list{Nemerle.Compiler.IMethod})">
      <summary>
        <para>it won't work with named parameters

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.Typer.GetBestOverloadsWithoutImplicitConversions(Nemerle.Core.list{Nemerle.Builtins.Tuple{Nemerle.Compiler.FixedType,Nemerle.Compiler.IMethod}})" />
    <member name="M:Nemerle.Compiler.Typer.get_CurrentType" />
    <member name="P:Nemerle.Compiler.Typer.CurrentType" />
    <member name="M:Nemerle.Compiler.Typer.get_LocalContext" />
    <member name="P:Nemerle.Compiler.Typer.LocalContext" />
    <member name="M:Nemerle.Compiler.Typer.get_Solver" />
    <member name="P:Nemerle.Compiler.Typer.Solver" />
    <member name="M:Nemerle.Compiler.Typer.get_CurrentMethodBuilder" />
    <member name="P:Nemerle.Compiler.Typer.CurrentMethodBuilder" />
    <member name="M:Nemerle.Compiler.Typer.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typer.PatternTyper" />
    <member name="T:Nemerle.Compiler.Typer.DelayedTyping" />
    <member name="T:Nemerle.Compiler.Typer.DelayedLambdaAction" />
    <member name="T:Nemerle.Compiler.Typer.DelayedAction" />
    <member name="T:Nemerle.Compiler.Typer.CallTyper" />
    <member name="T:Nemerle.Compiler.Typer.SwitchToYielding" />
    <member name="T:Nemerle.Compiler.Typer.IllegalYieldReturnType" />
    <member name="T:Nemerle.Compiler.Typer.DelayedMacro" />
    <member name="T:Nemerle.Compiler.ExtensionPattern" />
    <member name="M:Nemerle.Compiler.ExtensionPattern._N_handle_pats_120508(Nemerle.Compiler.ExtensionPattern._N_closureOf_Transform_120428,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.ExtensionPattern._N_handle_assigns_120468(Nemerle.Compiler.ExtensionPattern._N_closureOf_Transform_120428,Nemerle.Core.list{Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="M:Nemerle.Compiler.ExtensionPattern._N_add_wildcards_120452(Nemerle.Core.list{System.String},Nemerle.Collections.Map{System.String,Nemerle.Compiler.Parsetree.PExpr})" />
    <member name="F:Nemerle.Compiler.ExtensionPattern.parent" />
    <member name="F:Nemerle.Compiler.ExtensionPattern.name" />
    <member name="F:Nemerle.Compiler.ExtensionPattern.identifiers" />
    <member name="F:Nemerle.Compiler.ExtensionPattern.pattern" />
    <member name="F:Nemerle.Compiler.ExtensionPattern._N_Temporary_17944">
      <summary>
        <para>Must be removed before build type tree.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ExtensionPattern.get_Temporary" />
    <member name="P:Nemerle.Compiler.ExtensionPattern.Temporary">
      <summary>
        <para>Must be removed before build type tree.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.ExtensionPattern.ToString" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.Transform(Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.get_Parent" />
    <member name="P:Nemerle.Compiler.ExtensionPattern.Parent" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.get_Name" />
    <member name="P:Nemerle.Compiler.ExtensionPattern.Name" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.get_Identifiers" />
    <member name="P:Nemerle.Compiler.ExtensionPattern.Identifiers" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.get_Pattern" />
    <member name="P:Nemerle.Compiler.ExtensionPattern.Pattern" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.ExtensionPattern.#ctor(Nemerle.Compiler.TypeInfo,System.String,Nemerle.Core.list{System.String},Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="T:Nemerle.Compiler.Elem" />
    <member name="M:Nemerle.Compiler.Elem.#ctor" />
    <member name="M:Nemerle.Compiler.Elem._N_GetVariantCode" />
    <member name="M:Nemerle.Compiler.Elem._N_GetVariantCodeSafe(Nemerle.Compiler.Elem)" />
    <member name="M:Nemerle.Compiler.Elem._N_GetVariantCodeObject(System.Object)" />
    <member name="M:Nemerle.Compiler.Elem.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Elem.Simple" />
    <member name="T:Nemerle.Compiler.Elem.Node" />
    <member name="T:Nemerle.Compiler.Elem.Local" />
    <member name="T:Nemerle.Compiler.Elem.Overloads" />
    <member name="T:Nemerle.Compiler.Elem.Overload" />
    <member name="T:Nemerle.Compiler.Elem.Member" />
    <member name="T:Nemerle.Compiler.CompletionResult" />
    <member name="F:Nemerle.Compiler.CompletionResult._N_Elems_18062" />
    <member name="M:Nemerle.Compiler.CompletionResult.get_Elems" />
    <member name="P:Nemerle.Compiler.CompletionResult.Elems" />
    <member name="F:Nemerle.Compiler.CompletionResult._N_NamePrefix_18067" />
    <member name="M:Nemerle.Compiler.CompletionResult.get_NamePrefix" />
    <member name="P:Nemerle.Compiler.CompletionResult.NamePrefix" />
    <member name="F:Nemerle.Compiler.CompletionResult._N_Location_18072" />
    <member name="M:Nemerle.Compiler.CompletionResult.get_Location" />
    <member name="P:Nemerle.Compiler.CompletionResult.Location" />
    <member name="F:Nemerle.Compiler.CompletionResult._N_IsMemeberComplation_18077" />
    <member name="M:Nemerle.Compiler.CompletionResult.get_IsMemeberComplation" />
    <member name="P:Nemerle.Compiler.CompletionResult.IsMemeberComplation" />
    <member name="F:Nemerle.Compiler.CompletionResult._N_ObjectType_18082" />
    <member name="M:Nemerle.Compiler.CompletionResult.get_ObjectType" />
    <member name="M:Nemerle.Compiler.CompletionResult.set_ObjectType(Nemerle.Compiler.FixedType)" />
    <member name="P:Nemerle.Compiler.CompletionResult.ObjectType" />
    <member name="F:Nemerle.Compiler.CompletionResult._N_Env_18089" />
    <member name="M:Nemerle.Compiler.CompletionResult.get_Env" />
    <member name="M:Nemerle.Compiler.CompletionResult.set_Env(Nemerle.Compiler.GlobalEnv)" />
    <member name="P:Nemerle.Compiler.CompletionResult.Env" />
    <member name="M:Nemerle.Compiler.CompletionResult.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="M:Nemerle.Compiler.CompletionResult.#ctor(System.Collections.Generic.IList{Nemerle.Compiler.Elem},System.String,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.CompletionResult.#ctor(System.String,System.Collections.Generic.IList{Nemerle.Compiler.Elem},System.String,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.CompletionResult.#ctor(System.String,System.Exception,System.Collections.Generic.IList{Nemerle.Compiler.Elem},System.String,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="M:Nemerle.Compiler.CompletionResult.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Collections.Generic.IList{Nemerle.Compiler.Elem},System.String,Nemerle.Compiler.Location,System.Boolean)" />
    <member name="T:Nemerle.Compiler.TyperBase" />
    <member name="M:Nemerle.Compiler.TyperBase.#cctor" />
    <member name="F:Nemerle.Compiler.TyperBase.DebugOut" />
    <member name="M:Nemerle.Compiler.TyperBase.RemoveNL(System.Object)" />
    <member name="M:Nemerle.Compiler.TyperBase.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.TyperBase.VoidLiteral" />
    <member name="F:Nemerle.Compiler.TyperBase.Manager" />
    <member name="M:Nemerle.Compiler.TyperBase.get_InternalType" />
    <member name="P:Nemerle.Compiler.TyperBase.InternalType" />
    <member name="M:Nemerle.Compiler.TyperBase.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.TyperBase.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.TyperBase.__fake" />
    <member name="M:Nemerle.Compiler.TyperBase.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typer2" />
    <member name="M:Nemerle.Compiler.Typer2._N_warnDangerousOperator_124123(Nemerle.Compiler.Typer2._N_closureOf_TransformNullableOperators_124110,System.String)" />
    <member name="M:Nemerle.Compiler.Typer2._N_register_case_123720(Nemerle.Compiler.Typedtree.Try_case)" />
    <member name="M:Nemerle.Compiler.Typer2._N_PlainRef_123694(Nemerle.Compiler.LocalValue)" />
    <member name="M:Nemerle.Compiler.Typer2._N_get_default_value_123526(Nemerle.Compiler.Typer2._N_closureOf_DoWalk_123320,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="F:Nemerle.Compiler.Typer2.top_level_fun" />
    <member name="F:Nemerle.Compiler.Typer2.this_ptr_decl" />
    <member name="F:Nemerle.Compiler.Typer2.typer" />
    <member name="F:Nemerle.Compiler.Typer2.current_fun" />
    <member name="F:Nemerle.Compiler.Typer2.field_inits_typed" />
    <member name="M:Nemerle.Compiler.Typer2.IsCurrentFunInstanceCtor" />
    <member name="F:Nemerle.Compiler.Typer2.top_fun" />
    <member name="F:Nemerle.Compiler.Typer2.current_type" />
    <member name="F:Nemerle.Compiler.Typer2.messenger" />
    <member name="F:Nemerle.Compiler.Typer2.inside_yielding_function" />
    <member name="M:Nemerle.Compiler.Typer2.#ctor(Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.MethodBuilder,Nemerle.Compiler.Typer)" />
    <member name="M:Nemerle.Compiler.Typer2.MarkAsUsed(Nemerle.Compiler.IMember,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Typer2.MarkAsAssigned(Nemerle.Compiler.IField,Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.Typer2.Run" />
    <member name="M:Nemerle.Compiler.Typer2.Walk(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.Walks(Nemerle.Core.list{Nemerle.Compiler.Typedtree.TExpr})" />
    <member name="M:Nemerle.Compiler.Typer2.Walk(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.AreSelfMethodTyParms(Nemerle.Compiler.IMethod,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Typer2.IsSelfCall(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.Unfold(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.IsOperator(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.OperatorKind(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.IsCurrentType(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer2.GetEventObj(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.TheSame(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.PushConversionDown(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.ConvertEventExpr(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.WalkPattern(Nemerle.Compiler.Typedtree.Pattern)" />
    <member name="M:Nemerle.Compiler.Typer2.FixupCurrentFunction" />
    <member name="M:Nemerle.Compiler.Typer2.PolyLocalToLambdaTransform(Nemerle.Compiler.Typedtree.TExpr.LocalFunRef)" />
    <member name="M:Nemerle.Compiler.Typer2.MethodToLambdaTransform(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.IMethod,Nemerle.Core.list{Nemerle.Compiler.TypeVar},System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer2.VoidIfNull(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.IsBaseRef(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.IgnoreExpr(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.BuildEnforcement(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.Typer2.BuildConversion(Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,Nemerle.Compiler.Typedtree.ConversionKind)" />
    <member name="M:Nemerle.Compiler.Typer2.BuildBlockReturn(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.TypeVar,Nemerle.Compiler.LocalValue,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="M:Nemerle.Compiler.Typer2.ExpandBlock(Nemerle.Compiler.Typedtree.TExpr.Block)" />
    <member name="M:Nemerle.Compiler.Typer2.CheckTypeArguments(Nemerle.Compiler.Location,Nemerle.Compiler.IMember,Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.Typer2.DoWalk(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.StripImplicitConversion(Nemerle.Compiler.Typedtree.TExpr)" />
    <member name="M:Nemerle.Compiler.Typer2.UnwrapNullable(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer2.WrapToNullable(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.Typer2.NullableImplicitConversion(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.Typedtree.TExpr,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.Typer2.TransformNullableOperators(Nemerle.Compiler.Typer2.Context,Nemerle.Compiler.Location,Nemerle.Compiler.TypeVar,System.String,Nemerle.Core.list{Nemerle.Compiler.Typedtree.Parm})" />
    <member name="F:Nemerle.Compiler.Typer2.Manager" />
    <member name="M:Nemerle.Compiler.Typer2.get_InternalType" />
    <member name="P:Nemerle.Compiler.Typer2.InternalType" />
    <member name="M:Nemerle.Compiler.Typer2.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.Typer2.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.Typer2.__fake" />
    <member name="M:Nemerle.Compiler.Typer2.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:Nemerle.Compiler.Typer2.Context" />
    <member name="T:Nemerle.Compiler.TypeVar" />
    <member name="M:Nemerle.Compiler.TypeVar._N_error_100131(Nemerle.Compiler.TypeVar._N_closureOf_AddRelation_100081,System.Int32,Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.TypeVar.#cctor" />
    <member name="M:Nemerle.Compiler.TypeVar.Require(Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Require [this] to be at least [t].

</para>
      </summary>   <remarks><para>To be called when we require some lower constraint on type
   variable.  Return [true] if it's possible.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeVar.TryRequire(Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Check [this] to be subtype of [t].

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.ForceRequire(Nemerle.Compiler.TypeVar)">
      <summary>
        <para>This is much like [assert(Require (t))], but is executed regardless
 of asserts and ignores the result if there was already a
 [LocalError].

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.Require(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Require [this] to be at least [t].

</para>
      </summary> <remarks><para>To be called when we require some lower constraint on type
 variable.  Return [true] iff it's possible.

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeVar.Provide(Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Provide type [t] as the maximal type for [this].

</para>
      </summary> <remarks><para>To be called when value of type [t] is assigned to cell of type
 [this]. Dual to [Require].

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeVar.TryProvide(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.ForceProvide(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.Provide(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Provide type [t] as the maximal type for [this].

</para>
      </summary> <remarks><para>To be called when value of type [t] is assigned to cell of type
 [this]. Dual to [Require].

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeVar.Unify(Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Make sure [t] and [this] will from now on always represent the same type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.TryUnify(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.Unify(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Make sure [t] and [this] will from now on always represent the same type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.ForceUnify(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.EqualsUpperBound(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.get_LowerBound" />
    <member name="P:Nemerle.Compiler.TypeVar.LowerBound" />
    <member name="M:Nemerle.Compiler.TypeVar.get_UpperBound" />
    <member name="P:Nemerle.Compiler.TypeVar.UpperBound" />
    <member name="M:Nemerle.Compiler.TypeVar.get_Hint" />
    <member name="P:Nemerle.Compiler.TypeVar.Hint" />
    <member name="M:Nemerle.Compiler.TypeVar.get_HintFast" />
    <member name="P:Nemerle.Compiler.TypeVar.HintFast" />
    <member name="M:Nemerle.Compiler.TypeVar.get_AnyHint" />
    <member name="P:Nemerle.Compiler.TypeVar.AnyHint" />
    <member name="M:Nemerle.Compiler.TypeVar.get_FixedValue" />
    <member name="P:Nemerle.Compiler.TypeVar.FixedValue" />
    <member name="M:Nemerle.Compiler.TypeVar.Equals(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.Fix" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsPointer" />
    <member name="P:Nemerle.Compiler.TypeVar.IsPointer" />
    <member name="M:Nemerle.Compiler.TypeVar.IsAccessibleFrom(Nemerle.Compiler.TypeInfo)" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsFixed" />
    <member name="P:Nemerle.Compiler.TypeVar.IsFixed" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsFree" />
    <member name="P:Nemerle.Compiler.TypeVar.IsFree" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsFresh" />
    <member name="P:Nemerle.Compiler.TypeVar.IsFresh" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsEnum" />
    <member name="P:Nemerle.Compiler.TypeVar.IsEnum" />
    <member name="M:Nemerle.Compiler.TypeVar.get_TypeInfo" />
    <member name="P:Nemerle.Compiler.TypeVar.TypeInfo" />
    <member name="M:Nemerle.Compiler.TypeVar.get_AlwaysUnify" />
    <member name="M:Nemerle.Compiler.TypeVar.set_AlwaysUnify(System.Boolean)" />
    <member name="P:Nemerle.Compiler.TypeVar.AlwaysUnify" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsConstrained" />
    <member name="P:Nemerle.Compiler.TypeVar.IsConstrained" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsFromNull" />
    <member name="M:Nemerle.Compiler.TypeVar.set_IsFromNull(System.Boolean)" />
    <member name="P:Nemerle.Compiler.TypeVar.IsFromNull" />
    <member name="M:Nemerle.Compiler.TypeVar.Fixate">
      <summary>
        <para>Fix the type to be [LowerBound], so it won't change anymore.
 Don't use this function unless absolutely necessary.

</para>
      </summary>
    </member>
    <member name="F:Nemerle.Compiler.TypeVar.level" />
    <member name="M:Nemerle.Compiler.TypeVar.ToString" />
    <member name="M:Nemerle.Compiler.TypeVar.CompareTo(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.GetHashCode" />
    <member name="M:Nemerle.Compiler.TypeVar.get_CurrentSolver" />
    <member name="P:Nemerle.Compiler.TypeVar.CurrentSolver" />
    <member name="M:Nemerle.Compiler.TypeVar.GetSystemType">
      <summary>
        <para>Don't use this method in macros!

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.GetNonVoidSystemType">
      <summary>
        <para>Don't use this method in macros!

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.DoDeepFix(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.DoDeepFixM(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.TypeVar.DeepFix" />
    <member name="M:Nemerle.Compiler.TypeVar.FromList(Nemerle.Core.list{Nemerle.Compiler.TypeVar})" />
    <member name="M:Nemerle.Compiler.TypeVar.ToList(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.TypeVar.FunParamsTypes(Nemerle.Compiler.IMethod)" />
    <member name="M:Nemerle.Compiler.TypeVar.AddRelation(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.Alias(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.IsValueTypeImpl(Nemerle.Compiler.FixedType)" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsValueType" />
    <member name="P:Nemerle.Compiler.TypeVar.IsValueType" />
    <member name="M:Nemerle.Compiler.TypeVar.get_IsNullable" />
    <member name="P:Nemerle.Compiler.TypeVar.IsNullable" />
    <member name="M:Nemerle.Compiler.TypeVar.get_CanBeNull" />
    <member name="P:Nemerle.Compiler.TypeVar.CanBeNull" />
    <member name="M:Nemerle.Compiler.TypeVar.get_NeedNoSubst" />
    <member name="P:Nemerle.Compiler.TypeVar.NeedNoSubst" />
    <member name="M:Nemerle.Compiler.TypeVar.SetLowerBound(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.SetUpperBound(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.FixArray(Nemerle.Compiler.TypeVar[],Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.FixArrays" />
    <member name="M:Nemerle.Compiler.TypeVar.AddRelation(Nemerle.Compiler.FixedType,Nemerle.Compiler.TypeVar,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeVar.print_info" />
    <member name="M:Nemerle.Compiler.TypeVar.WillRead" />
    <member name="M:Nemerle.Compiler.TypeVar.CopyArrays" />
    <member name="M:Nemerle.Compiler.TypeVar.CopyTyVar(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.WillWrite" />
    <member name="M:Nemerle.Compiler.TypeVar.get_Self" />
    <member name="P:Nemerle.Compiler.TypeVar.Self" />
    <member name="M:Nemerle.Compiler.TypeVar.CopyFrom(Nemerle.Compiler.TypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVar.ResetSerial" />
    <member name="M:Nemerle.Compiler.TypeVar.get_LocalError" />
    <member name="P:Nemerle.Compiler.TypeVar.LocalError" />
    <member name="M:Nemerle.Compiler.TypeVar.get_LocalErrorCount" />
    <member name="P:Nemerle.Compiler.TypeVar.LocalErrorCount" />
    <member name="F:Nemerle.Compiler.TypeVar.alias_to" />
    <member name="F:Nemerle.Compiler.TypeVar.next" />
    <member name="F:Nemerle.Compiler.TypeVar.serial" />
    <member name="F:Nemerle.Compiler.TypeVar.id" />
    <member name="F:Nemerle.Compiler.TypeVar.lower_bound" />
    <member name="F:Nemerle.Compiler.TypeVar.upper_bound" />
    <member name="F:Nemerle.Compiler.TypeVar.lower_tyvars" />
    <member name="F:Nemerle.Compiler.TypeVar.upper_tyvars" />
    <member name="F:Nemerle.Compiler.TypeVar.flags" />
    <member name="F:Nemerle.Compiler.TypeVar._N_ImplicitCastHint_15407" />
    <member name="M:Nemerle.Compiler.TypeVar.get_ImplicitCastHint" />
    <member name="M:Nemerle.Compiler.TypeVar.set_ImplicitCastHint(Nemerle.Compiler.TypeVar)" />
    <member name="P:Nemerle.Compiler.TypeVar.ImplicitCastHint" />
    <member name="F:Nemerle.Compiler.TypeVar.stop_serial" />
    <member name="M:Nemerle.Compiler.TypeVar.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.TypeVar.#ctor(Nemerle.Compiler.TypeVar)" />
    <member name="F:Nemerle.Compiler.TypeVar.empty_set" />
    <member name="M:Nemerle.Compiler.TypeVar.NullToEmpty" />
    <member name="M:Nemerle.Compiler.TypeVar.AddEdge(Nemerle.Compiler.TypeVar,Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Requires [low] and [high] to be after [Self].
</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.IsIn(Nemerle.Compiler.TypeVar[])" />
    <member name="M:Nemerle.Compiler.TypeVar.NormalizeAndCount(Nemerle.Compiler.TypeVar[])" />
    <member name="M:Nemerle.Compiler.TypeVar.InsertSelfInto(Nemerle.Compiler.TypeVar[])" />
    <member name="M:Nemerle.Compiler.TypeVar.ContainedIn(Nemerle.Compiler.TypeVar[],System.Int32)" />
    <member name="M:Nemerle.Compiler.TypeVar.SumSets(Nemerle.Compiler.TypeVar[],Nemerle.Compiler.TypeVar[])" />
    <member name="M:Nemerle.Compiler.TypeVar.IntersectSets(Nemerle.Compiler.TypeVar[],Nemerle.Compiler.TypeVar[])" />
    <member name="F:Nemerle.Compiler.TypeVar.Manager" />
    <member name="M:Nemerle.Compiler.TypeVar.get_InternalType" />
    <member name="P:Nemerle.Compiler.TypeVar.InternalType" />
    <member name="M:Nemerle.Compiler.TypeVar.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.TypeVar.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.TypeVar.__fake" />
    <member name="M:Nemerle.Compiler.TypeVar._N__FT_Unify_4064(Nemerle.Compiler.TypeVar)">
      <summary>
        <para>Make sure [t] and [this] will from now on always represent the same type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar._N__FT_Unify_4065(Nemerle.Compiler.FixedType)">
      <summary>
        <para>Make sure [t] and [this] will from now on always represent the same type.

</para>
      </summary>
    </member>
    <member name="M:Nemerle.Compiler.TypeVar.Equals(System.Object)" />
    <member name="M:Nemerle.Compiler.TypeVar._N__FT_Fixate_4066">
      <summary>
        <para>Fix the type to be [LowerBound], so it won't change anymore.
 Don't use this function unless absolutely necessary.

</para>
      </summary>
    </member>
    <member name="T:Nemerle.Compiler.TypeVar.Flags" />
    <member name="T:Nemerle.Compiler.TyVarEnv" />
    <member name="T:Nemerle.Compiler.TypeVarEnv" />
    <member name="M:Nemerle.Compiler.TypeVarEnv._N_scan_125301(Nemerle.Compiler.TypeVarEnv._N_closureOf_tryFindCyclicConstraint_125291,Nemerle.Compiler.TypeVarEnv._N_closureOf_tryDetectCyclicConstraints_125269,Nemerle.Compiler.TypeVarEnv._N_closureOf_AddTyparms_125190,Nemerle.Compiler.StaticTypeVar,Nemerle.Core.Nil[T]{System.String})" />
    <member name="M:Nemerle.Compiler.TypeVarEnv._N_tryFindCyclicConstraint_125284(Nemerle.Compiler.TypeVarEnv._N_closureOf_tryDetectCyclicConstraints_125269,Nemerle.Compiler.TypeVarEnv._N_closureOf_AddTyparms_125190,Nemerle.Compiler.StaticTypeVar)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv._N_get_125225(Nemerle.Compiler.TypeVarEnv._N_closureOf_AddTyparms_125190,System.Int32)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv._N_type_class_124911(Nemerle.Compiler.TypeVarEnv._N_closureOf_Bind_124877,Nemerle.Compiler.Parsetree.PExpr)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv._N_f2_124905(Nemerle.Compiler.TypeVarEnv._N_closureOf_Bind_124877,Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="F:Nemerle.Compiler.TypeVarEnv.tyvars" />
    <member name="F:Nemerle.Compiler.TypeVarEnv.triggerObsolete" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.#ctor(Nemerle.Compiler.ManagerClass,Nemerle.Collections.Map{Nemerle.Compiler.Parsetree.Name,Nemerle.Compiler.StaticTypeVar})" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.#ctor(Nemerle.Compiler.ManagerClass)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.get_IsEmpty" />
    <member name="P:Nemerle.Compiler.TypeVarEnv.IsEmpty" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.Find(Nemerle.Compiler.Parsetree.Name)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.BindFixedType(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr,System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.CopyWithObsolete(System.Boolean)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.bind_simple_named_type(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.Name,Nemerle.Core.list{System.String},Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.poors_man_lookup_member(Nemerle.Compiler.TypeInfo,System.String)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.bind_nested_type(Nemerle.Compiler.TypeInfo,Nemerle.Compiler.TypeVar,System.String,Nemerle.Core.list{Nemerle.Compiler.TypeVar},Nemerle.Compiler.Location)" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.Bind(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.TypeBuilder,Nemerle.Compiler.Parsetree.PExpr,System.Boolean,System.Boolean)">
      <summary>
        <para>Perform typing of Parsetree type to Typedtree type, looking up
        type constructors in given global environment (with accessibility
        information implied by given current TypeInfo) and type variables
        in current instance.

</para>
      </summary>        <remarks><para>If [check_parms] is true, then we check if type substituted for
        a given type variable conforms to all of its constraints. It
        should be true in general, but is false when we don't know the
        subtyping relations yet (during scanning of global types).

</para></remarks></member>
    <member name="M:Nemerle.Compiler.TypeVarEnv.AddTyparms(Nemerle.Compiler.GlobalEnv,Nemerle.Compiler.Parsetree.Typarms,Nemerle.Compiler.TypeBuilder,System.Boolean)" />
    <member name="F:Nemerle.Compiler.TypeVarEnv.Manager" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.get_InternalType" />
    <member name="P:Nemerle.Compiler.TypeVarEnv.InternalType" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.get_SystemTypeCache" />
    <member name="P:Nemerle.Compiler.TypeVarEnv.SystemTypeCache" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.__fake" />
    <member name="M:Nemerle.Compiler.TypeVarEnv.RelocateImplInternal(Nemerle.Compiler.RelocationInfo)" />
    <member name="T:_N_MacroContexts" />
    <member name="M:_N_MacroContexts.#cctor" />
    <member name="F:_N_MacroContexts.serialized" />
    <member name="F:_N_MacroContexts.contexts" />
    <member name="F:_N_MacroContexts.last_manager" />
    <member name="M:_N_MacroContexts.Get(System.Int32,Nemerle.Compiler.ManagerClass)" />
    <member name="M:_N_MacroContexts.Clear" />
  </members>
</doc>