using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using System.IO;
using TypeScript;
using Nemerle.Web;

namespace Nemerle.Web.Macros
{
  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Assembly)]
  macro NemerleWebProperties(params options : list[PExpr])
  {  
    NemerleWebPropertiesImpl.Impl(Nemerle.Macros.ImplicitCTX(), options) 
  }

  module NemerleWebPropertiesImpl
  {
    public Impl(typer : Typer, options : list[PExpr]) : void
    {
      foreach(opt in options)
      {
      | <[ (TypeScriptPath, $(path)) ]> => 
        def parser = TSDeclarationParser();
        def path = path.ToString();      
        def projectDir = Path.GetDirectoryName(typer.Manager.Options.ProjectPath);
        def tsDir = Path.Combine(projectDir, path);
        def tsFiles = Directory.EnumerateFiles(tsDir, "*.d.ts", SearchOption.AllDirectories);
      
        def jsApi = typer.Env.Define(<[ decl: module JavaScriptApi {} ]>);
        //assert2(false); 
      
        def parse(tsFile)
        {
          match(parser.TryParse(File.ReadAllText(tsFile)))
          {
          | (pos, result) when pos == parser.ParsingSource.OriginalText.Length =>           
            foreach(r in result) 
            {
            | Variable  as v => CreateTSGlobalVariable(v, jsApi)
            | Function  as f => CreateTSGlobalFunction(f, jsApi)
            | Interface as i => CreateTSGlobalInterface(i, jsApi)
            | Class     as c => CreateTSGlobalClass(c, jsApi)
            | Construct as c => CreateTSGlobalConstruct(c, jsApi)
            | Enum      as e => CreateTSGlobalEnum(e, jsApi)
            | Import    as i => CreateTSGlobalImport(i, jsApi)
            | Export    as e => CreateTSGlobalExport(e, jsApi)
            | Module    as m => CreateTSGlobalModule(m, jsApi)
            | _ => ()
            }
          | (pos, _) => 
            def text = parser.ParsingSource.OriginalText;
            Message.Error(Location(tsFile, pos, pos, pos, pos), $"Failed to parse $tsFile, somewhere here: $(text.Substring(pos, 55))...")
          }
        }
      
        // Parse first the infrastructure file.
        def infrastructure = Path.Combine(tsDir, @"_infrastructure\tests\typescript_0.8.3\lib.d.ts");
        parse(infrastructure);
      
        // Parse other files
        foreach(tsFile when !tsFile.Contains("_infrastructure") in tsFiles)
          parse(tsFile);
          
        jsApi.Compile();

      | _ => Message.Error(<#Unrecognized option format, should be tuple of two strings: ("TypeScriptPath", "Typescripts") #>)
      }
    }
    
    globalVariables : HashSet.[string] = HashSet();
  
    private static CreateTSGlobalVariable(var : TSGlobal.Variable, jsApi : TypeBuilder) : void
    {
      when (!globalVariables.Contains(var.Name))
      {
        _  = globalVariables.Add(var.Name);
        def variableType = var.Name + "AnonymousClass";
        jsApi.DefineNestedType(<[ decl: public partial class $(variableType : usesite) {} ]>).Compile();
        
        // DefineMembers(anon, var.Members);
        
        //_ = jsApi.Define(<[ decl: public $(var.Name : usesite) : $(variableType : usesite) ]>);
      }
    }
  
    globalFunctions : HashSet.[string] = HashSet();
  
    private static CreateTSGlobalFunction(function : TSGlobal.Function, jsApi : TypeBuilder) : void
    {
      if (function.Name is Some(fname))
      {
        when (!globalFunctions.Contains(fname))
        {
          _ = globalFunctions.Add(fname);
          jsApi.Define(<[ decl: 
            $(fname : usesite)() : $(ConvertType(function.ReturnType))
            {
              throw ClientCodeCalledInServerException();
            }
          ]>);
        }
      }
      else
      {
        Message.Error("Global functions must have name");
      }
    }
  
    private static CreateTSGlobalInterface(tsInterface : TSGlobal.Interface, jsApi : TypeBuilder) : void
    {
      def type =
        match (tsInterface.Extends)
        {
        | [] =>
          <[ decl: public partial interface $(tsInterface.Name : usesite) {} ]>
        | _ =>
          def extends = tsInterface.Extends.Map(e => <[ $(e : usesite) ]>);
          <[ decl: public partial interface $(tsInterface.Name : usesite) : ..$extends {} ]>
        };
      jsApi.DefineNestedType(type).Compile();
    }
  
    private static CreateTSGlobalClass(tsClass : TSGlobal.Class, jsApi : TypeBuilder) : void
    {
      def type = 
        match((tsClass.Extends, tsClass.Implements))
        {
        | (None, []) =>
          <[ decl: public partial class $(tsClass.Name : usesite) {} ]>
        | _ =>
          def extends = if (tsClass.Extends is Some(ex)) [<[ $(ex : usesite) ]>] else [];
          def implement = tsClass.Implements.Map(e => <[ $(e : usesite) ]>);
          def inherit = extends.Append(implement);
          <[ decl: public partial class $(tsClass.Name : usesite) : ..$inherit {} ]>
        };
      jsApi.DefineNestedType(type).Compile();
    }
  
    private static CreateTSGlobalConstruct(c : TSGlobal.Construct, jsApi : TypeBuilder) : void
    {
      
    }
    
    enums : HashSet.[string] = HashSet();
  
    private static CreateTSGlobalEnum(tsEnum : TSGlobal.Enum, jsApi : TypeBuilder) : void
    {
      when (!enums.Contains(tsEnum.Name))
      {
        _ = enums.Add(tsEnum.Name);
        def type = <[ decl: enum $(tsEnum.Name : usesite) { } ]>;
        jsApi.DefineNestedType(type).Compile();
      }
    }
  
    private static CreateTSGlobalImport(i : TSGlobal.Import, jsApi : TypeBuilder) : void
    {
      
    }
  
    private static CreateTSGlobalExport(e : TSGlobal.Export, jsApi : TypeBuilder) : void
    {
      
    }
  
    private static CreateTSGlobalModule(tsModule : TSGlobal.Module, jsApi : TypeBuilder) : void
    {
      when (!tsModule.Name.Contains('.') && !tsModule.Name.Contains('/'))
        jsApi.DefineNestedType(<[ decl: public partial module $(tsModule.Name : usesite) {} ]>).Compile();
    }
  
    private GetParamsType(parms : list[TSParam], additional : option[TSType]) : list[PExpr]
    {
      def convertParamsType(p : TSParam)
      {
        | Required(_, t, _)
        | Option(_, _, t, _) => ConvertType(t)
        | Rest(_, t) => ConvertType(t)
      }
    
      def ret = 
        parms
          .Map(convertParamsType)
          .Append(if (additional is Some(t)) [ConvertType(t)] else []);
    
      ret
    }
  
    private ConvertType(inputType : option[TSType]) : PExpr
    {
      | Some(type) => ConvertType(type)
      | None => <[ object ]>
    }
  
    private ConvertType(inputType : TSType) : PExpr
    {
      | Array(type, 0) => <[ $(ConvertType(type)) ]>
      | Array(type, arity) => <[ array[$(ConvertType(TSType.Array(type, arity - 1)))] ]>
      | Bool => <[ bool ]>    
      | Lambda(parms, ret) =>
        def (type, additional) = 
          if (ret is TSType.Void()) (<[ Action ]>, None())
          else                      (<[ Func ]>, Some(ret));
        
        <[ $type.[{..$(GetParamsType(parms, additional))}] ]>
      | Named
      | New
      | Number => <[ float ]>
      | Object => Message.Hint("Object is not supported"); <[ ]>
      | String => <[ void ]>
      | Void => <[ void ]>
      | Any
      | _ => <[ object ]>
    }
  }
}
