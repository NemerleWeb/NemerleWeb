using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Peg
{
  partial internal class RuleCompiler
  {
    public CompileRuleNot(rule : Rule.Not) : PExpr
    {
      | Not(Chars([RangeSet where (Ranges = [range])])) when range.from == char.MinValue && range.to == char.MaxValue => // !any
        <[ if (position >= text.Length) position else -1 ]>

      | Not(rule) =>
        <[
          def newPosCompileRuleNot = $(CompileRule(rule, []));
          if (newPosCompileRuleNot < 0) position else -1
        ]>
    }
  }
}
