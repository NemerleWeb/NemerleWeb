using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Peg
{
  partial internal class RuleCompiler
  {
    public CompileRuleRepeatMinMax(rule : Rule.RepeatMinMax, results : list[string], global : bool, counter : int) : PExpr
    {
      def pos = if (global) <[ position ]> else <[ $(("pos" + counter) : usesite) ]>;
      def newPos = <[ $(("pos" + (counter + 1)) : usesite) ]>;
      def rep = <[ $(("rep" + counter) : usesite) ]>;
      match (rule)
      {
        | RepeatMinMax(0, 1, subrule)    =>
          def (initialising, setExpr, setNoneExpr, ruleCode) = match (subrule)
          {
            | Capture(Handler(_, _, ty), _) when GrammarTyper.IsOptimizableOptionType(ty)
            | Capture(Argument(ty), _) when GrammarTyper.IsOptimizableOptionType(ty) =>
              MakeSubruleCode(results, subrule,
                              _                      => <[ () ]>,
                              (varRef, variableRefs) => match (variableRefs)
                                                        {
                                                          | [variableRef] => <[ $varRef = $variableRef; ]>
                                                          | _ => assert(false);
                                                        },
                              _                      => <[ () ]>,
                              counter);

            | _ =>
              MakeSubruleCode(results, subrule,
                              _                      => <[ () ]>,
                              (varRef, variableRefs) => <[ $varRef = Some(..$variableRefs); ]>,
                              varRef                 => <[ $varRef = None(); ]>,
                              counter);
          }
          PrepandExprs(initialising, <[
            def newPosCompileRuleRepeatMinMax01 = $ruleCode;
            if (newPosCompileRuleRepeatMinMax01 >= 0)
            {
              $setExpr;
              newPosCompileRuleRepeatMinMax01
            }
            else
            {
              $setNoneExpr;
              $pos
            }
          ]>)

        | RepeatMinMax(minCount, maxCount, subrule)    =>
          def (initialising, addTokensToList, ruleCode) = MakeListCode(results, subrule, counter);
          PrepandExprs(initialising, <[
            //def rep(count, pos)
            mutable rep = null;
            $rep = (count, $newPos) =>
            {
              if (count == $(maxCount : int))
                pos
              else
              {
                def newPosCompileRuleRepeatMinMax = $ruleCode;
                if (newPosCompileRuleRepeatMinMax >= 0)
                {
                  $addTokensToList;
                  $rep(count + 1, newPosCompileRuleRepeatMinMax)
                }
                else if (count >= $(minCount : int))
                  newPos
                else
                  -1
               }
            }
            $rep(0, $pos)
          ]>)
      }
    }
  }
}
