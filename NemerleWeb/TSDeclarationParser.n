using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;

using System;
using System.Collections.Generic;
using System.Linq;

namespace TypeScript
{
  [PegGrammar(Options = EmitDebugSources,
      start,
      grammar
      {
        // We create void rules to write less code in handler and even skip writing handler.
        #region Literals
        
        Spacing = WhiteSpace / LineTerminatorSequence / Comment;
        s : void = Spacing*;
        S : void = (Spacing / ';')*;
        
        import_s : void = "import"s;
        export_s : void = "export"s;
        module_s : void = "module"s;
        declare_s : void = "declare"s;
        var_s : void = "var"s;
        function_s : void = "function"s;
        new_s : void = "new"s;

        #endregion
        
        #region EcmaScript
        
        #region SourceCharacter (6)

        SourceCharacter = [Any];

        #endregion

        #region WhiteSpace (7.2)

        NBSP = '\u00A0';
        BOM = '\uFEFF';
        WhiteSpace = [Zs] / '\t' / '\v' / '\f' / ' ' / NBSP / BOM;        

        #endregion

        #region Line terminators (7.3)

        LineSeparator = '\u2028';
        ParagraphSeparator = '\u2029';
        LineTerminator = '\n' / '\r' / LineSeparator / ParagraphSeparator;
        LineTerminatorSequence = "\r\n" / LineTerminator;

        #endregion

        #region Comment (7.4)
        
        Comment = MultiLineComment / SingleLineComment;
        MultiLineComment = "/*" (!"*/" [Any])* "*/";
        SingleLineComment = "//" (!LineTerminator [Any])*;

        #endregion
        
        #region Identifier (7.6)
        
        ZWNJ = '\u200C';
        ZWJ = '\u200D';        
        
        // Any name
        AnyIdentifier = IdentifierName s;
        Identifier = !(ReservedWord Spacing+) IdentifierName s;
        IdentifierName = IdentifierStart+ IdentifierPart*;
        IdentifierStart = UnicodeLetter / '$' / '_' / '\\' UnicodeEscapeSequence;
        IdentifierPart =
          IdentifierStart /
          UnicodeCombiningMark /
          UnicodeDigit /
          UnicodeConnectorPunctuation /
          ZWNJ /
          ZWJ;
          
        UnicodeLetter = [Lu, Ll, Lt, Lm, Lo, Nl];
        UnicodeCombiningMark = [Mn, Mc];
        UnicodeDigit = [Nd];
        UnicodeConnectorPunctuation = [Pc];        
        
        #endregion
        
        #region ReservedWord (7.6.1)
        
        ReservedWord = Keyword / FutureReservedWord / StrictReservedWord / NullLiteral / BooleanLiteral;
        StrictModeReservedWord = ReservedWord / StrictReservedWord;
        
        Keyword =
          "break" / "do" / "instanceof" / "typeof" / "case" / "else" / 
          "new" / "var" / "catch" / "finally" / "return" / "void" / "continue" /
          "for" / "switch" / "while" / "debugger" / "function" / "this" / "with" / 
          "default" / "if" / "throw" / "delete" / "in" / "try";
          
        // 7.6.1.2          
        FutureReservedWord =
          "class" / "enum" / "extends" / "super" / "const" / "export" / "import";
          
        // 10.1.1  
        StrictReservedWord =
          "implements" / "let" / "private" / "public" / "yield" / "interface" /
          "package" / "protected" / "static";
        
        #endregion
        
        #region Literals (7.8)

        Literal = NullLiteral / BooleanLiteral / NumericLiteral / StringLiteral / RegularExpressionLiteral;

        #endregion
        
        #region NullLiteral (7.8.1)
        
        NullLiteral = "null";
        
        #endregion
        
        #region BooleanLiteral (7.8.2)
        
        BooleanLiteral = "true" / "false";
        
        #endregion

        #region NumericLiteral (7.8.3)

        NumericLiteral = (DecimalLiteral / HexIntegerLiteral) !(IdentifierStart / DecimalDigit);

        DecimalLiteral =
          DecimalIntegerLiteral "." DecimalDigit* ExponentPart? /
          "." DecimalDigit+ ExponentPart? /
          DecimalIntegerLiteral ExponentPart?;

        DecimalIntegerLiteral = '0' / NonZeroDigit DecimalDigit*;
        DecimalDigit = ['0'..'9'];
        NonZeroDigit = ['1'..'9'];        
        ExponentPart = ExponentIndicator SignedInteger;
        ExponentIndicator = 'e' / 'E';
        SignedInteger = DecimalDigit+ / "+" DecimalDigit+ / "-" DecimalDigit+;
        HexIntegerLiteral = ("0x" / "0X") HexDigit+;
        HexDigit = ['0'..'9', 'a'..'f', 'A'..'F'];        

        #endregion

        #region StringLiteral (7.8.4)
        
        StringLiteral = '"' DoubleStringCharacter* '"' / '\'' SingleStringCharacter* '\'';
        DoubleStringCharacter = 
          !('"' / '\\' / LineTerminator) SourceCharacter /
          '\\' EscapeSequence /
          LineContinuation;                 
        SingleStringCharacter =
          !('\'' / '\\' / LineTerminator) SourceCharacter /
          '\\' EscapeSequence /
          LineContinuation;
        LineContinuation = '\\' LineTerminatorSequence ;
        
        EscapeSequence = 
          CharacterEscapeSequence /
          '0' !DecimalDigit /
          HexEscapeSequence /
          UnicodeEscapeSequence;
        
        CharacterEscapeSequence = SingleEscapeCharacter / NonEscapeCharacter;
        SingleEscapeCharacter = '\'' / '\"' / '\\' / 'b' / 'f' / 'n' / 'r' / 't' / 'v';
        NonEscapeCharacter = !(EscapeCharacter / LineTerminator) SourceCharacter;        
        EscapeCharacter = SingleEscapeCharacter / DecimalDigit / 'x' / 'u';
        HexEscapeSequence = "x" HexDigit HexDigit;
        UnicodeEscapeSequence = "u" HexDigit HexDigit HexDigit HexDigit;
        
        #endregion
        
        #region Regular Expression Literals (7.8.5)
        
        RegularExpressionLiteral = '/'s RegularExpressionBody '/'s RegularExpressionFlags s;
        RegularExpressionBody = RegularExpressionFirstChar RegularExpressionChars;
        RegularExpressionChars = RegularExpressionChar*;
        RegularExpressionFirstChar =
          !'*' !'\\' !'/' !'[' RegularExpressionNonTerminator /
          RegularExpressionBackslashSequence /
          RegularExpressionClass;
        RegularExpressionChar =
          !'\\' !'/' !'[' RegularExpressionNonTerminator /
          RegularExpressionBackslashSequence /
          RegularExpressionClass;
        RegularExpressionBackslashSequence = '\\'s RegularExpressionNonTerminator;
        RegularExpressionNonTerminator = !LineTerminator SourceCharacter;
        RegularExpressionClass = '['s RegularExpressionClassChars ']'s;
        RegularExpressionClassChars = RegularExpressionClassChar*;
        RegularExpressionClassChar = 
          !']' !'\\' RegularExpressionNonTerminator /
          RegularExpressionBackslashSequence;        
        RegularExpressionFlags = IdentifierPart?;
        
        #endregion
        
        #region Primary Expressions (11.1)
        
        PrimaryExpression =
          "this" /
          Identifier /
          Literal /
          ArrayLiteral /
          ObjectLiteral /
          '('s Expression ')'s;
          
        #endregion
        
        #region Array Initialiser (11.1.4)
        
        ArrayLiteral = '['s (ElementList / ElementList ','s Elision? / Elision?) ']'s;
        ElementList = Elision? AssignmentExpression (','s Elision? AssignmentExpression)*;
        Elision = (','s)+;
        
        #endregion
        
        #region Object Initialiser (11.1.5)

        ObjectLiteral =
          '{'s '}'s /
          '{'s PropertyNameAndValueList '}' /
          '{'s PropertyNameAndValueList ','s '}'s;
        PropertyNameAndValueList = PropertyAssignment (','s PropertyAssignment)*;
        PropertyAssignment =
          PropertyName ':'s AssignmentExpression /
          "get"s PropertyName '('s ')'s '{'s FunctionBody '}'s /
          "set"s PropertyName '('s PropertySetParameterList ')'s '{'s FunctionBody '}'s;
        PropertyName = IdentifierName / StringLiteral / NumericLiteral;
        PropertySetParameterList = Identifier;
        
        #endregion
        
        #region Left-Hand-Side Expressions (11.2)
        
        MemberExpression =
          (new_s)? (PrimaryExpression / FunctionExpression) ('['s Expression ']'s / '.'s IdentifierName)+ Arguments?;
        NewExpression = MemberExpression / new_s NewExpression;
        CallExpression = MemberExpression (Arguments+ / '['s Expression ']'s / '.'s IdentifierName);
        Arguments = '('s ArgumentList? ')'s;
        ArgumentList = AssignmentExpression (','s AssignmentExpression)*;

        LeftHandSideExpression = NewExpression / CallExpression;
        
        #endregion
        
        #region Postfix Expression
        
        PostfixExpression =
          LeftHandSideExpression /
          LeftHandSideExpression !LineTerminator "++" /
          LeftHandSideExpression !LineTerminator  "--";
        
        #endregion
        
        #region Unary Operators (11.4)
        
        UnaryExpression =
          PostfixExpression /
          "delete"s UnaryExpression /
          "void"s UnaryExpression /
          "typeof"s UnaryExpression /
          "++"s UnaryExpression /
          "--"s UnaryExpression /
          '+'s UnaryExpression /
          '-'s UnaryExpression /
          '~'s UnaryExpression /
          '!'s UnaryExpression;
        
        #endregion
        
        #region Multiplicative Operators (11.5)
        
        MultiplicativeExpression = UnaryExpression (('*' / '/' / '%')s UnaryExpression)*;
        
        #endregion
        
        #region Additive Operators (11.6)
        
        AdditiveExpression = MultiplicativeExpression (('+' / '-')s MultiplicativeExpression)*;
        
        #endregion
        
        #region Bitwise Shift Operators (11.7)
        
        ShiftExpression = AdditiveExpression (("<<" / ">>" / ">>>")s AdditiveExpression)*;
        
        #endregion
        
        #region Relational Operators (11.8)
        
        RelationalExpression =
          ShiftExpression (('<' / '>' / "<=" / ">=" / "instanceof" / "in")s ShiftExpression)*;        
        #endregion
        
        #region Equality Operators (11.9)
        
        EqualityExpression = RelationalExpression (("==" / "!=" / "===" / "!==")s RelationalExpression)*;
        
        #endregion
        
        #region Binary Bitwise Operators (11.10)
        
        BitwiseANDExpression = EqualityExpression ('&'s EqualityExpression)*;        
        BitwiseXORExpression = BitwiseANDExpression ('^'s BitwiseANDExpression)*;   
        BitwiseORExpression = BitwiseXORExpression ('|'s BitwiseXORExpression)*;
        
        #endregion
        
        #region Binary Logical Expression (11.11)
        
        LogicalANDExpression = BitwiseORExpression ("&&"s BitwiseORExpression)*;        
        LogicalORExpression = LogicalANDExpression ("||"s LogicalANDExpression)*;
        
        #endregion
        
        #region Conditional Operator (11.12)
        
        ConditionalExpression =
          LogicalORExpression /
          LogicalORExpression '?'s AssignmentExpression ':'s AssignmentExpression;
        
        #endregion
        
        #region Assignement Operators (11.13)
        
        AssignmentExpression =
          ConditionalExpression /
          LeftHandSideExpression '=' AssignmentExpression /
          LeftHandSideExpression AssignmentOperator AssignmentExpression;
        
        AssignmentOperator = "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / ">>>=" / "&=" / "^=" / "|=";
        
        #endregion
        
        #region Comma Operator (11.14)
        
        Expression = AssignmentExpression (','s AssignmentExpression)*;
        
        #endregion

        #region Statement (12)
        
        // TODO: Add other statements
        Statement = VariableStatement;
        
        #endregion
        
        #region Variable Statement (12.2)
        
        VariableStatement = var_s VariableDeclarationList ';'S;
        VariableDeclarationList = VariableDeclaration (','s VariableDeclaration)*;
        // This rule is modified in TypeSript see: 5.1
        //VariableDeclaration = Identifier;
        Initialiser = '=' AssignmentExpression;
        
        #endregion
        
        #region Function Definition (13)
        
        FunctionExpression = function_s Identifier? '('s FormalParameterList? ')'s '{'s FunctionBody '}'s;
        FormalParameterList = Identifier (','s Identifier)*;
        FunctionBody = SourceElement*;
        
        #endregion
        
        #region Program (14)
        
        SourceElement = Statement / FunctionDeclaration;
        
        #endregion
        
        #endregion
        
        #region TypeScript
        
        #region Specifying Types (3.5)
        
        // Array is specified here, because otherwise we have left recursion.
        ScriptType = (TypeLiteral / PredefinedType / TypeName) ('['s ']'s)*;
        PredefinedType = ("any" / "number" / "bool" / "string") s !IdentifierPart;
        TypeName = Identifier ("." Identifier)*;
        ModuleName = TypeName;
        TypeLiteral = ObjectType / FunctionType / ConstructorType;
        
        #endregion
        
        #region Object Type Literals (3.5.3)
        
        ObjectType = '{'s TypeBody '}'s;
        TypeBody = TypeMemberList ';'S / TypeMemberList?;
        TypeMemberList = TypeMember (';'S TypeMember)* S;
        TypeMember =
          CallSignature /
          ConstructSignature /
          IndexSignature /
          FunctionSignature /
          PropertySignature;
        
        CallSignature = '('s ParameterList? ')'s ReturnTypeAnnotation?;
        ConstructSignature = new_s '('s ParameterList? ')'s TypeAnnotation?;
        IndexSignature = '['s RequiredParameter ']'s TypeAnnotation?;
        PropertySignature = Identifier '?'?s TypeAnnotation?;
        FunctionSignature = Identifier '?'?s '('s ParameterList? ')'s ReturnTypeAnnotation?;
        
        #endregion
        
        #region Array Type Literal (3.5.4)
        
        ArrayType = (PredefinedType / TypeName / TypeLiteral) ('['s ']'s)+;
        
        #endregion
        
        #region Function Type Literals (3.5.5)
        
        FunctionType = '('s ParameterList? ')'s "=>"s ReturnType s;
        
        #endregion
        
        #region Constructor Type Literals (3.5.6)
        
        ConstructorType = new_s '('s ParameterList? ')'s "=>"s ScriptType s;

        #endregion
        
        #region Variable Statements (5.1)
        
        VariableDeclaration = Identifier TypeAnnotation?;
        TypeAnnotation = ':'s ScriptType s;
        
        #endregion
        
        #region Function Declarations
        
        // Modified
        FunctionDeclaration = FunctionOverload+;
        FunctionOverload = function_s FunctionSignature ';'S;
        
        #endregion
        
        #region Function Signatures (6.2)
        
        ParameterList =
          RequiredParameterList ','s OptionalParameterList ','s RestParameter /
          OptionalParameterList ','s RestParameter /
          RequiredParameterList ','s OptionalParameterList /
          RequiredParameterList ','s RestParameter /
          OptionalParameterList /
          RequiredParameterList /
          RestParameter;
        RequiredParameterList = RequiredParameter (','s RequiredParameter)*;
        RequiredParameter = PublicOrPrivate? Identifier !'?' TypeAnnotation?;
        PublicOrPrivate = ("public" / "private")s;
        OptionalParameterList = OptionalParameter (','s OptionalParameter)*;
        // Optional parameter must not have Initialiser in declaration files.
        OptionalParameter = PublicOrPrivate? Identifier ('?'s TypeAnnotation? / TypeAnnotation?) s;
        RestParameter = "..."s Identifier !'?' ':'s ArrayType;
        ReturnTypeAnnotation = ':'s ReturnType s;
        ReturnType = ScriptType / "void";
        
        #endregion
        
        #region Interface Declarations (7.1)
        
        InterfaceDeclaration : TSGlobal = "interface"s Identifier InterfaceExtendsClause? ObjectType S;
        InterfaceExtendsClause = "extends"s InterfaceNameList;
        InterfaceNameList = InterfaceName (','s InterfaceName)*;
        InterfaceName = TypeName;
        
        #endregion
        
        #region Class Declarations (8.1)
        
        ClassDeclaration = "class"s Identifier ClassHeritage '{'s ClassBody '}'S;
        
        ClassHeritage = ClassExtendsClause? ImplementsClause?;
        ClassExtendsClause = "extends"s ClassName;
        ClassName = TypeName;
        ImplementsClause = "implements"s InterfaceNameList;
        
        ClassBody = ClassElement*;
        ClassElement = ConstructorDeclaration / MemberDeclaration;
        
        #endregion
        
        #region Constructor Declaration (8.3)
        
        ConstructorDeclaration = ConstructorOverload+;
        ConstructorOverload = "constructor"s '('s ParameterList? ')'s ';'S;
        
        #endregion
        
        #region Member Declarations (8.4)
        
        MemberDeclaration = MemberFunctionDeclaration / MemberVariableDeclaration;
        
        MemberVariableDeclaration = PublicOrPrivate? "static"?s VariableDeclaration ';'S;
        
        MemberFunctionDeclaration = MemberFunctionOverload+;
        MemberFunctionOverload = PublicOrPrivate? "static"?s FunctionSignature ';'S;
                
        #endregion
        
        #region Enum Declaration
        
        EnumDeclaration = "enum"s Identifier '{'s EnumBody? '}'S;
        EnumBody = EnumElement (','s EnumElement)* ','?s;
        EnumElement = Identifier Initialiser?;
        
        #endregion
        
        #region Programs (9.1)
        
        SourceFile = DeclarationSourceFile;
        ModuleElement =
          Statement /
          FunctionDeclaration /
          ClassDeclaration /
          InterfaceDeclaration /
          ModuleDeclaration /
          EnumDeclaration /
          ImportDeclaration /
          ExportDeclaration /
          AmbientDeclaration;
        
        #endregion
        
        #region Module Declarations (9.2)
        
        ModuleDeclaration = "module"s IdentifierPath? '{'s ModuleBody '}'S;
        IdentifierPath = Identifier ("." Identifier)*;
        ModuleBody = ModuleElement*;
        
        #endregion
        
        #region Export Declarations (9.2.1)
        
        // Allow export function();
        ExportFunctionDeclaration = AmbientFunctionDeclaration;
        ExportDeclaration =
          export_s
            (
              VariableStatement /
              ExportFunctionDeclaration /
              ClassDeclaration /
              InterfaceDeclaration /
              ModuleDeclaration /
              EnumDeclaration /
              AmbientDeclaration
            );
            
        #endregion 
        
        #region Import Declarations (9.2.2)
        
        ImportDeclaration : TSGlobal = import_s Identifier '='s ModuleReference s ';'S;
        ModuleReference = ExternalModuleReference / ModuleName;
        ExternalModuleReference = module_s '('s StringLiteral s ')';
        
        #endregion
        
        #region Ambient Declarations (10.1)
                
        AmbientDeclaration =
          declare_s
           (
            AmbientVariableDeclaration /
            AmbientFunctionDeclaration /
            AmbientClassDeclaration /
            AmbientModuleDeclaration /
            AmbientEnumDeclaration
           );
        
        #endregion
        
        #region Ambient Variable Declarations (10.1.1)
        
        AmbientVariableDeclaration : TSGlobal = var_s Identifier TypeAnnotation? S;
        
        #endregion
        
        #region Ambient Variable Declarations (10.1.2)
        
        // This rule is not by specification, but TypeScript parses it correctly.
        AmbientFunctionSignature = AnyIdentifier? '?'?s '('s ParameterList? ')'s ReturnTypeAnnotation?;
        AmbientFunctionDeclaration : TSGlobal = function_s AmbientFunctionSignature S;
        
        // This rule is not by specification, but TypeScript parses it correctly.
        AmbientConstructDeclaration : TSGlobal  = function_s new_s '('s ParameterList? ')'s ReturnTypeAnnotation? S;
        
        #endregion
        
        #region Ambient Class Declarations (10.1.3)
        
        AmbientClassDeclaration : TSGlobal = "class"s Identifier ClassHeritage '{'s AmbientClassBody '}'S;
        AmbientClassBody = AmbientClassBodyElement*;
        AmbientClassBodyElement = AmbientConstructorDeclaration / AmbientStaticDeclaration / AmbientMemberDeclaration;
        AmbientConstructorDeclaration = "constructor"s '('s ParameterList? ')'s ';'S;
        AmbientMemberDeclaration = PublicOrPrivate? (FunctionSignature / Identifier TypeAnnotation?) ';'S;
        AmbientStaticDeclaration = PublicOrPrivate? "static"s (FunctionSignature / Identifier TypeAnnotation?) ';'S;
        AmbientEnumDeclaration : TSGlobal = "enum"s Identifier '{'s EnumBody? '}'S;
        
        #endregion        
        
        #region Ambient Module Declarations (10.1.4)
        
        AmbientModuleDeclaration : TSGlobal = module_s AmbientModuleIdentification s '{'s AmbientModuleBody '}'S;
        AmbientModuleIdentification = StringLiteral / IdentifierPath;
        AmbientModuleBody = AmbientElement*;
        
        AmbientElementNotImport : TSGlobal =
          export_s? declare_s?
            (
              AmbientVariableDeclaration /
              AmbientConstructDeclaration /
              AmbientFunctionDeclaration /
              AmbientClassDeclaration /
              InterfaceDeclaration /
              AmbientModuleDeclaration /
              AmbientEnumDeclaration
            );
        AmbientElement : TSGlobal = AmbientElementNotImport / ImportDeclaration;
                  
        #endregion
                
        #region Declaration Source Files (10.2)
        
        DeclarationSourceFile : List[TSGlobal] = S AmbientElement*;
        
        #endregion
        
        #endregion
        
        start : List[TSGlobal] = DeclarationSourceFile;
      }
    )]
  public class TSDeclarationParser
  {
    AmbientVariableDeclaration( _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Variable()
    }
    
    AmbientConstructDeclaration(_ : NToken, _ : NToken, _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Construct()
    }
    
    AmbientFunctionDeclaration(_ : NToken) : TSGlobal
    {
      TSGlobal.Function()
    }
    
    AmbientClassDeclaration(_ : NToken, _ : NToken, _ : NToken, _ : NToken, _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Class()
    }
    
    InterfaceDeclaration(_ : NToken, _ : NToken, _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Interface()
    }
    
    AmbientModuleDeclaration(_ : NToken, _ : NToken, _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Module()
    }
    
    AmbientEnumDeclaration(_ : NToken, _ : NToken, _ : NToken, _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Enum()
    }
    
    ImportDeclaration(_ : NToken, _ : NToken, _ : NToken, _ : NToken) : TSGlobal
    {
      TSGlobal.Import()
    }
  }

  public variant TSGlobal
  {
    | Variable 
    | Construct
    | Function
    | Class
    | Interface
    | Module
    | Enum
    | Import
  }
}
