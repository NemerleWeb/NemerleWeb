using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Collections.Generic;
using System.Linq;

namespace NemerleWeb
{
  public module JsAstHelper
  {     
    allowedCallTargets : list[Type] = [typeof(JsAst.LocalRef), typeof(JsAst.Literal)];
    mutable temporaryVariableCounter : int = 0;
    
    public TransformBottomUp(ast : JsAst) : JsAst
    {   
        JsAst.Recurse(ast, (a, _depth) => a.Transform(), 0, false)
    }
    
    public RemoveEmptyBranches(ast : JsAst) : JsAst
    {
        JsAst.Recurse(ast, (a : JsAst, _depth) =>
        match(a) { 
        | While(_, Void) 
        | While(_, Undefined) => JsAst.Void()
        | If(cond, then, Undefined) 
        | If(cond, then, Void) => JsAst.JustIf(cond, then)
        | JustIf(_, Void) 
        | JustIf(_, Undefined) => JsAst.Void()        
        | _ => a
        }, 0, false);
    }
    
    public FlattenAndRemoveVoids(ast : JsAst) : JsAst    
    {
        JsAst.Recurse(ast, (a : JsAst, _depth) => {
            def flatten(a' : JsAst) : JsAst {
            | Seq(s0) when s0.Any(e => e is JsAst.Seq)  => 
                def r = s0.Flatten(e => 
                    match(e) {
                    | JsAst.Seq(xs) => xs
                    | x => [x]
                });
                flatten(JsAst.Seq(r.Filter(rr => !(rr is JsAst.Void))));
            | _ => a'
            }
            flatten(a);
        });
    }
    
    public LabelsToNamedWhile(ast : JsAst) : JsAst 
    {
        def gotos = IterateAST(ast).OfType.[JsAst.Goto]()
                                   .Select(k => k.LabelId)
                                   .Distinct()
                                   .ToDictionary(k => k);
      
        def r = JsAst.Recurse(ast, (a : JsAst, _depth) => 
          match(a)
          {
          | Label(id, body) when gotos.ContainsKey(id.ToString()) =>
            def functionName = "_nweb_lbl_l" + id.ToString();
            JsAst.Seq([
              JsAst.DeclFunction(functionName, [], MakeReturn(body)),
              JsAst.Call(JsAst.LocalRef(functionName, None()), [])
            ]);
            //JsAst.WhileNamed(JsAst.Literal(JsLiteral.Bool(true)), JsAst.Seq([body, JsAst.Break()]), "l" + id.ToString()); //ConvertLabelToSwitch(l)
          | Label(_, body)  => body
          | Goto(id)        => 
            def functionName = "_nweb_lbl_l" + id.ToString();
            JsAst.Call(JsAst.LocalRef(functionName, None()), [])
          | _ => a
          });        
        r
    }
        
    public GotosToSwitch(ast : JsAst) : JsAst
    {
      def anyGotos = IterateAST(ast).OfType.[JsAst.Goto]().Any();
      if(anyGotos) 
      {
        def exprList = List();
        def labelMap = Dictionary();
        def currentLabelVar = GetTemporaryVariableName();
        def loopName = "__gotoSwitchLoop";
        mutable labelCounter = 0;
        def getNewLabel() {
          ++labelCounter;
          $"__lbl__$labelCounter"
        }
        def getGotoToLabel(label) {
          JsAst.Seq([
            JsAst.Assign(JsAst.LocalRef(currentLabelVar, None()), JsAst.Literal(JsLiteral.String("__CHECK_LABEL__" + label))),
            JsAst.Continue(loopName)
          ]);
        }
        
        def f(current : JsAst, next : option[string]) : string
        {
          match(current)
          {
          | Label(id, Seq as seq)
          | Seq as seq with id = -1 =>
            if(seq.Items.Any()) 
            {
              def seqList = seq.Items.ToList();
              def reversed = Enumerable.Reverse(seqList);
              mutable currentNext = next;
              foreach(s in reversed)
                  currentNext = Some(f(s, currentNext));
              when(!labelMap.ContainsKey(id.ToString()))
                labelMap.Add(id.ToString(), currentNext.Value);
              currentNext.Value;
            } else ""
          | Label(id, body) =>
            def label = f(body, next);
            when(!labelMap.ContainsKey(id.ToString()))
              labelMap.Add(id.ToString(), label);
            label;
          | If(cond, bdy, els) =>
            def bdyLabel = f(bdy, next);
            def elsLabel = f(els, next);
            def newExpr = JsAst.If(cond, getGotoToLabel(bdyLabel), getGotoToLabel(elsLabel));
            def newLabel = getNewLabel();
            exprList.Add(new (label = newLabel, expr = newExpr, next = next));
            newLabel;
          | Goto(id) =>
            def newLabel = getNewLabel();            
            exprList.Add(new (label = newLabel, expr = getGotoToLabel(id), next = next));
            newLabel;            
          | TryFinally(body, _handler) => 
            f(body, next);            
          | _ =>
            def newLabel = getNewLabel();
            exprList.Add(new (label = newLabel, expr = current, next = next));
            newLabel;
          }
        }
        
        _ = f(ast, None());
        def reversedExprs = Enumerable.Reverse(exprList).ToList();
        def createSwitchCase(e) {
          match(e.next)
          {
          | Some(next) => JsAst.Seq([
              e.expr,
              getGotoToLabel(next)
            ]);
          | None() => 
            JsAst.Seq([
              e.expr,
              JsAst.BreakNamed(loopName)
            ]);
          }
        }
        def firstLabel = if(reversedExprs.Count > 0) reversedExprs[0].label else "";
        def resultAst = JsAst.Seq([
          JsAst.DefValue(currentLabelVar, JsAst.Literal(JsLiteral.String(firstLabel))),
          JsAst.WhileNamed(JsAst.Literal(JsLiteral.Bool(true)), 
            JsAst.Switch(
              JsAst.LocalRef(currentLabelVar, None()),               
              reversedExprs.Select(e => JsAst.SwitchCase(e.label, createSwitchCase(e))).NToList(),
              JsAst.Void()),
            loopName)
        ]);
        def resultAst' = JsAst.Recurse(resultAst, (ast : JsAst, _) => 
          match(ast) {
          | Assign(l, Literal(JsLiteral.String(label))) 
            when label.StartsWith("__CHECK_LABEL__") => 
            def label = label.Replace("__CHECK_LABEL__", "");
            def label = if(labelMap.ContainsKey(label)) labelMap[label] else label;
            JsAst.Assign(l, JsAst.Literal(JsLiteral.String(label)))
          | _ => ast
          }
        );
        
        resultAst'
      }
      else 
        ast
    }
    
    public DelayAssignment(expr : JsAst, left : JsAst) : JsAst
    {
        def delayAssignment = DelayAssignment(_, left);
        match(expr)
        {
        | Seq(exprs) => 
            def newExprs =
              match(exprs.Rev())
              {
              | (JsAst.Unpack as u) :: (JsAst.Call as c) :: rest => u :: delayAssignment(c) :: rest
              | last :: allButLast => delayAssignment(last) :: allButLast
              | r => r
              };
            JsAst.Seq(newExprs.Rev())
        | TryFinally(body, handler) => JsAst.TryFinally(delayAssignment(body), handler)
        | Assign(l, r)     => JsAst.Assign(l, delayAssignment(r))
        | If(c, t, e)      => JsAst.If(c, delayAssignment(t), delayAssignment(e))
        | ServerCall(m, t, ps, c) => JsAst.ServerCall(m, t, ps.Map(p => (p[0], delayAssignment(p[1]))), delayAssignment(c))
        | Switch(e, cases, deflt) => JsAst.Switch(e, cases.Map(c => JsAst.SwitchCase(c.Id, delayAssignment(c.Body))), delayAssignment(deflt))
        | WhileNamed(c, b, n) => 
            def newBody =
              match(b)
              {
              | Seq(bodyItems) => 
                  def newItems =
                    match(bodyItems.Rev())
                    {
                    | Break :: secondToLast :: rest => JsAst.Break() :: delayAssignment(secondToLast) :: rest;
                    | last :: rest => delayAssignment(last) :: rest;
                    | [] => []
                    };
                  JsAst.Seq(newItems.Rev())
              | something => JsAst.Assign(left, delayAssignment(something))
              };
            JsAst.WhileNamed(c, newBody, n)
        | Label(id, body) => JsAst.Label(id, delayAssignment(body))
        | Void => JsAst.Void()
        | e when JsAst.AllowedForAssignment.Contains(e.GetType()) => JsAst.Assign(left, e)
        | Undefined
        | _ => expr
        }
    }
    
    public MakeReturn(ast : JsAst) : JsAst 
    {
      | Void => ast
      | _ =>
        JsAst.Seq([
          JsAst.DefValue("__returnValue", JsAst.Void()),
          DelayAssignment(ast, JsAst.LocalRef("__returnValue", None())),
          JsAst.Return(JsAst.LocalRef("__returnValue", None()))
        ])
    }
    
    public MakeReturningFunction(ast : JsAst) : JsAst
    {
      | _ => JsAst.DefFunction(JsAst.Void(), [], MakeReturn(ast))
    }
    
    public Append(ast : JsAst, toAppend : JsAst) : JsAst
    {
      match(ast) 
      {
      | Seq(xs) => JsAst.Seq(xs.Append([toAppend]))
      | _ => JsAst.Seq([ast, toAppend])
      }
    }
    
    // Call toString JS method with some optimization for strings.
    public JsToString(arg : JsAst) : JsAst
    {
      | JsAst.Literal(JsLiteral.String) => arg        
      | JsAst.LocalRef(_, Some(type)) when type.TryRequire(JsClass.StringType) => arg
      | _ => arg.MethodCall("toString", [])
    }
    
    /// Call user ToString if exist
    public ExternalToString(typeInfo : TypeInfo, [NotNull] left : JsAst, [NotNull] parms : list[JsAst]) : JsAst
    {       
      def isFrameworkAssembly(typeInfo)
      {
        if (typeInfo.SystemType == null) false
        else
        {
          def token = typeInfo.SystemType.Assembly.GetName().GetPublicKeyToken();
        
          def msClrToken = array[0xb7 : byte, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89];
          def msFxToken = array[0xb0 : byte, 0x3f, 0x5f, 0x7f, 0x11, 0xd5, 0x0a, 0x3a];
       
          token.SequenceEqual(msClrToken) || token.SequenceEqual(msFxToken);
        }
      }      
      
      // If type has method ToString, use it
      if (typeInfo != null && !isFrameworkAssembly(typeInfo) &&
        { 
          def members = typeInfo.GetMembers(
            BindingFlags.Instance |
            BindingFlags.Public |
            BindingFlags.NonPublic |
            BindingFlags.DeclaredOnly);
          members.Any(m => m.Name == "ToString") })
        left.ExternalMethodCall("ToString", parms)
      else
        JsAstHelper.JsToString(left)
    }
    
    public GetTemporaryVariableName() : string 
    {
        temporaryVariableCounter++;
        $"_N_T_temp_var_$temporaryVariableCounter";
    }
    
    public IterateAST(ast : JsAst) : List[JsAst] 
    {
        def lst = List();
        _ = JsAst.Recurse(ast, (a, _depth) => {
            lst.Add(a);
            a
        });
        lst
    }
  }
}
