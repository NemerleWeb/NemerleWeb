using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NemerleWeb
{
  [Record(NotNull = [".*"])]
  public class JsClass
  {
      public ClassType : TypeBuilder { get; }
      public Indent : string    { get; }      
      public Typer : Typer { get; }
      
      public static StringType : TypeVar { get; set; }
      public static IEnumerableType : TypeVar { get; set; }        
      public static IPageType : TypeVar { get; set; }
      public static ObjectType : TypeVar { get; set; }
        
      public Fields : IEnumerable[IField]
      {
        get
        {
          ClassType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                   .Where(f => f.Name != "server" && f.Name != "__constructorParams")
        }
      }
      
      public StaticFields : IEnumerable[IField]
      {
        get
        {
          ClassType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
                   .Where(f => f.Name != "server" && f.Name != "__constructorParams")
        }
      }
        
      public Properties : IEnumerable[IProperty] 
      {
        get
        {
          ClassType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                    .Where(_ is PropertyBuilder)
                    .Where(p => p.Name != "server")
        }
      }
      
      public StaticProperties : IEnumerable[IProperty] 
      {
        get
        {
          ClassType.GetProperties(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
                    .Where(_ is PropertyBuilder)
                    .Where(p => p.Name != "server")
        }
      }      
        
      public Methods : IEnumerable[IMethod] 
      {
        get
        {            
          def methods = ClassType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
          FilterMethods(methods);
        }
      }
      
      public StaticMethods : IEnumerable[IMethod] 
      {
        get
        {            
          def methods = ClassType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Static| BindingFlags.Public | BindingFlags.NonPublic);
          FilterMethods(methods);
        }
      }
        
      IsPage : bool { get { !ClassType.Name.StartsWith("_N_") } }
        
      public Constructor : IMethod { 
          get {
              def constructors = ClassType.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
              when(constructors.Length > 1)
                    Message.Error(ClassType.Location, "Multiple constructors are not supported");  
              constructors.FirstOrDefault()
          }
      }
        
      public Write() : string 
      {
        def isAbstract = this.ClassType.IsAbstract;
        def properTypeName = GetProperName(ClassType);
        def parentPtr = if(isAbstract) properTypeName + ".prototype" else "this";
        def bodyIndent = Indent + "  ";
        def constructorParams = GetConstructorParams();
        def properties = GetProperties(bodyIndent, parentPtr);
        def staticProperties = GetStaticProperties(Indent);
        def fields = GetFields(bodyIndent, parentPtr);
        def staticFields = GetStaticFields(Indent);
        def constructorBody = GetConstructorBody(bodyIndent);
        def staticConstructorBody = GetStaticConstructorBody(Indent);
        def methods = GetMethods(bodyIndent, parentPtr, !isAbstract);
        def staticMethods = GetStaticMethods(Indent);        
        def (nestedClassesString, nestedClasses) = GetNestedClasses();
          
        def returning = match(ClassType.BaseType?.Name) {
            | "Function" => bodyIndent + 
/*<#return function() {
return self.apply.apply(self, arguments);
}#>*/
<#return self.apply;#>
            | "FunctionVoid" => bodyIndent + 
/*<#return function() {
return self.apply_void.apply(self, arguments);
}#>*/
<#return self.apply_void;#>
            | _ => ""
        };
          
        if(isAbstract)
        {
          def commonProps = 
            nestedClasses.Select(c => 
              string.Join(Environment.NewLine, 
                          Properties.Select(p => $"$(GetProperName(c.ClassType)).prototype.$(p.Name) = $properTypeName.prototype.$(p.Name);")));
          def commonFields = 
            nestedClasses.Select(c => 
              string.Join(Environment.NewLine, 
                          Fields.Select(p => $"$(GetProperName(c.ClassType)).prototype.$(p.Name) = $properTypeName.prototype.$(p.Name);")));
          def commonMethods = 
            nestedClasses.Select(c => 
              string.Join(Environment.NewLine, 
                          Methods.Select(p => $"$(GetProperName(c.ClassType)).prototype.$(p.Name) = $properTypeName.prototype.$(p.Name);")));
$<#
$nestedClassesString
$(Indent)function $(GetProperName(ClassType))(..$constructorParams) {
$(bodyIndent)var self = this;
$(bodyIndent)$constructorBody
$(bodyIndent) {{{SignalR}}}
$(bodyIndent)$returning
$(Indent)}
$properties
..$(commonProps; Environment.NewLine)
$fields
..$(commonFields; Environment.NewLine)
$methods
..$(commonMethods; Environment.NewLine)
$staticFields
$staticConstructorBody
$staticMethods
$staticProperties
#>
        }
        else
        {
$<#
$nestedClassesString
$(Indent)function $(GetProperName(ClassType))(..$constructorParams) {
$(bodyIndent)var self = this;
$properties
$fields
$methods
$constructorBody
{{{SignalR}}}
$returning
$(Indent)}
$staticFields
$staticConstructorBody
$staticMethods
$staticProperties
#>
        }
      }
        
      GetConstructorParams() : list[string] 
      { 
          def ctor = Constructor;
          if(ctor != null) ctor.GetParameters().Map(p => p.Name) else [];            
      }
      
      static PropVal(prop : IProperty) : string
      {
        def type = prop.GetGetter().ReturnType;
        def isArray = TypeIsArray(type);
        if(isArray) 
          "[]" 
        else 
          if(type.TypeInfo.FullName == "System.String") <#""#> 
          else if(type.TypeInfo.FullName == "System.Boolean") "false"
          else if(type.TypeInfo.FullName == "System.Int32") "0" else "null";
      }
      
      GenerateProperties(indent : string, parentPtr : string, properties : IEnumerable[IProperty]) : string 
      {
        def propStrings = properties.Select(p =>
          {
            when (p.IsIndexer)
              Message.Error(p.Location, $"Indexed properties are not supported, $p");
            
            def sb = StringBuilder();
            
            when (p.GetGetter() != null)
            {
              def getterBody = TranslateMethodBody(p.GetGetter(), indent + "  ");
              _ = sb.AppendLine(
$<#$indent$parentPtr.get_$(p.Name) = function() {
$getterBody
$indent};#>);
            }
          
            when (p.GetSetter() != null)
            {
              def setterBody = TranslateMethodBody(p.GetSetter(), indent + "  ");
              _ = sb.AppendLine(
$<#$indent$parentPtr.set_$(p.Name) = function(value) {
$setterBody
$indent};#>);
            }
            
            sb.ToString()
          });
          
        $<#..$(propStrings; "\n")#>;
      }
      
      GetProperties(indent : string, parentPtr : string) : string
      {
        GenerateProperties(indent, parentPtr, Properties)
      }
      
      GetStaticProperties(indent : string) : string 
      {
        GenerateProperties(indent, GetProperName(ClassType), StaticProperties)
      }
      
      FieldValue(field : IField) : string
      {
        def type = field.GetMemType();
        def isArray = TypeIsArray(type);
        if(isArray) 
          "[]" 
        else
        {
          match(type.TypeInfo?.FullName)
          {
          | "System.Byte"
          | "System.SByte"
          | "System.Char"
          | "System.Int16"
          | "System.UInt16"
          | "System.Int32"
          | "System.UInt32"
          | "System.Int64"
          | "System.UInt64"
          | "System.Single"
          | "System.Double"
          | "System.Decimal"=> "0"
          | _ => "null"
          }
        }
      }
      
      GenerateFields(indent : string, parentPtr : string, fields: IEnumerable[IField]) : string
      {
        def fieldStrings = fields.Select(f => $<#$indent$parentPtr.$(f.Name) = $(FieldValue(f))#>);
        
        $<#..$(fieldStrings; ";\n")#>;
      }
        
      GetFields(indent : string, parentPtr : string) : string 
      {
        GenerateFields(indent, parentPtr, Fields)
      }
        
      GetStaticFields(indent : string) : string 
      {
        def parentPtr = GetProperName(ClassType);
        def fieldStrings = StaticFields.Select(f => 
          {
            // HACK: Hack for Instance initializers of lambda
            if (ClassType.Name.Contains("_N__N_lambda__") && f.Name == "Instance")
              $<#$indent$parentPtr.$(f.Name) = new $parentPtr()#>
            else
              $<#$indent$parentPtr.$(f.Name) = $(FieldValue(f))#>
          });
        
        $<#..$(fieldStrings; ";\n")#>;
      }
        
      GetConstructorBody(indent : string) : string
      {
          def ctor = Constructor;
          if(ctor != null)
          {
              def ctorBody = TranslateMethodBody(ctor, indent);
              def endIndex = ctorBody.IndexOf("js constructor end");
              if(endIndex != -1) ctorBody.Substring(0, endIndex - 1) else ctorBody
          }
          else
              ""
      }
        
      GetStaticConstructorBody(indent : string) : string 
      {
          def ctors = ClassType.GetConstructors(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
          def ctor = ctors.FirstOrDefault();
          if(ctor != null)
            TranslateMethodBody(ctor, indent)
          else
            ""
      }
      
      GenerateMethods(indent : string, parentPtr : string, hasSelf : bool, methods : IEnumerable[IMethod]) : string 
      {
        def self = if(hasSelf) "" else "var self = this;";
        def methodParms(method) { method.GetParameters().Select(p => p.Name); }
        def m = methods.Select(m => 
$<#$(indent)$parentPtr.$(m.Name) = function(..$(methodParms(m))) { 
$(indent)  $self
$(TranslateMethodBody(m, indent + "  "))
$(indent)}#>);

          $<#..$(m; "\n")#>
      }
        
      GetMethods(indent : string, parentPtr : string, hasSelf : bool) : string 
      {
        GenerateMethods(indent, parentPtr, hasSelf, Methods)
      }
      
      GetStaticMethods(indent : string) : string 
      {
        GenerateMethods(indent, GetProperName(ClassType), false, StaticMethods)
      }
      
      GetNestedClasses() : (string * IEnumerable[JsClass])
      {            
          def nested = ClassType.DeclaredNestedTypes
                                .Where(c => c.Name != "Server" && c.Name != "ServerProxy") //Not server
                                .Where(c => !c.Name.StartsWith("_N__N_")) //Not generated class
                                .Select(c => JsClass(c, Indent, Typer))
                                .ToList();
          ($"..$(nested; Environment.NewLine; _.Write())", nested)
      }
      
      ApplyAttributesToGeneratedClasses() : void
      {
          ClassType.DeclaredNestedTypes
                   .Where(t => t.Name.StartsWith("_N__N_"))
                   .Iter(t => t.Ast.AddCustomAttribute(<[ NemerleWeb.GeneratedClass ]>));
      }
                
      public TranslateMethodBody([NotNull] meth : IMethod, [NotNull] indent = "" : string) : string
      {
        def ast = TyperHelper.GetMethodJsAst(meth, Typer, ClassType);
        ast.Write(indent);
      }
      
      public static TypeIsArray([NotNull] typeVar : TypeVar) : bool 
      {
        typeVar.TryRequire(IEnumerableType) && !typeVar.TryRequire(StringType);
      }
      
      public static GetProperName([NotNull] typeInfo : TypeInfo) : string 
      {          
        def typeParams = if(typeInfo.Typarms.IsEmpty) "";
                         else $"[..$(typeInfo.Typarms.MapToArray(t => t.ToString()))]";
        GetProperName(typeInfo.FullName + typeParams)
      }
        
      public static GetProperName([NotNull] type : Type) : string 
      {
        GetProperName(type.FullName)
      }
        
      public static GetProperName([NotNull] fullName : string) : string
      {          
        fullName.Replace(" ", "")
                .Replace(".", "_")
                .Replace("+", "_")
                .Replace("[", "_$")
                .Replace("]", "$_")
                .Replace(",", "$$")
      }
        
      public static FilterMethods([NotNull] methods : IEnumerable[IMethod]) : IEnumerable[IMethod]
      {
        def pageMethods = typeof(IPage).GetMethods().Select(m => m.Name);
        methods.Where(m => !m.Name.StartsWith("get_") && !m.Name.StartsWith("set_"))
               .Where(m => !m.IsCustomAttributeDefined("NemerleWeb.IgnoreAttribute"))
               .Where(m => !m.IsConstructor)
               .Where(m => !pageMethods.Contains(m.Name))
               .Where(m => m.Name != "View")
               .Where(m => !(m.Name.StartsWith("_N__") && m.Name.EndsWith("____")))
      }
  }
}
