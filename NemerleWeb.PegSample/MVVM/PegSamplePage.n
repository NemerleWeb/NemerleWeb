using NemerleWeb;
using Nemerle.Extensions;
using System;
using System.Collections.Generic;
using SCG = System.Collections.Generic;
using System.Linq;

using Nemerle.Peg;

namespace Calculator
{
  [Unit]
  [PegGrammar(Options = EmitDebugSources, implicitMul,
  grammar
  {
    letters               = ['a'..'z', 'A'..'Z'];
    limit_arg    : string = (letter / operator / limit)+;
    letter       : string = letters;
    operator     : string = "#sin()" letter+;
    limit        : string = "#lim()##low(" implicitMul "#to()" implicitMul ")" limit_arg;
    implicitMul  : string = (letter / operator / limit)+;
  })]
  class P
  {
    limit_arg(_ : List[string]) : string
    {
      ""
    }
    letter(_ : NToken) : string
    {
      ""
    }
    operator(_ : NToken, _ : List[string]) : string
    {
      ""
    }
    limit(_ : NToken, _ : string, _ : NToken, _ : string, _ : NToken, _ : string) : string
    {
      ""
    }
    implicitMul(_ : List[string]) : string
    {
      ""
    }
    
    // TODO: Remove
    // Generated by macro
    public TryParse(text : string) : int * string
    {
      TryParse(SourceSnapshot(text, text, 0, "", SourceSnapshot.MakeLineIndexes(text)))
    }
    
    public TryParse(source : Nemerle.Peg.SourceSnapshot) : int * string
    {
      ResetMemoization();
      ResetMaxRollbackPos();
      _parsingSource = source;
      mutable result;
      def pos = __GENERATED_PEG__RULE__implicitMul__(0, _parsingSource.Text, ref result);
      (pos, result)
    }

  }

  [Unit]
  [PegGrammar(Options = EmitDebugSources,
    rule1,
    grammar
    {
      rule1 : SCG.List[int] = rule11+ / rule12;
      rule11 : int = any;
      rule12 : SCG.List[int] = any;
      any = ['\u0000'..'\uFFFF'];
    }
  )]
  class Parser
  {
    rule1(@list : SCG.List[int]) : SCG.List[int]
    {
      @list;
    }
    
    rule11(_ : NToken) : int
    {
      1;
    }
    
    rule12(_ : NToken) : SCG.List[int]
    {
      SCG.List();
    }
    
    // TODO: Remove
    // Generated by macro
    public TryParse(text : string) : int * System.Collections.Generic.List[int]
    {
      TryParse(Nemerle.Peg.SourceSnapshot(text, text, 0, "", Nemerle.Peg.SourceSnapshot.MakeLineIndexes(text)))
    }

    public TryParse(source : Nemerle.Peg.SourceSnapshot) : int * System.Collections.Generic.List[int]
    {
      ResetMemoization();
      ResetMaxRollbackPos();
      _parsingSource = source;
      mutable result;
      def pos = __GENERATED_PEG__RULE__rule1__(0, _parsingSource.Text, ref result);
      (pos, result)
    }
  }
  
  type LoopTokens = NToken * int;
  
  [Record] public class ParserFatalError : Exception
  {
    public Pos     : int;
  }
  
  public class FakeGrammar { }
  
  /// <summary>
  /// Description of CalcParser.
  /// </summary>  
  [Unit]
  [PegGrammar( Options = EmitDebugSources, start, 
  grammar
  {
    s : void              = ' '*;

    [Extensible(a)]
    expr                  : int;

    num                   is expr = ['0'..'9']+ s;

    unaryMinus            is expr = '-'s expr : 30;

    parenthesesExpr       is expr = '('s expr ')'s;

    sum                   is expr = expr : 10 '+' expr : 10;
    sub                   is expr = expr : 10 '-' expr : 10;
    mul                   is expr = expr : 20 '*' expr : 20;
    div                   is expr = expr : 20 '/' expr : 20;

    start                 : int = s expr ![Any];
  })]
  public class CalcParser
  {
    private num(digits : NToken) : int
    {
      int.Parse(GetText(digits))
    }

    private unaryMinus(_ : NToken, se : int) : int
    {
      -se
    }

    private parenthesesExpr(_ : NToken, se : int, _ : NToken) : int
    {
      se
    }

    private sum(x : int, _ : NToken, y : int) : int { x + y }
    private sub(x : int, _ : NToken, y : int) : int { x - y }
    private mul(x : int, _ : NToken, y : int) : int { x * y }
    private div(x : int, _ : NToken, y : int) : int { x / y }
    
    // TODO: Remove
    // Generated by macro
    public TryParse(text : string) : int * int
    {
      TryParse(Nemerle.Peg.SourceSnapshot(text, text, 0, "", Nemerle.Peg.SourceSnapshot.MakeLineIndexes(text)))
    }

    // Calculator.CalcParser
    public TryParse(source : Nemerle.Peg.SourceSnapshot) : int * int
    {
      ResetMemoization();
      ResetMaxRollbackPos();
      _parsingSource = source;
      mutable result;
      def pos = __GENERATED_PEG__RULE__start__(0, _parsingSource.Text, ref result);
      (pos, result)
    }
  }
}

namespace NemerleWeb.PegSample
{
  [Page]
  public class PegSamplePage
  {
    _calc : Calculator.CalcParser = Calculator.CalcParser();
     
    CalcInput : string { get; set; }
    CalcOutput : string { get; set; }
     
    public Calculate() : void
    {
      CalcOutput = if (_calc.Parse(CalcInput) is Some(res)) res.ToString() else "Incorrect input";
    }
     
    public $CalcKeypress(e : EventData) : void
    {
      when(e.which == 13) Calculate();
    }
    
    [Html]
    public View() : string
    {
      <#
        <div>
          <div class="output">
            <span class="output-text">$CalcOutput</span> 
          </div>
          <div class="calc-input">
            <input value="$CalcInput" event-keypress="$CalcKeypress" />
            <button click="$Calculate" disable="$(string.IsNullOrEmpty(CalcInput))" class="btn btn-info">Calculate</button>
          </div>
        </div>
      #>
    }    
  }
}
