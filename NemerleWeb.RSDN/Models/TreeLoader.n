using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Text;
using System.IO;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Xml.Linq;
using System.Web;

namespace NemerleWeb.Rsdn
{
  module TreeLoader
  {
    _tree : TreeNode;
    _childrenById : ConcurrentDictionary[string, List[TreeNode]] = ConcurrentDictionary();
    _searchTerms : SortedDictionary[string, int] = SortedDictionary();
    _searchTermResults : ConcurrentDictionary[string, List[TreeNode]] = ConcurrentDictionary();
    
    this()
    {
      def xml = File.ReadAllText(HttpContext.Current.Server.MapPath("~/App_Data/tree.xml"), Encoding.GetEncoding("windows-1251"));
      def readNodes(element, depth) : TreeNode {        
        def childNodes = element.Elements("node").Select(e => readNodes(e, depth + 1)).ToList();
        
        if(element.Name.LocalName == "tree") 
          TreeNode() <- ( Children = childNodes ) 
        else {
          def id = element.Attribute("id")?.Value;
          
          _ = _childrenById.TryAdd(id, childNodes.Select(CloneNoChildren).ToList());
          
          TreeNode() <- (           
            Id = id,
            Caption = element.Attribute("caption")?.Value,
            Href = element.Attribute("href")?.Value,
            Icon = element.Attribute("icon")?.Value,
            Hide = element.Attribute("hide")?.Value == "1",
            HasChildren = childNodes.Count > 0,
            Depth = depth,
            Children = childNodes,
          );
        }
      }
      
      _tree = readNodes(XDocument.Parse(xml).Root, 0);
    }
        
    public GetTopNodes() : List[TreeNode]
    {      
      _tree.Children.Select(CloneNoChildren).ToList()
    }

    public LoadNodeChildren(id : string) : List[TreeNode]
    {
      _childrenById.GetOrAdd(id, List());
    }
    
    public Search(term : string) : List[TreeNode]
    {
      lock(_searchTerms) {
        if(_searchTerms.ContainsKey(term))
          _searchTerms[term]++;
        else
          _searchTerms.Add(term, 0);
      }
      
      lock(_searchTermResults) {
        _searchTermResults.GetOrAdd(term, _ => {
          _tree.Children.Select(c => CreateTreeBySearchTerm(term, c)).ToList();
        });
      }
    }
    
    CreateTreeBySearchTerm(term : string, node : TreeNode) : TreeNode
    {     
      mutable nodeChildren;
      
      if(_childrenById.TryGetValue(node.Id, out nodeChildren) && nodeChildren.Count > 0) {        
        def result = CloneNoChildren(node);
        def children = nodeChildren.Select(c => CreateTreeBySearchTerm(term, c)).ToList();
        result.IsOpened = children.Any(_.IsOpened) || node.Caption.Contains(term);
        result.Children = if(result.IsOpened) children.Where(c => c.IsOpened).ToList() else null;
        result
      }
      else {
        def result = CloneNoChildren(node);
        result.IsOpened = node.Caption.Contains(term);
        result;
      }
    }
    
    CloneNoChildren(node : TreeNode) : TreeNode
    {
      TreeNode() <- (
        Id = node.Id,
        Caption = node.Caption,
        Href = node.Href,
        Icon = node.Icon,
        Hide = node.Hide,
        Depth = node.Depth,
        HasChildren = node.HasChildren        
      )      
    }
  }
}
